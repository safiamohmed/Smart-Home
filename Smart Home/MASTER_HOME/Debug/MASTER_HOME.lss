
MASTER_HOME.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000544c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00800060  0000544c  000054e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000068f  0080012a  0080012a  000055aa  2**0
                  ALLOC
  3 .stab         00007d28  00000000  00000000  000055ac  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000036ba  00000000  00000000  0000d2d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  0001098e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  00010ace  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  00010c3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00012887  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00013772  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00014520  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00014680  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  0001490d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  000150db  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 05 1e 	jmp	0x3c0a	; 0x3c0a <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d4 e0       	ldi	r29, 0x04	; 4
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ec e4       	ldi	r30, 0x4C	; 76
      68:	f4 e5       	ldi	r31, 0x54	; 84
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	aa 32       	cpi	r26, 0x2A	; 42
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	aa e2       	ldi	r26, 0x2A	; 42
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a9 3b       	cpi	r26, 0xB9	; 185
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 83 18 	call	0x3106	; 0x3106 <main>
      8a:	0c 94 24 2a 	jmp	0x5448	; 0x5448 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 ce 29 	jmp	0x539c	; 0x539c <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a4 ef       	ldi	r26, 0xF4	; 244
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 ea 29 	jmp	0x53d4	; 0x53d4 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 da 29 	jmp	0x53b4	; 0x53b4 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 da 29 	jmp	0x53b4	; 0x53b4 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 ce 29 	jmp	0x539c	; 0x539c <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__stack+0x3f>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__stack+0x55>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__stack+0x2d>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__stack+0x3f>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__stack+0x35>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__stack+0x3b>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__stack+0x55>
     494:	84 ef       	ldi	r24, 0xF4	; 244
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__stack+0x1c7>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__stack+0x51>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__stack+0x1c7>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__stack+0x67>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__stack+0x1c7>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__stack+0xd3>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__stack+0xc7>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__stack+0xef>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__stack+0x109>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__stack+0x8f>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__stack+0x14d>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__stack+0x141>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__stack+0x11f>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__stack+0x16b>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__stack+0x153>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__stack+0x1ad>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__stack+0x1ad>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__stack+0x1ad>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__stack+0x1b7>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 ea 29 	jmp	0x53d4	; 0x53d4 <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 da 29 	jmp	0x53b4	; 0x53b4 <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 da 29 	jmp	0x53b4	; 0x53b4 <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 da 29 	jmp	0x53b4	; 0x53b4 <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 f6 29 	jmp	0x53ec	; 0x53ec <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 de 29 	jmp	0x53bc	; 0x53bc <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 fa 29 	jmp	0x53f4	; 0x53f4 <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__pack_f+0x178>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__pack_f+0x172>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__pack_f+0x17c>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__pack_f+0x114>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__pack_f+0x76>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__pack_f+0xca>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__pack_f+0x86>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__pack_f+0x7e>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__pack_f+0x9c>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__pack_f+0x94>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__pack_f+0xbe>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__pack_f+0xee>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__pack_f+0xf6>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__pack_f+0xf6>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__pack_f+0x10e>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__pack_f+0x162>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__pack_f+0x172>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__pack_f+0x144>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__pack_f+0x154>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__pack_f+0x14c>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__pack_f+0x162>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__pack_f+0x164>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__pack_f+0x17c>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <ADC_voidInit>:
#include"ADC_private.h"
#include"ADC_register.h"


void  ADC_voidInit(void)
{
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62
#if VOLT_REF==1
	CLR_BIT(ADMUX,ADMUX_REFS0);
	CLR_BIT(ADMUX,ADMUX_REFS1);

#elif VOLT_REF==2
	SET_BIT(ADMUX,ADMUX_REFS0);
     b4e:	a7 e2       	ldi	r26, 0x27	; 39
     b50:	b0 e0       	ldi	r27, 0x00	; 0
     b52:	e7 e2       	ldi	r30, 0x27	; 39
     b54:	f0 e0       	ldi	r31, 0x00	; 0
     b56:	80 81       	ld	r24, Z
     b58:	80 64       	ori	r24, 0x40	; 64
     b5a:	8c 93       	st	X, r24
	CLR_BIT(ADMUX,ADMUX_REFS1);
     b5c:	a7 e2       	ldi	r26, 0x27	; 39
     b5e:	b0 e0       	ldi	r27, 0x00	; 0
     b60:	e7 e2       	ldi	r30, 0x27	; 39
     b62:	f0 e0       	ldi	r31, 0x00	; 0
     b64:	80 81       	ld	r24, Z
     b66:	8f 77       	andi	r24, 0x7F	; 127
     b68:	8c 93       	st	X, r24
    #error "Wrong Choose TO Voltage Reference"
#endif

	/*Set Prescaler Devision Factor*/
		/*Using Bit_Masked*/
		ADCSRA &=0b11111000;
     b6a:	a6 e2       	ldi	r26, 0x26	; 38
     b6c:	b0 e0       	ldi	r27, 0x00	; 0
     b6e:	e6 e2       	ldi	r30, 0x26	; 38
     b70:	f0 e0       	ldi	r31, 0x00	; 0
     b72:	80 81       	ld	r24, Z
     b74:	88 7f       	andi	r24, 0xF8	; 248
     b76:	8c 93       	st	X, r24
		ADCSRA |=PRESC;
     b78:	a6 e2       	ldi	r26, 0x26	; 38
     b7a:	b0 e0       	ldi	r27, 0x00	; 0
     b7c:	e6 e2       	ldi	r30, 0x26	; 38
     b7e:	f0 e0       	ldi	r31, 0x00	; 0
     b80:	80 81       	ld	r24, Z
     b82:	87 60       	ori	r24, 0x07	; 7
     b84:	8c 93       	st	X, r24

	/*Activate Left Adjust Result*/
	SET_BIT(ADMUX,ADMUX_ADLAR);
     b86:	a7 e2       	ldi	r26, 0x27	; 39
     b88:	b0 e0       	ldi	r27, 0x00	; 0
     b8a:	e7 e2       	ldi	r30, 0x27	; 39
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	80 81       	ld	r24, Z
     b90:	80 62       	ori	r24, 0x20	; 32
     b92:	8c 93       	st	X, r24
	/* Set ADC Enable State*/
#if  ADCSRA_ADEN_State==Enable
	SET_BIT(ADCSRA,ADCSRA_ADEN);
     b94:	a6 e2       	ldi	r26, 0x26	; 38
     b96:	b0 e0       	ldi	r27, 0x00	; 0
     b98:	e6 e2       	ldi	r30, 0x26	; 38
     b9a:	f0 e0       	ldi	r31, 0x00	; 0
     b9c:	80 81       	ld	r24, Z
     b9e:	80 68       	ori	r24, 0x80	; 128
     ba0:	8c 93       	st	X, r24
    #error "Wrong Choose TO ADC Enable State"

#endif


}
     ba2:	cf 91       	pop	r28
     ba4:	df 91       	pop	r29
     ba6:	08 95       	ret

00000ba8 <ADC_u8GetChannelReading>:

u8    ADC_u8GetChannelReading(u8  copy_u8Channel)
{
     ba8:	df 93       	push	r29
     baa:	cf 93       	push	r28
     bac:	0f 92       	push	r0
     bae:	cd b7       	in	r28, 0x3d	; 61
     bb0:	de b7       	in	r29, 0x3e	; 62
     bb2:	89 83       	std	Y+1, r24	; 0x01
  /*Use Bit_Masked To Choose Channel*/
	  /*1_Clear The Mux Bits in ADMUX*/
	       ADMUX &=0b11100000;
     bb4:	a7 e2       	ldi	r26, 0x27	; 39
     bb6:	b0 e0       	ldi	r27, 0x00	; 0
     bb8:	e7 e2       	ldi	r30, 0x27	; 39
     bba:	f0 e0       	ldi	r31, 0x00	; 0
     bbc:	80 81       	ld	r24, Z
     bbe:	80 7e       	andi	r24, 0xE0	; 224
     bc0:	8c 93       	st	X, r24
	  /*2_Set The Chosen Channel To Mux Bits*/
           ADMUX |= copy_u8Channel;
     bc2:	a7 e2       	ldi	r26, 0x27	; 39
     bc4:	b0 e0       	ldi	r27, 0x00	; 0
     bc6:	e7 e2       	ldi	r30, 0x27	; 39
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	90 81       	ld	r25, Z
     bcc:	89 81       	ldd	r24, Y+1	; 0x01
     bce:	89 2b       	or	r24, r25
     bd0:	8c 93       	st	X, r24


  /*Start Conversion */
    	SET_BIT(ADCSRA,ADCSRA_ADSC);
     bd2:	a6 e2       	ldi	r26, 0x26	; 38
     bd4:	b0 e0       	ldi	r27, 0x00	; 0
     bd6:	e6 e2       	ldi	r30, 0x26	; 38
     bd8:	f0 e0       	ldi	r31, 0x00	; 0
     bda:	80 81       	ld	r24, Z
     bdc:	80 64       	ori	r24, 0x40	; 64
     bde:	8c 93       	st	X, r24

  /*Pulling (Busy Waiting) Until Setting The Conversion Flag */
    	while((GET_BIT(ADCSRA,ADCSRA_ADIF))==0);
     be0:	e6 e2       	ldi	r30, 0x26	; 38
     be2:	f0 e0       	ldi	r31, 0x00	; 0
     be4:	80 81       	ld	r24, Z
     be6:	82 95       	swap	r24
     be8:	8f 70       	andi	r24, 0x0F	; 15
     bea:	88 2f       	mov	r24, r24
     bec:	90 e0       	ldi	r25, 0x00	; 0
     bee:	81 70       	andi	r24, 0x01	; 1
     bf0:	90 70       	andi	r25, 0x00	; 0
     bf2:	00 97       	sbiw	r24, 0x00	; 0
     bf4:	a9 f3       	breq	.-22     	; 0xbe0 <ADC_u8GetChannelReading+0x38>

  /*Clear Conversion Flag*/
    	SET_BIT(ADCSRA,ADCSRA_ADIF);
     bf6:	a6 e2       	ldi	r26, 0x26	; 38
     bf8:	b0 e0       	ldi	r27, 0x00	; 0
     bfa:	e6 e2       	ldi	r30, 0x26	; 38
     bfc:	f0 e0       	ldi	r31, 0x00	; 0
     bfe:	80 81       	ld	r24, Z
     c00:	80 61       	ori	r24, 0x10	; 16
     c02:	8c 93       	st	X, r24

   /*Return Reading*/  /*Suppose Using 8bit*/
    	return ADCH;
     c04:	e5 e2       	ldi	r30, 0x25	; 37
     c06:	f0 e0       	ldi	r31, 0x00	; 0
     c08:	80 81       	ld	r24, Z

}
     c0a:	0f 90       	pop	r0
     c0c:	cf 91       	pop	r28
     c0e:	df 91       	pop	r29
     c10:	08 95       	ret

00000c12 <CLCD_voidSendCommand>:
#include "BIT_MATH.h"
#include "CLCD_interface.h"
#include "DIO_INTERFACE.h"
#include <util/delay.h>
void CLCD_voidSendCommand(u8 copy_u8Command)
{
     c12:	df 93       	push	r29
     c14:	cf 93       	push	r28
     c16:	cd b7       	in	r28, 0x3d	; 61
     c18:	de b7       	in	r29, 0x3e	; 62
     c1a:	2f 97       	sbiw	r28, 0x0f	; 15
     c1c:	0f b6       	in	r0, 0x3f	; 63
     c1e:	f8 94       	cli
     c20:	de bf       	out	0x3e, r29	; 62
     c22:	0f be       	out	0x3f, r0	; 63
     c24:	cd bf       	out	0x3d, r28	; 61
     c26:	8f 87       	std	Y+15, r24	; 0x0f
	/*Setting RS pin to low*/
DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_LOW);
     c28:	83 e0       	ldi	r24, 0x03	; 3
     c2a:	60 e0       	ldi	r22, 0x00	; 0
     c2c:	40 e0       	ldi	r20, 0x00	; 0
     c2e:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
/*Setting RW pin low for write*/
DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
     c32:	83 e0       	ldi	r24, 0x03	; 3
     c34:	61 e0       	ldi	r22, 0x01	; 1
     c36:	40 e0       	ldi	r20, 0x00	; 0
     c38:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>

/*Set command data pins*/
DIO_u8SetPortValue(CLCD_DATA_PORT,copy_u8Command);
     c3c:	82 e0       	ldi	r24, 0x02	; 2
     c3e:	6f 85       	ldd	r22, Y+15	; 0x0f
     c40:	0e 94 ce 08 	call	0x119c	; 0x119c <DIO_u8SetPortValue>

/*Send Enable pulse*/
DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
     c44:	83 e0       	ldi	r24, 0x03	; 3
     c46:	62 e0       	ldi	r22, 0x02	; 2
     c48:	41 e0       	ldi	r20, 0x01	; 1
     c4a:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
     c4e:	80 e0       	ldi	r24, 0x00	; 0
     c50:	90 e0       	ldi	r25, 0x00	; 0
     c52:	a0 e0       	ldi	r26, 0x00	; 0
     c54:	b0 e4       	ldi	r27, 0x40	; 64
     c56:	8b 87       	std	Y+11, r24	; 0x0b
     c58:	9c 87       	std	Y+12, r25	; 0x0c
     c5a:	ad 87       	std	Y+13, r26	; 0x0d
     c5c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     c5e:	6b 85       	ldd	r22, Y+11	; 0x0b
     c60:	7c 85       	ldd	r23, Y+12	; 0x0c
     c62:	8d 85       	ldd	r24, Y+13	; 0x0d
     c64:	9e 85       	ldd	r25, Y+14	; 0x0e
     c66:	20 e0       	ldi	r18, 0x00	; 0
     c68:	30 e0       	ldi	r19, 0x00	; 0
     c6a:	4a e7       	ldi	r20, 0x7A	; 122
     c6c:	53 e4       	ldi	r21, 0x43	; 67
     c6e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     c72:	dc 01       	movw	r26, r24
     c74:	cb 01       	movw	r24, r22
     c76:	8f 83       	std	Y+7, r24	; 0x07
     c78:	98 87       	std	Y+8, r25	; 0x08
     c7a:	a9 87       	std	Y+9, r26	; 0x09
     c7c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     c7e:	6f 81       	ldd	r22, Y+7	; 0x07
     c80:	78 85       	ldd	r23, Y+8	; 0x08
     c82:	89 85       	ldd	r24, Y+9	; 0x09
     c84:	9a 85       	ldd	r25, Y+10	; 0x0a
     c86:	20 e0       	ldi	r18, 0x00	; 0
     c88:	30 e0       	ldi	r19, 0x00	; 0
     c8a:	40 e8       	ldi	r20, 0x80	; 128
     c8c:	5f e3       	ldi	r21, 0x3F	; 63
     c8e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     c92:	88 23       	and	r24, r24
     c94:	2c f4       	brge	.+10     	; 0xca0 <CLCD_voidSendCommand+0x8e>
		__ticks = 1;
     c96:	81 e0       	ldi	r24, 0x01	; 1
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	9e 83       	std	Y+6, r25	; 0x06
     c9c:	8d 83       	std	Y+5, r24	; 0x05
     c9e:	3f c0       	rjmp	.+126    	; 0xd1e <CLCD_voidSendCommand+0x10c>
	else if (__tmp > 65535)
     ca0:	6f 81       	ldd	r22, Y+7	; 0x07
     ca2:	78 85       	ldd	r23, Y+8	; 0x08
     ca4:	89 85       	ldd	r24, Y+9	; 0x09
     ca6:	9a 85       	ldd	r25, Y+10	; 0x0a
     ca8:	20 e0       	ldi	r18, 0x00	; 0
     caa:	3f ef       	ldi	r19, 0xFF	; 255
     cac:	4f e7       	ldi	r20, 0x7F	; 127
     cae:	57 e4       	ldi	r21, 0x47	; 71
     cb0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     cb4:	18 16       	cp	r1, r24
     cb6:	4c f5       	brge	.+82     	; 0xd0a <CLCD_voidSendCommand+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     cb8:	6b 85       	ldd	r22, Y+11	; 0x0b
     cba:	7c 85       	ldd	r23, Y+12	; 0x0c
     cbc:	8d 85       	ldd	r24, Y+13	; 0x0d
     cbe:	9e 85       	ldd	r25, Y+14	; 0x0e
     cc0:	20 e0       	ldi	r18, 0x00	; 0
     cc2:	30 e0       	ldi	r19, 0x00	; 0
     cc4:	40 e2       	ldi	r20, 0x20	; 32
     cc6:	51 e4       	ldi	r21, 0x41	; 65
     cc8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     ccc:	dc 01       	movw	r26, r24
     cce:	cb 01       	movw	r24, r22
     cd0:	bc 01       	movw	r22, r24
     cd2:	cd 01       	movw	r24, r26
     cd4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     cd8:	dc 01       	movw	r26, r24
     cda:	cb 01       	movw	r24, r22
     cdc:	9e 83       	std	Y+6, r25	; 0x06
     cde:	8d 83       	std	Y+5, r24	; 0x05
     ce0:	0f c0       	rjmp	.+30     	; 0xd00 <CLCD_voidSendCommand+0xee>
     ce2:	89 e1       	ldi	r24, 0x19	; 25
     ce4:	90 e0       	ldi	r25, 0x00	; 0
     ce6:	9c 83       	std	Y+4, r25	; 0x04
     ce8:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     cea:	8b 81       	ldd	r24, Y+3	; 0x03
     cec:	9c 81       	ldd	r25, Y+4	; 0x04
     cee:	01 97       	sbiw	r24, 0x01	; 1
     cf0:	f1 f7       	brne	.-4      	; 0xcee <CLCD_voidSendCommand+0xdc>
     cf2:	9c 83       	std	Y+4, r25	; 0x04
     cf4:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     cf6:	8d 81       	ldd	r24, Y+5	; 0x05
     cf8:	9e 81       	ldd	r25, Y+6	; 0x06
     cfa:	01 97       	sbiw	r24, 0x01	; 1
     cfc:	9e 83       	std	Y+6, r25	; 0x06
     cfe:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     d00:	8d 81       	ldd	r24, Y+5	; 0x05
     d02:	9e 81       	ldd	r25, Y+6	; 0x06
     d04:	00 97       	sbiw	r24, 0x00	; 0
     d06:	69 f7       	brne	.-38     	; 0xce2 <CLCD_voidSendCommand+0xd0>
     d08:	14 c0       	rjmp	.+40     	; 0xd32 <CLCD_voidSendCommand+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     d0a:	6f 81       	ldd	r22, Y+7	; 0x07
     d0c:	78 85       	ldd	r23, Y+8	; 0x08
     d0e:	89 85       	ldd	r24, Y+9	; 0x09
     d10:	9a 85       	ldd	r25, Y+10	; 0x0a
     d12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     d16:	dc 01       	movw	r26, r24
     d18:	cb 01       	movw	r24, r22
     d1a:	9e 83       	std	Y+6, r25	; 0x06
     d1c:	8d 83       	std	Y+5, r24	; 0x05
     d1e:	8d 81       	ldd	r24, Y+5	; 0x05
     d20:	9e 81       	ldd	r25, Y+6	; 0x06
     d22:	9a 83       	std	Y+2, r25	; 0x02
     d24:	89 83       	std	Y+1, r24	; 0x01
     d26:	89 81       	ldd	r24, Y+1	; 0x01
     d28:	9a 81       	ldd	r25, Y+2	; 0x02
     d2a:	01 97       	sbiw	r24, 0x01	; 1
     d2c:	f1 f7       	brne	.-4      	; 0xd2a <CLCD_voidSendCommand+0x118>
     d2e:	9a 83       	std	Y+2, r25	; 0x02
     d30:	89 83       	std	Y+1, r24	; 0x01
_delay_ms(2);
DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_LOW);
     d32:	83 e0       	ldi	r24, 0x03	; 3
     d34:	62 e0       	ldi	r22, 0x02	; 2
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
}
     d3c:	2f 96       	adiw	r28, 0x0f	; 15
     d3e:	0f b6       	in	r0, 0x3f	; 63
     d40:	f8 94       	cli
     d42:	de bf       	out	0x3e, r29	; 62
     d44:	0f be       	out	0x3f, r0	; 63
     d46:	cd bf       	out	0x3d, r28	; 61
     d48:	cf 91       	pop	r28
     d4a:	df 91       	pop	r29
     d4c:	08 95       	ret

00000d4e <CLCD_voidInit>:

void CLCD_voidInit(void)
{
     d4e:	df 93       	push	r29
     d50:	cf 93       	push	r28
     d52:	cd b7       	in	r28, 0x3d	; 61
     d54:	de b7       	in	r29, 0x3e	; 62
     d56:	2e 97       	sbiw	r28, 0x0e	; 14
     d58:	0f b6       	in	r0, 0x3f	; 63
     d5a:	f8 94       	cli
     d5c:	de bf       	out	0x3e, r29	; 62
     d5e:	0f be       	out	0x3f, r0	; 63
     d60:	cd bf       	out	0x3d, r28	; 61
     d62:	80 e0       	ldi	r24, 0x00	; 0
     d64:	90 e0       	ldi	r25, 0x00	; 0
     d66:	a0 e2       	ldi	r26, 0x20	; 32
     d68:	b2 e4       	ldi	r27, 0x42	; 66
     d6a:	8b 87       	std	Y+11, r24	; 0x0b
     d6c:	9c 87       	std	Y+12, r25	; 0x0c
     d6e:	ad 87       	std	Y+13, r26	; 0x0d
     d70:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     d72:	6b 85       	ldd	r22, Y+11	; 0x0b
     d74:	7c 85       	ldd	r23, Y+12	; 0x0c
     d76:	8d 85       	ldd	r24, Y+13	; 0x0d
     d78:	9e 85       	ldd	r25, Y+14	; 0x0e
     d7a:	20 e0       	ldi	r18, 0x00	; 0
     d7c:	30 e0       	ldi	r19, 0x00	; 0
     d7e:	4a e7       	ldi	r20, 0x7A	; 122
     d80:	53 e4       	ldi	r21, 0x43	; 67
     d82:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     d86:	dc 01       	movw	r26, r24
     d88:	cb 01       	movw	r24, r22
     d8a:	8f 83       	std	Y+7, r24	; 0x07
     d8c:	98 87       	std	Y+8, r25	; 0x08
     d8e:	a9 87       	std	Y+9, r26	; 0x09
     d90:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     d92:	6f 81       	ldd	r22, Y+7	; 0x07
     d94:	78 85       	ldd	r23, Y+8	; 0x08
     d96:	89 85       	ldd	r24, Y+9	; 0x09
     d98:	9a 85       	ldd	r25, Y+10	; 0x0a
     d9a:	20 e0       	ldi	r18, 0x00	; 0
     d9c:	30 e0       	ldi	r19, 0x00	; 0
     d9e:	40 e8       	ldi	r20, 0x80	; 128
     da0:	5f e3       	ldi	r21, 0x3F	; 63
     da2:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     da6:	88 23       	and	r24, r24
     da8:	2c f4       	brge	.+10     	; 0xdb4 <CLCD_voidInit+0x66>
		__ticks = 1;
     daa:	81 e0       	ldi	r24, 0x01	; 1
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	9e 83       	std	Y+6, r25	; 0x06
     db0:	8d 83       	std	Y+5, r24	; 0x05
     db2:	3f c0       	rjmp	.+126    	; 0xe32 <CLCD_voidInit+0xe4>
	else if (__tmp > 65535)
     db4:	6f 81       	ldd	r22, Y+7	; 0x07
     db6:	78 85       	ldd	r23, Y+8	; 0x08
     db8:	89 85       	ldd	r24, Y+9	; 0x09
     dba:	9a 85       	ldd	r25, Y+10	; 0x0a
     dbc:	20 e0       	ldi	r18, 0x00	; 0
     dbe:	3f ef       	ldi	r19, 0xFF	; 255
     dc0:	4f e7       	ldi	r20, 0x7F	; 127
     dc2:	57 e4       	ldi	r21, 0x47	; 71
     dc4:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     dc8:	18 16       	cp	r1, r24
     dca:	4c f5       	brge	.+82     	; 0xe1e <CLCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     dcc:	6b 85       	ldd	r22, Y+11	; 0x0b
     dce:	7c 85       	ldd	r23, Y+12	; 0x0c
     dd0:	8d 85       	ldd	r24, Y+13	; 0x0d
     dd2:	9e 85       	ldd	r25, Y+14	; 0x0e
     dd4:	20 e0       	ldi	r18, 0x00	; 0
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	40 e2       	ldi	r20, 0x20	; 32
     dda:	51 e4       	ldi	r21, 0x41	; 65
     ddc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     de0:	dc 01       	movw	r26, r24
     de2:	cb 01       	movw	r24, r22
     de4:	bc 01       	movw	r22, r24
     de6:	cd 01       	movw	r24, r26
     de8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     dec:	dc 01       	movw	r26, r24
     dee:	cb 01       	movw	r24, r22
     df0:	9e 83       	std	Y+6, r25	; 0x06
     df2:	8d 83       	std	Y+5, r24	; 0x05
     df4:	0f c0       	rjmp	.+30     	; 0xe14 <CLCD_voidInit+0xc6>
     df6:	89 e1       	ldi	r24, 0x19	; 25
     df8:	90 e0       	ldi	r25, 0x00	; 0
     dfa:	9c 83       	std	Y+4, r25	; 0x04
     dfc:	8b 83       	std	Y+3, r24	; 0x03
     dfe:	8b 81       	ldd	r24, Y+3	; 0x03
     e00:	9c 81       	ldd	r25, Y+4	; 0x04
     e02:	01 97       	sbiw	r24, 0x01	; 1
     e04:	f1 f7       	brne	.-4      	; 0xe02 <CLCD_voidInit+0xb4>
     e06:	9c 83       	std	Y+4, r25	; 0x04
     e08:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     e0a:	8d 81       	ldd	r24, Y+5	; 0x05
     e0c:	9e 81       	ldd	r25, Y+6	; 0x06
     e0e:	01 97       	sbiw	r24, 0x01	; 1
     e10:	9e 83       	std	Y+6, r25	; 0x06
     e12:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     e14:	8d 81       	ldd	r24, Y+5	; 0x05
     e16:	9e 81       	ldd	r25, Y+6	; 0x06
     e18:	00 97       	sbiw	r24, 0x00	; 0
     e1a:	69 f7       	brne	.-38     	; 0xdf6 <CLCD_voidInit+0xa8>
     e1c:	14 c0       	rjmp	.+40     	; 0xe46 <CLCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     e1e:	6f 81       	ldd	r22, Y+7	; 0x07
     e20:	78 85       	ldd	r23, Y+8	; 0x08
     e22:	89 85       	ldd	r24, Y+9	; 0x09
     e24:	9a 85       	ldd	r25, Y+10	; 0x0a
     e26:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     e2a:	dc 01       	movw	r26, r24
     e2c:	cb 01       	movw	r24, r22
     e2e:	9e 83       	std	Y+6, r25	; 0x06
     e30:	8d 83       	std	Y+5, r24	; 0x05
     e32:	8d 81       	ldd	r24, Y+5	; 0x05
     e34:	9e 81       	ldd	r25, Y+6	; 0x06
     e36:	9a 83       	std	Y+2, r25	; 0x02
     e38:	89 83       	std	Y+1, r24	; 0x01
     e3a:	89 81       	ldd	r24, Y+1	; 0x01
     e3c:	9a 81       	ldd	r25, Y+2	; 0x02
     e3e:	01 97       	sbiw	r24, 0x01	; 1
     e40:	f1 f7       	brne	.-4      	; 0xe3e <CLCD_voidInit+0xf0>
     e42:	9a 83       	std	Y+2, r25	; 0x02
     e44:	89 83       	std	Y+1, r24	; 0x01
	/*Wait more that 30 ms*/
	_delay_ms(40);

	/*Function set ,2 lines AND 5*8 size*/
	CLCD_voidSendCommand(0b00111000);
     e46:	88 e3       	ldi	r24, 0x38	; 56
     e48:	0e 94 09 06 	call	0xc12	; 0xc12 <CLCD_voidSendCommand>
	/*Display on/off control:diplay enable,disable cursor*/
	CLCD_voidSendCommand(0b00001100);
     e4c:	8c e0       	ldi	r24, 0x0C	; 12
     e4e:	0e 94 09 06 	call	0xc12	; 0xc12 <CLCD_voidSendCommand>
	/*display clear*/
	CLCD_voidSendCommand(1);
     e52:	81 e0       	ldi	r24, 0x01	; 1
     e54:	0e 94 09 06 	call	0xc12	; 0xc12 <CLCD_voidSendCommand>



}
     e58:	2e 96       	adiw	r28, 0x0e	; 14
     e5a:	0f b6       	in	r0, 0x3f	; 63
     e5c:	f8 94       	cli
     e5e:	de bf       	out	0x3e, r29	; 62
     e60:	0f be       	out	0x3f, r0	; 63
     e62:	cd bf       	out	0x3d, r28	; 61
     e64:	cf 91       	pop	r28
     e66:	df 91       	pop	r29
     e68:	08 95       	ret

00000e6a <CLCD_voidSendData>:


void CLCD_voidSendData(u8 copy_u8Data)
{
     e6a:	df 93       	push	r29
     e6c:	cf 93       	push	r28
     e6e:	cd b7       	in	r28, 0x3d	; 61
     e70:	de b7       	in	r29, 0x3e	; 62
     e72:	2f 97       	sbiw	r28, 0x0f	; 15
     e74:	0f b6       	in	r0, 0x3f	; 63
     e76:	f8 94       	cli
     e78:	de bf       	out	0x3e, r29	; 62
     e7a:	0f be       	out	0x3f, r0	; 63
     e7c:	cd bf       	out	0x3d, r28	; 61
     e7e:	8f 87       	std	Y+15, r24	; 0x0f

	/*Setting RS pin to HIGH*/
	DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_RS_PIN,DIO_HIGH);
     e80:	83 e0       	ldi	r24, 0x03	; 3
     e82:	60 e0       	ldi	r22, 0x00	; 0
     e84:	41 e0       	ldi	r20, 0x01	; 1
     e86:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
	/*Setting RW pin low for write*/
	DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_RW_PIN,DIO_LOW);
     e8a:	83 e0       	ldi	r24, 0x03	; 3
     e8c:	61 e0       	ldi	r22, 0x01	; 1
     e8e:	40 e0       	ldi	r20, 0x00	; 0
     e90:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>

	/*Set data pins*/
	DIO_u8SetPortValue(CLCD_DATA_PORT,copy_u8Data);
     e94:	82 e0       	ldi	r24, 0x02	; 2
     e96:	6f 85       	ldd	r22, Y+15	; 0x0f
     e98:	0e 94 ce 08 	call	0x119c	; 0x119c <DIO_u8SetPortValue>

	/*Send Enable pulse*/
	DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_HIGH);
     e9c:	83 e0       	ldi	r24, 0x03	; 3
     e9e:	62 e0       	ldi	r22, 0x02	; 2
     ea0:	41 e0       	ldi	r20, 0x01	; 1
     ea2:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
     ea6:	80 e0       	ldi	r24, 0x00	; 0
     ea8:	90 e0       	ldi	r25, 0x00	; 0
     eaa:	a0 e0       	ldi	r26, 0x00	; 0
     eac:	b0 e4       	ldi	r27, 0x40	; 64
     eae:	8b 87       	std	Y+11, r24	; 0x0b
     eb0:	9c 87       	std	Y+12, r25	; 0x0c
     eb2:	ad 87       	std	Y+13, r26	; 0x0d
     eb4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
     eb6:	6b 85       	ldd	r22, Y+11	; 0x0b
     eb8:	7c 85       	ldd	r23, Y+12	; 0x0c
     eba:	8d 85       	ldd	r24, Y+13	; 0x0d
     ebc:	9e 85       	ldd	r25, Y+14	; 0x0e
     ebe:	20 e0       	ldi	r18, 0x00	; 0
     ec0:	30 e0       	ldi	r19, 0x00	; 0
     ec2:	4a e7       	ldi	r20, 0x7A	; 122
     ec4:	53 e4       	ldi	r21, 0x43	; 67
     ec6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     eca:	dc 01       	movw	r26, r24
     ecc:	cb 01       	movw	r24, r22
     ece:	8f 83       	std	Y+7, r24	; 0x07
     ed0:	98 87       	std	Y+8, r25	; 0x08
     ed2:	a9 87       	std	Y+9, r26	; 0x09
     ed4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
     ed6:	6f 81       	ldd	r22, Y+7	; 0x07
     ed8:	78 85       	ldd	r23, Y+8	; 0x08
     eda:	89 85       	ldd	r24, Y+9	; 0x09
     edc:	9a 85       	ldd	r25, Y+10	; 0x0a
     ede:	20 e0       	ldi	r18, 0x00	; 0
     ee0:	30 e0       	ldi	r19, 0x00	; 0
     ee2:	40 e8       	ldi	r20, 0x80	; 128
     ee4:	5f e3       	ldi	r21, 0x3F	; 63
     ee6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
     eea:	88 23       	and	r24, r24
     eec:	2c f4       	brge	.+10     	; 0xef8 <CLCD_voidSendData+0x8e>
		__ticks = 1;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	90 e0       	ldi	r25, 0x00	; 0
     ef2:	9e 83       	std	Y+6, r25	; 0x06
     ef4:	8d 83       	std	Y+5, r24	; 0x05
     ef6:	3f c0       	rjmp	.+126    	; 0xf76 <CLCD_voidSendData+0x10c>
	else if (__tmp > 65535)
     ef8:	6f 81       	ldd	r22, Y+7	; 0x07
     efa:	78 85       	ldd	r23, Y+8	; 0x08
     efc:	89 85       	ldd	r24, Y+9	; 0x09
     efe:	9a 85       	ldd	r25, Y+10	; 0x0a
     f00:	20 e0       	ldi	r18, 0x00	; 0
     f02:	3f ef       	ldi	r19, 0xFF	; 255
     f04:	4f e7       	ldi	r20, 0x7F	; 127
     f06:	57 e4       	ldi	r21, 0x47	; 71
     f08:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
     f0c:	18 16       	cp	r1, r24
     f0e:	4c f5       	brge	.+82     	; 0xf62 <CLCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
     f10:	6b 85       	ldd	r22, Y+11	; 0x0b
     f12:	7c 85       	ldd	r23, Y+12	; 0x0c
     f14:	8d 85       	ldd	r24, Y+13	; 0x0d
     f16:	9e 85       	ldd	r25, Y+14	; 0x0e
     f18:	20 e0       	ldi	r18, 0x00	; 0
     f1a:	30 e0       	ldi	r19, 0x00	; 0
     f1c:	40 e2       	ldi	r20, 0x20	; 32
     f1e:	51 e4       	ldi	r21, 0x41	; 65
     f20:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
     f24:	dc 01       	movw	r26, r24
     f26:	cb 01       	movw	r24, r22
     f28:	bc 01       	movw	r22, r24
     f2a:	cd 01       	movw	r24, r26
     f2c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f30:	dc 01       	movw	r26, r24
     f32:	cb 01       	movw	r24, r22
     f34:	9e 83       	std	Y+6, r25	; 0x06
     f36:	8d 83       	std	Y+5, r24	; 0x05
     f38:	0f c0       	rjmp	.+30     	; 0xf58 <CLCD_voidSendData+0xee>
     f3a:	89 e1       	ldi	r24, 0x19	; 25
     f3c:	90 e0       	ldi	r25, 0x00	; 0
     f3e:	9c 83       	std	Y+4, r25	; 0x04
     f40:	8b 83       	std	Y+3, r24	; 0x03
     f42:	8b 81       	ldd	r24, Y+3	; 0x03
     f44:	9c 81       	ldd	r25, Y+4	; 0x04
     f46:	01 97       	sbiw	r24, 0x01	; 1
     f48:	f1 f7       	brne	.-4      	; 0xf46 <CLCD_voidSendData+0xdc>
     f4a:	9c 83       	std	Y+4, r25	; 0x04
     f4c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     f4e:	8d 81       	ldd	r24, Y+5	; 0x05
     f50:	9e 81       	ldd	r25, Y+6	; 0x06
     f52:	01 97       	sbiw	r24, 0x01	; 1
     f54:	9e 83       	std	Y+6, r25	; 0x06
     f56:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     f58:	8d 81       	ldd	r24, Y+5	; 0x05
     f5a:	9e 81       	ldd	r25, Y+6	; 0x06
     f5c:	00 97       	sbiw	r24, 0x00	; 0
     f5e:	69 f7       	brne	.-38     	; 0xf3a <CLCD_voidSendData+0xd0>
     f60:	14 c0       	rjmp	.+40     	; 0xf8a <CLCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
     f62:	6f 81       	ldd	r22, Y+7	; 0x07
     f64:	78 85       	ldd	r23, Y+8	; 0x08
     f66:	89 85       	ldd	r24, Y+9	; 0x09
     f68:	9a 85       	ldd	r25, Y+10	; 0x0a
     f6a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
     f6e:	dc 01       	movw	r26, r24
     f70:	cb 01       	movw	r24, r22
     f72:	9e 83       	std	Y+6, r25	; 0x06
     f74:	8d 83       	std	Y+5, r24	; 0x05
     f76:	8d 81       	ldd	r24, Y+5	; 0x05
     f78:	9e 81       	ldd	r25, Y+6	; 0x06
     f7a:	9a 83       	std	Y+2, r25	; 0x02
     f7c:	89 83       	std	Y+1, r24	; 0x01
     f7e:	89 81       	ldd	r24, Y+1	; 0x01
     f80:	9a 81       	ldd	r25, Y+2	; 0x02
     f82:	01 97       	sbiw	r24, 0x01	; 1
     f84:	f1 f7       	brne	.-4      	; 0xf82 <CLCD_voidSendData+0x118>
     f86:	9a 83       	std	Y+2, r25	; 0x02
     f88:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(CLCD_CONTROL_PORT,CLCD_E_PIN,DIO_LOW);
     f8a:	83 e0       	ldi	r24, 0x03	; 3
     f8c:	62 e0       	ldi	r22, 0x02	; 2
     f8e:	40 e0       	ldi	r20, 0x00	; 0
     f90:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>


}
     f94:	2f 96       	adiw	r28, 0x0f	; 15
     f96:	0f b6       	in	r0, 0x3f	; 63
     f98:	f8 94       	cli
     f9a:	de bf       	out	0x3e, r29	; 62
     f9c:	0f be       	out	0x3f, r0	; 63
     f9e:	cd bf       	out	0x3d, r28	; 61
     fa0:	cf 91       	pop	r28
     fa2:	df 91       	pop	r29
     fa4:	08 95       	ret

00000fa6 <CLCD_voidSendString>:

void CLCD_voidSendString(const u8* Copy_u8String)
{
     fa6:	df 93       	push	r29
     fa8:	cf 93       	push	r28
     faa:	00 d0       	rcall	.+0      	; 0xfac <CLCD_voidSendString+0x6>
     fac:	0f 92       	push	r0
     fae:	cd b7       	in	r28, 0x3d	; 61
     fb0:	de b7       	in	r29, 0x3e	; 62
     fb2:	9b 83       	std	Y+3, r25	; 0x03
     fb4:	8a 83       	std	Y+2, r24	; 0x02
u8 Local_u8Counter=0;
     fb6:	19 82       	std	Y+1, r1	; 0x01
     fb8:	0e c0       	rjmp	.+28     	; 0xfd6 <CLCD_voidSendString+0x30>
while(Copy_u8String[Local_u8Counter]!='\0')
{
    CLCD_voidSendData(Copy_u8String[Local_u8Counter]);
     fba:	89 81       	ldd	r24, Y+1	; 0x01
     fbc:	28 2f       	mov	r18, r24
     fbe:	30 e0       	ldi	r19, 0x00	; 0
     fc0:	8a 81       	ldd	r24, Y+2	; 0x02
     fc2:	9b 81       	ldd	r25, Y+3	; 0x03
     fc4:	fc 01       	movw	r30, r24
     fc6:	e2 0f       	add	r30, r18
     fc8:	f3 1f       	adc	r31, r19
     fca:	80 81       	ld	r24, Z
     fcc:	0e 94 35 07 	call	0xe6a	; 0xe6a <CLCD_voidSendData>
    Local_u8Counter++;
     fd0:	89 81       	ldd	r24, Y+1	; 0x01
     fd2:	8f 5f       	subi	r24, 0xFF	; 255
     fd4:	89 83       	std	Y+1, r24	; 0x01
}

void CLCD_voidSendString(const u8* Copy_u8String)
{
u8 Local_u8Counter=0;
while(Copy_u8String[Local_u8Counter]!='\0')
     fd6:	89 81       	ldd	r24, Y+1	; 0x01
     fd8:	28 2f       	mov	r18, r24
     fda:	30 e0       	ldi	r19, 0x00	; 0
     fdc:	8a 81       	ldd	r24, Y+2	; 0x02
     fde:	9b 81       	ldd	r25, Y+3	; 0x03
     fe0:	fc 01       	movw	r30, r24
     fe2:	e2 0f       	add	r30, r18
     fe4:	f3 1f       	adc	r31, r19
     fe6:	80 81       	ld	r24, Z
     fe8:	88 23       	and	r24, r24
     fea:	39 f7       	brne	.-50     	; 0xfba <CLCD_voidSendString+0x14>
{
    CLCD_voidSendData(Copy_u8String[Local_u8Counter]);
    Local_u8Counter++;
}

}
     fec:	0f 90       	pop	r0
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	cf 91       	pop	r28
     ff4:	df 91       	pop	r29
     ff6:	08 95       	ret

00000ff8 <CLCD_voidGoToXY>:


void CLCD_voidGoToXY(u8 Copy_u8Xposition,u8 Copy_u8Yposition)
{
     ff8:	df 93       	push	r29
     ffa:	cf 93       	push	r28
     ffc:	00 d0       	rcall	.+0      	; 0xffe <CLCD_voidGoToXY+0x6>
     ffe:	0f 92       	push	r0
    1000:	cd b7       	in	r28, 0x3d	; 61
    1002:	de b7       	in	r29, 0x3e	; 62
    1004:	8a 83       	std	Y+2, r24	; 0x02
    1006:	6b 83       	std	Y+3, r22	; 0x03
  u8 Local_u8Address;

  if(Copy_u8Xposition==0)
    1008:	8a 81       	ldd	r24, Y+2	; 0x02
    100a:	88 23       	and	r24, r24
    100c:	19 f4       	brne	.+6      	; 0x1014 <CLCD_voidGoToXY+0x1c>
  {
	  Local_u8Address=Copy_u8Yposition;
    100e:	8b 81       	ldd	r24, Y+3	; 0x03
    1010:	89 83       	std	Y+1, r24	; 0x01
    1012:	06 c0       	rjmp	.+12     	; 0x1020 <CLCD_voidGoToXY+0x28>
  }
  else if(Copy_u8Xposition==1)
    1014:	8a 81       	ldd	r24, Y+2	; 0x02
    1016:	81 30       	cpi	r24, 0x01	; 1
    1018:	19 f4       	brne	.+6      	; 0x1020 <CLCD_voidGoToXY+0x28>

  {
	  Local_u8Address=Copy_u8Yposition+0x40;
    101a:	8b 81       	ldd	r24, Y+3	; 0x03
    101c:	80 5c       	subi	r24, 0xC0	; 192
    101e:	89 83       	std	Y+1, r24	; 0x01
  }

  CLCD_voidSendCommand(Local_u8Address|(1<<7));
    1020:	89 81       	ldd	r24, Y+1	; 0x01
    1022:	80 68       	ori	r24, 0x80	; 128
    1024:	0e 94 09 06 	call	0xc12	; 0xc12 <CLCD_voidSendCommand>
}
    1028:	0f 90       	pop	r0
    102a:	0f 90       	pop	r0
    102c:	0f 90       	pop	r0
    102e:	cf 91       	pop	r28
    1030:	df 91       	pop	r29
    1032:	08 95       	ret

00001034 <CLCD_voidWriteNumber>:


void CLCD_voidWriteNumber(u32 copy_u32Number)
{
    1034:	df 93       	push	r29
    1036:	cf 93       	push	r28
    1038:	cd b7       	in	r28, 0x3d	; 61
    103a:	de b7       	in	r29, 0x3e	; 62
    103c:	27 97       	sbiw	r28, 0x07	; 7
    103e:	0f b6       	in	r0, 0x3f	; 63
    1040:	f8 94       	cli
    1042:	de bf       	out	0x3e, r29	; 62
    1044:	0f be       	out	0x3f, r0	; 63
    1046:	cd bf       	out	0x3d, r28	; 61
    1048:	6c 83       	std	Y+4, r22	; 0x04
    104a:	7d 83       	std	Y+5, r23	; 0x05
    104c:	8e 83       	std	Y+6, r24	; 0x06
    104e:	9f 83       	std	Y+7, r25	; 0x07
	u8 Local_u8Digit;
	u8 Local_u8Counter=0;
    1050:	1a 82       	std	Y+2, r1	; 0x02
	s8 Local_u8Counter2;
	static u8 Local_ArrayOfChar[10]={'0','1','2','3','4','5','6','7','8','9'};
	static u8 Local_ArrayOfDigits[10];

	if(copy_u32Number==0)
    1052:	8c 81       	ldd	r24, Y+4	; 0x04
    1054:	9d 81       	ldd	r25, Y+5	; 0x05
    1056:	ae 81       	ldd	r26, Y+6	; 0x06
    1058:	bf 81       	ldd	r27, Y+7	; 0x07
    105a:	00 97       	sbiw	r24, 0x00	; 0
    105c:	a1 05       	cpc	r26, r1
    105e:	b1 05       	cpc	r27, r1
    1060:	b9 f5       	brne	.+110    	; 0x10d0 <CLCD_voidWriteNumber+0x9c>
	{
		CLCD_voidSendData(Local_ArrayOfChar[0]);
    1062:	80 91 fc 00 	lds	r24, 0x00FC
    1066:	0e 94 35 07 	call	0xe6a	; 0xe6a <CLCD_voidSendData>
    106a:	4e c0       	rjmp	.+156    	; 0x1108 <CLCD_voidWriteNumber+0xd4>
	else
	{

		while(copy_u32Number>0)
		{
			Local_u8Digit=copy_u32Number%10;
    106c:	8c 81       	ldd	r24, Y+4	; 0x04
    106e:	9d 81       	ldd	r25, Y+5	; 0x05
    1070:	ae 81       	ldd	r26, Y+6	; 0x06
    1072:	bf 81       	ldd	r27, Y+7	; 0x07
    1074:	2a e0       	ldi	r18, 0x0A	; 10
    1076:	30 e0       	ldi	r19, 0x00	; 0
    1078:	40 e0       	ldi	r20, 0x00	; 0
    107a:	50 e0       	ldi	r21, 0x00	; 0
    107c:	bc 01       	movw	r22, r24
    107e:	cd 01       	movw	r24, r26
    1080:	0e 94 ac 29 	call	0x5358	; 0x5358 <__udivmodsi4>
    1084:	dc 01       	movw	r26, r24
    1086:	cb 01       	movw	r24, r22
    1088:	8b 83       	std	Y+3, r24	; 0x03
			copy_u32Number=copy_u32Number/10;
    108a:	8c 81       	ldd	r24, Y+4	; 0x04
    108c:	9d 81       	ldd	r25, Y+5	; 0x05
    108e:	ae 81       	ldd	r26, Y+6	; 0x06
    1090:	bf 81       	ldd	r27, Y+7	; 0x07
    1092:	2a e0       	ldi	r18, 0x0A	; 10
    1094:	30 e0       	ldi	r19, 0x00	; 0
    1096:	40 e0       	ldi	r20, 0x00	; 0
    1098:	50 e0       	ldi	r21, 0x00	; 0
    109a:	bc 01       	movw	r22, r24
    109c:	cd 01       	movw	r24, r26
    109e:	0e 94 ac 29 	call	0x5358	; 0x5358 <__udivmodsi4>
    10a2:	da 01       	movw	r26, r20
    10a4:	c9 01       	movw	r24, r18
    10a6:	8c 83       	std	Y+4, r24	; 0x04
    10a8:	9d 83       	std	Y+5, r25	; 0x05
    10aa:	ae 83       	std	Y+6, r26	; 0x06
    10ac:	bf 83       	std	Y+7, r27	; 0x07
			Local_ArrayOfDigits[Local_u8Counter]=Local_ArrayOfChar[Local_u8Digit];
    10ae:	8a 81       	ldd	r24, Y+2	; 0x02
    10b0:	28 2f       	mov	r18, r24
    10b2:	30 e0       	ldi	r19, 0x00	; 0
    10b4:	8b 81       	ldd	r24, Y+3	; 0x03
    10b6:	88 2f       	mov	r24, r24
    10b8:	90 e0       	ldi	r25, 0x00	; 0
    10ba:	fc 01       	movw	r30, r24
    10bc:	e4 50       	subi	r30, 0x04	; 4
    10be:	ff 4f       	sbci	r31, 0xFF	; 255
    10c0:	80 81       	ld	r24, Z
    10c2:	f9 01       	movw	r30, r18
    10c4:	e6 5d       	subi	r30, 0xD6	; 214
    10c6:	fe 4f       	sbci	r31, 0xFE	; 254
    10c8:	80 83       	st	Z, r24
			Local_u8Counter++;
    10ca:	8a 81       	ldd	r24, Y+2	; 0x02
    10cc:	8f 5f       	subi	r24, 0xFF	; 255
    10ce:	8a 83       	std	Y+2, r24	; 0x02
		CLCD_voidSendData(Local_ArrayOfChar[0]);
	}
	else
	{

		while(copy_u32Number>0)
    10d0:	8c 81       	ldd	r24, Y+4	; 0x04
    10d2:	9d 81       	ldd	r25, Y+5	; 0x05
    10d4:	ae 81       	ldd	r26, Y+6	; 0x06
    10d6:	bf 81       	ldd	r27, Y+7	; 0x07
    10d8:	00 97       	sbiw	r24, 0x00	; 0
    10da:	a1 05       	cpc	r26, r1
    10dc:	b1 05       	cpc	r27, r1
    10de:	31 f6       	brne	.-116    	; 0x106c <CLCD_voidWriteNumber+0x38>
			copy_u32Number=copy_u32Number/10;
			Local_ArrayOfDigits[Local_u8Counter]=Local_ArrayOfChar[Local_u8Digit];
			Local_u8Counter++;
		}

		for(Local_u8Counter2=Local_u8Counter-1;Local_u8Counter2>=0;Local_u8Counter2--)
    10e0:	8a 81       	ldd	r24, Y+2	; 0x02
    10e2:	81 50       	subi	r24, 0x01	; 1
    10e4:	89 83       	std	Y+1, r24	; 0x01
    10e6:	0d c0       	rjmp	.+26     	; 0x1102 <CLCD_voidWriteNumber+0xce>
		{
			CLCD_voidSendData(Local_ArrayOfDigits[Local_u8Counter2]);
    10e8:	89 81       	ldd	r24, Y+1	; 0x01
    10ea:	99 27       	eor	r25, r25
    10ec:	87 fd       	sbrc	r24, 7
    10ee:	90 95       	com	r25
    10f0:	fc 01       	movw	r30, r24
    10f2:	e6 5d       	subi	r30, 0xD6	; 214
    10f4:	fe 4f       	sbci	r31, 0xFE	; 254
    10f6:	80 81       	ld	r24, Z
    10f8:	0e 94 35 07 	call	0xe6a	; 0xe6a <CLCD_voidSendData>
			copy_u32Number=copy_u32Number/10;
			Local_ArrayOfDigits[Local_u8Counter]=Local_ArrayOfChar[Local_u8Digit];
			Local_u8Counter++;
		}

		for(Local_u8Counter2=Local_u8Counter-1;Local_u8Counter2>=0;Local_u8Counter2--)
    10fc:	89 81       	ldd	r24, Y+1	; 0x01
    10fe:	81 50       	subi	r24, 0x01	; 1
    1100:	89 83       	std	Y+1, r24	; 0x01
    1102:	89 81       	ldd	r24, Y+1	; 0x01
    1104:	88 23       	and	r24, r24
    1106:	84 f7       	brge	.-32     	; 0x10e8 <CLCD_voidWriteNumber+0xb4>
		{
			CLCD_voidSendData(Local_ArrayOfDigits[Local_u8Counter2]);
		}
	}
}
    1108:	27 96       	adiw	r28, 0x07	; 7
    110a:	0f b6       	in	r0, 0x3f	; 63
    110c:	f8 94       	cli
    110e:	de bf       	out	0x3e, r29	; 62
    1110:	0f be       	out	0x3f, r0	; 63
    1112:	cd bf       	out	0x3d, r28	; 61
    1114:	cf 91       	pop	r28
    1116:	df 91       	pop	r29
    1118:	08 95       	ret

0000111a <CLCD_voidWriteSpecialChar>:
void CLCD_voidWriteSpecialChar(u8* copy_pu8Pattern,u8 copy_u8PatternNumber,u8 copy_u8Xposition,u8 copy_u8Yposition)
{
    111a:	df 93       	push	r29
    111c:	cf 93       	push	r28
    111e:	cd b7       	in	r28, 0x3d	; 61
    1120:	de b7       	in	r29, 0x3e	; 62
    1122:	27 97       	sbiw	r28, 0x07	; 7
    1124:	0f b6       	in	r0, 0x3f	; 63
    1126:	f8 94       	cli
    1128:	de bf       	out	0x3e, r29	; 62
    112a:	0f be       	out	0x3f, r0	; 63
    112c:	cd bf       	out	0x3d, r28	; 61
    112e:	9c 83       	std	Y+4, r25	; 0x04
    1130:	8b 83       	std	Y+3, r24	; 0x03
    1132:	6d 83       	std	Y+5, r22	; 0x05
    1134:	4e 83       	std	Y+6, r20	; 0x06
    1136:	2f 83       	std	Y+7, r18	; 0x07
	u8 Local_u8CGRAM_Address=0;
    1138:	1a 82       	std	Y+2, r1	; 0x02
	/*Set the CGRAM address*/
Local_u8CGRAM_Address=copy_u8PatternNumber*8;
    113a:	8d 81       	ldd	r24, Y+5	; 0x05
    113c:	88 2f       	mov	r24, r24
    113e:	90 e0       	ldi	r25, 0x00	; 0
    1140:	88 0f       	add	r24, r24
    1142:	99 1f       	adc	r25, r25
    1144:	88 0f       	add	r24, r24
    1146:	99 1f       	adc	r25, r25
    1148:	88 0f       	add	r24, r24
    114a:	99 1f       	adc	r25, r25
    114c:	8a 83       	std	Y+2, r24	; 0x02
CLCD_voidSendCommand(Local_u8CGRAM_Address|(1<<6));
    114e:	8a 81       	ldd	r24, Y+2	; 0x02
    1150:	80 64       	ori	r24, 0x40	; 64
    1152:	0e 94 09 06 	call	0xc12	; 0xc12 <CLCD_voidSendCommand>

for(u8 i=0;i<8;i++)
    1156:	19 82       	std	Y+1, r1	; 0x01
    1158:	0e c0       	rjmp	.+28     	; 0x1176 <CLCD_voidWriteSpecialChar+0x5c>
{
	CLCD_voidSendData(copy_pu8Pattern[i]);
    115a:	89 81       	ldd	r24, Y+1	; 0x01
    115c:	28 2f       	mov	r18, r24
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	8b 81       	ldd	r24, Y+3	; 0x03
    1162:	9c 81       	ldd	r25, Y+4	; 0x04
    1164:	fc 01       	movw	r30, r24
    1166:	e2 0f       	add	r30, r18
    1168:	f3 1f       	adc	r31, r19
    116a:	80 81       	ld	r24, Z
    116c:	0e 94 35 07 	call	0xe6a	; 0xe6a <CLCD_voidSendData>
	u8 Local_u8CGRAM_Address=0;
	/*Set the CGRAM address*/
Local_u8CGRAM_Address=copy_u8PatternNumber*8;
CLCD_voidSendCommand(Local_u8CGRAM_Address|(1<<6));

for(u8 i=0;i<8;i++)
    1170:	89 81       	ldd	r24, Y+1	; 0x01
    1172:	8f 5f       	subi	r24, 0xFF	; 255
    1174:	89 83       	std	Y+1, r24	; 0x01
    1176:	89 81       	ldd	r24, Y+1	; 0x01
    1178:	88 30       	cpi	r24, 0x08	; 8
    117a:	78 f3       	brcs	.-34     	; 0x115a <CLCD_voidWriteSpecialChar+0x40>
{
	CLCD_voidSendData(copy_pu8Pattern[i]);
}
/*go back to DDRAM to display the Arr*/
 CLCD_voidGoToXY(copy_u8Xposition,copy_u8Yposition);
    117c:	8e 81       	ldd	r24, Y+6	; 0x06
    117e:	6f 81       	ldd	r22, Y+7	; 0x07
    1180:	0e 94 fc 07 	call	0xff8	; 0xff8 <CLCD_voidGoToXY>

CLCD_voidSendData(copy_u8PatternNumber);
    1184:	8d 81       	ldd	r24, Y+5	; 0x05
    1186:	0e 94 35 07 	call	0xe6a	; 0xe6a <CLCD_voidSendData>

}
    118a:	27 96       	adiw	r28, 0x07	; 7
    118c:	0f b6       	in	r0, 0x3f	; 63
    118e:	f8 94       	cli
    1190:	de bf       	out	0x3e, r29	; 62
    1192:	0f be       	out	0x3f, r0	; 63
    1194:	cd bf       	out	0x3d, r28	; 61
    1196:	cf 91       	pop	r28
    1198:	df 91       	pop	r29
    119a:	08 95       	ret

0000119c <DIO_u8SetPortValue>:
#include"BIT_MATH.h"
#include "DIO_INTERFACE.h"
#include <avr/io.h>

u8 DIO_u8SetPortValue(u8 Copy_u8Port,u8 Copy_u8Value)
{
    119c:	df 93       	push	r29
    119e:	cf 93       	push	r28
    11a0:	00 d0       	rcall	.+0      	; 0x11a2 <DIO_u8SetPortValue+0x6>
    11a2:	00 d0       	rcall	.+0      	; 0x11a4 <DIO_u8SetPortValue+0x8>
    11a4:	00 d0       	rcall	.+0      	; 0x11a6 <DIO_u8SetPortValue+0xa>
    11a6:	cd b7       	in	r28, 0x3d	; 61
    11a8:	de b7       	in	r29, 0x3e	; 62
    11aa:	8a 83       	std	Y+2, r24	; 0x02
    11ac:	6b 83       	std	Y+3, r22	; 0x03

   u8 Local_u8ErrorState=0;
    11ae:	19 82       	std	Y+1, r1	; 0x01
   if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    11b0:	8a 81       	ldd	r24, Y+2	; 0x02
    11b2:	84 30       	cpi	r24, 0x04	; 4
    11b4:	28 f0       	brcs	.+10     	; 0x11c0 <DIO_u8SetPortValue+0x24>
   {
	   Local_u8ErrorState=1;
    11b6:	81 e0       	ldi	r24, 0x01	; 1
    11b8:	89 83       	std	Y+1, r24	; 0x01
	  return Local_u8ErrorState;
    11ba:	29 81       	ldd	r18, Y+1	; 0x01
    11bc:	2e 83       	std	Y+6, r18	; 0x06
    11be:	34 c0       	rjmp	.+104    	; 0x1228 <DIO_u8SetPortValue+0x8c>
   }
   else
   {
	   switch(Copy_u8Port)
    11c0:	8a 81       	ldd	r24, Y+2	; 0x02
    11c2:	28 2f       	mov	r18, r24
    11c4:	30 e0       	ldi	r19, 0x00	; 0
    11c6:	3d 83       	std	Y+5, r19	; 0x05
    11c8:	2c 83       	std	Y+4, r18	; 0x04
    11ca:	8c 81       	ldd	r24, Y+4	; 0x04
    11cc:	9d 81       	ldd	r25, Y+5	; 0x05
    11ce:	81 30       	cpi	r24, 0x01	; 1
    11d0:	91 05       	cpc	r25, r1
    11d2:	d1 f0       	breq	.+52     	; 0x1208 <DIO_u8SetPortValue+0x6c>
    11d4:	2c 81       	ldd	r18, Y+4	; 0x04
    11d6:	3d 81       	ldd	r19, Y+5	; 0x05
    11d8:	22 30       	cpi	r18, 0x02	; 2
    11da:	31 05       	cpc	r19, r1
    11dc:	2c f4       	brge	.+10     	; 0x11e8 <DIO_u8SetPortValue+0x4c>
    11de:	8c 81       	ldd	r24, Y+4	; 0x04
    11e0:	9d 81       	ldd	r25, Y+5	; 0x05
    11e2:	00 97       	sbiw	r24, 0x00	; 0
    11e4:	61 f0       	breq	.+24     	; 0x11fe <DIO_u8SetPortValue+0x62>
    11e6:	1e c0       	rjmp	.+60     	; 0x1224 <DIO_u8SetPortValue+0x88>
    11e8:	2c 81       	ldd	r18, Y+4	; 0x04
    11ea:	3d 81       	ldd	r19, Y+5	; 0x05
    11ec:	22 30       	cpi	r18, 0x02	; 2
    11ee:	31 05       	cpc	r19, r1
    11f0:	81 f0       	breq	.+32     	; 0x1212 <DIO_u8SetPortValue+0x76>
    11f2:	8c 81       	ldd	r24, Y+4	; 0x04
    11f4:	9d 81       	ldd	r25, Y+5	; 0x05
    11f6:	83 30       	cpi	r24, 0x03	; 3
    11f8:	91 05       	cpc	r25, r1
    11fa:	81 f0       	breq	.+32     	; 0x121c <DIO_u8SetPortValue+0x80>
    11fc:	13 c0       	rjmp	.+38     	; 0x1224 <DIO_u8SetPortValue+0x88>
	   {
	   case DIO_PORTA:PORTA=Copy_u8Value;break;
    11fe:	eb e3       	ldi	r30, 0x3B	; 59
    1200:	f0 e0       	ldi	r31, 0x00	; 0
    1202:	8b 81       	ldd	r24, Y+3	; 0x03
    1204:	80 83       	st	Z, r24
    1206:	0e c0       	rjmp	.+28     	; 0x1224 <DIO_u8SetPortValue+0x88>
	   case DIO_PORTB:PORTB=Copy_u8Value;break;
    1208:	e8 e3       	ldi	r30, 0x38	; 56
    120a:	f0 e0       	ldi	r31, 0x00	; 0
    120c:	8b 81       	ldd	r24, Y+3	; 0x03
    120e:	80 83       	st	Z, r24
    1210:	09 c0       	rjmp	.+18     	; 0x1224 <DIO_u8SetPortValue+0x88>
	   case DIO_PORTC:PORTC=Copy_u8Value;break;
    1212:	e5 e3       	ldi	r30, 0x35	; 53
    1214:	f0 e0       	ldi	r31, 0x00	; 0
    1216:	8b 81       	ldd	r24, Y+3	; 0x03
    1218:	80 83       	st	Z, r24
    121a:	04 c0       	rjmp	.+8      	; 0x1224 <DIO_u8SetPortValue+0x88>
	   case DIO_PORTD:PORTD=Copy_u8Value;break;
    121c:	e2 e3       	ldi	r30, 0x32	; 50
    121e:	f0 e0       	ldi	r31, 0x00	; 0
    1220:	8b 81       	ldd	r24, Y+3	; 0x03
    1222:	80 83       	st	Z, r24
	   default:;
        }
   }
return Local_u8ErrorState;
    1224:	99 81       	ldd	r25, Y+1	; 0x01
    1226:	9e 83       	std	Y+6, r25	; 0x06
    1228:	8e 81       	ldd	r24, Y+6	; 0x06
}
    122a:	26 96       	adiw	r28, 0x06	; 6
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	de bf       	out	0x3e, r29	; 62
    1232:	0f be       	out	0x3f, r0	; 63
    1234:	cd bf       	out	0x3d, r28	; 61
    1236:	cf 91       	pop	r28
    1238:	df 91       	pop	r29
    123a:	08 95       	ret

0000123c <DIO_u8SetPinValue>:
u8 DIO_u8SetPinValue(u8 Copy_u8Port,u8 Copy_u8Pin,u8 Copy_u8Value){
    123c:	df 93       	push	r29
    123e:	cf 93       	push	r28
    1240:	cd b7       	in	r28, 0x3d	; 61
    1242:	de b7       	in	r29, 0x3e	; 62
    1244:	29 97       	sbiw	r28, 0x09	; 9
    1246:	0f b6       	in	r0, 0x3f	; 63
    1248:	f8 94       	cli
    124a:	de bf       	out	0x3e, r29	; 62
    124c:	0f be       	out	0x3f, r0	; 63
    124e:	cd bf       	out	0x3d, r28	; 61
    1250:	8a 83       	std	Y+2, r24	; 0x02
    1252:	6b 83       	std	Y+3, r22	; 0x03
    1254:	4c 83       	std	Y+4, r20	; 0x04

 u8 Local_u8ErrorState=0;
    1256:	19 82       	std	Y+1, r1	; 0x01

 if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    1258:	8a 81       	ldd	r24, Y+2	; 0x02
    125a:	84 30       	cpi	r24, 0x04	; 4
    125c:	28 f0       	brcs	.+10     	; 0x1268 <DIO_u8SetPinValue+0x2c>
    {
 	   Local_u8ErrorState=1;
    125e:	81 e0       	ldi	r24, 0x01	; 1
    1260:	89 83       	std	Y+1, r24	; 0x01
 	  return Local_u8ErrorState;
    1262:	29 81       	ldd	r18, Y+1	; 0x01
    1264:	29 87       	std	Y+9, r18	; 0x09
    1266:	f4 c0       	rjmp	.+488    	; 0x1450 <DIO_u8SetPinValue+0x214>
    }
 else if ((Copy_u8Pin>DIO_PIN7)||(Copy_u8Pin<DIO_PIN0))
    1268:	8b 81       	ldd	r24, Y+3	; 0x03
    126a:	88 30       	cpi	r24, 0x08	; 8
    126c:	28 f0       	brcs	.+10     	; 0x1278 <DIO_u8SetPinValue+0x3c>
 {
	   Local_u8ErrorState=1;
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	89 83       	std	Y+1, r24	; 0x01
       return Local_u8ErrorState;
    1272:	39 81       	ldd	r19, Y+1	; 0x01
    1274:	39 87       	std	Y+9, r19	; 0x09
    1276:	ec c0       	rjmp	.+472    	; 0x1450 <DIO_u8SetPinValue+0x214>
 }
 else
 {
	 if(Copy_u8Value==DIO_HIGH)
    1278:	8c 81       	ldd	r24, Y+4	; 0x04
    127a:	81 30       	cpi	r24, 0x01	; 1
    127c:	09 f0       	breq	.+2      	; 0x1280 <DIO_u8SetPinValue+0x44>
    127e:	6f c0       	rjmp	.+222    	; 0x135e <DIO_u8SetPinValue+0x122>
	 {

		 switch(Copy_u8Port)
    1280:	8a 81       	ldd	r24, Y+2	; 0x02
    1282:	28 2f       	mov	r18, r24
    1284:	30 e0       	ldi	r19, 0x00	; 0
    1286:	38 87       	std	Y+8, r19	; 0x08
    1288:	2f 83       	std	Y+7, r18	; 0x07
    128a:	8f 81       	ldd	r24, Y+7	; 0x07
    128c:	98 85       	ldd	r25, Y+8	; 0x08
    128e:	81 30       	cpi	r24, 0x01	; 1
    1290:	91 05       	cpc	r25, r1
    1292:	49 f1       	breq	.+82     	; 0x12e6 <DIO_u8SetPinValue+0xaa>
    1294:	2f 81       	ldd	r18, Y+7	; 0x07
    1296:	38 85       	ldd	r19, Y+8	; 0x08
    1298:	22 30       	cpi	r18, 0x02	; 2
    129a:	31 05       	cpc	r19, r1
    129c:	2c f4       	brge	.+10     	; 0x12a8 <DIO_u8SetPinValue+0x6c>
    129e:	8f 81       	ldd	r24, Y+7	; 0x07
    12a0:	98 85       	ldd	r25, Y+8	; 0x08
    12a2:	00 97       	sbiw	r24, 0x00	; 0
    12a4:	61 f0       	breq	.+24     	; 0x12be <DIO_u8SetPinValue+0x82>
    12a6:	d2 c0       	rjmp	.+420    	; 0x144c <DIO_u8SetPinValue+0x210>
    12a8:	2f 81       	ldd	r18, Y+7	; 0x07
    12aa:	38 85       	ldd	r19, Y+8	; 0x08
    12ac:	22 30       	cpi	r18, 0x02	; 2
    12ae:	31 05       	cpc	r19, r1
    12b0:	71 f1       	breq	.+92     	; 0x130e <DIO_u8SetPinValue+0xd2>
    12b2:	8f 81       	ldd	r24, Y+7	; 0x07
    12b4:	98 85       	ldd	r25, Y+8	; 0x08
    12b6:	83 30       	cpi	r24, 0x03	; 3
    12b8:	91 05       	cpc	r25, r1
    12ba:	e9 f1       	breq	.+122    	; 0x1336 <DIO_u8SetPinValue+0xfa>
    12bc:	c7 c0       	rjmp	.+398    	; 0x144c <DIO_u8SetPinValue+0x210>
		 {
		 case DIO_PORTA:SET_BIT(PORTA,Copy_u8Pin);break;
    12be:	ab e3       	ldi	r26, 0x3B	; 59
    12c0:	b0 e0       	ldi	r27, 0x00	; 0
    12c2:	eb e3       	ldi	r30, 0x3B	; 59
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	80 81       	ld	r24, Z
    12c8:	48 2f       	mov	r20, r24
    12ca:	8b 81       	ldd	r24, Y+3	; 0x03
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	02 2e       	mov	r0, r18
    12d6:	02 c0       	rjmp	.+4      	; 0x12dc <DIO_u8SetPinValue+0xa0>
    12d8:	88 0f       	add	r24, r24
    12da:	99 1f       	adc	r25, r25
    12dc:	0a 94       	dec	r0
    12de:	e2 f7       	brpl	.-8      	; 0x12d8 <DIO_u8SetPinValue+0x9c>
    12e0:	84 2b       	or	r24, r20
    12e2:	8c 93       	st	X, r24
    12e4:	b3 c0       	rjmp	.+358    	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTB:SET_BIT(PORTB,Copy_u8Pin);break;
    12e6:	a8 e3       	ldi	r26, 0x38	; 56
    12e8:	b0 e0       	ldi	r27, 0x00	; 0
    12ea:	e8 e3       	ldi	r30, 0x38	; 56
    12ec:	f0 e0       	ldi	r31, 0x00	; 0
    12ee:	80 81       	ld	r24, Z
    12f0:	48 2f       	mov	r20, r24
    12f2:	8b 81       	ldd	r24, Y+3	; 0x03
    12f4:	28 2f       	mov	r18, r24
    12f6:	30 e0       	ldi	r19, 0x00	; 0
    12f8:	81 e0       	ldi	r24, 0x01	; 1
    12fa:	90 e0       	ldi	r25, 0x00	; 0
    12fc:	02 2e       	mov	r0, r18
    12fe:	02 c0       	rjmp	.+4      	; 0x1304 <DIO_u8SetPinValue+0xc8>
    1300:	88 0f       	add	r24, r24
    1302:	99 1f       	adc	r25, r25
    1304:	0a 94       	dec	r0
    1306:	e2 f7       	brpl	.-8      	; 0x1300 <DIO_u8SetPinValue+0xc4>
    1308:	84 2b       	or	r24, r20
    130a:	8c 93       	st	X, r24
    130c:	9f c0       	rjmp	.+318    	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTC:SET_BIT(PORTC,Copy_u8Pin);break;
    130e:	a5 e3       	ldi	r26, 0x35	; 53
    1310:	b0 e0       	ldi	r27, 0x00	; 0
    1312:	e5 e3       	ldi	r30, 0x35	; 53
    1314:	f0 e0       	ldi	r31, 0x00	; 0
    1316:	80 81       	ld	r24, Z
    1318:	48 2f       	mov	r20, r24
    131a:	8b 81       	ldd	r24, Y+3	; 0x03
    131c:	28 2f       	mov	r18, r24
    131e:	30 e0       	ldi	r19, 0x00	; 0
    1320:	81 e0       	ldi	r24, 0x01	; 1
    1322:	90 e0       	ldi	r25, 0x00	; 0
    1324:	02 2e       	mov	r0, r18
    1326:	02 c0       	rjmp	.+4      	; 0x132c <DIO_u8SetPinValue+0xf0>
    1328:	88 0f       	add	r24, r24
    132a:	99 1f       	adc	r25, r25
    132c:	0a 94       	dec	r0
    132e:	e2 f7       	brpl	.-8      	; 0x1328 <DIO_u8SetPinValue+0xec>
    1330:	84 2b       	or	r24, r20
    1332:	8c 93       	st	X, r24
    1334:	8b c0       	rjmp	.+278    	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTD:SET_BIT(PORTD,Copy_u8Pin);break;
    1336:	a2 e3       	ldi	r26, 0x32	; 50
    1338:	b0 e0       	ldi	r27, 0x00	; 0
    133a:	e2 e3       	ldi	r30, 0x32	; 50
    133c:	f0 e0       	ldi	r31, 0x00	; 0
    133e:	80 81       	ld	r24, Z
    1340:	48 2f       	mov	r20, r24
    1342:	8b 81       	ldd	r24, Y+3	; 0x03
    1344:	28 2f       	mov	r18, r24
    1346:	30 e0       	ldi	r19, 0x00	; 0
    1348:	81 e0       	ldi	r24, 0x01	; 1
    134a:	90 e0       	ldi	r25, 0x00	; 0
    134c:	02 2e       	mov	r0, r18
    134e:	02 c0       	rjmp	.+4      	; 0x1354 <DIO_u8SetPinValue+0x118>
    1350:	88 0f       	add	r24, r24
    1352:	99 1f       	adc	r25, r25
    1354:	0a 94       	dec	r0
    1356:	e2 f7       	brpl	.-8      	; 0x1350 <DIO_u8SetPinValue+0x114>
    1358:	84 2b       	or	r24, r20
    135a:	8c 93       	st	X, r24
    135c:	77 c0       	rjmp	.+238    	; 0x144c <DIO_u8SetPinValue+0x210>
         default:;
		 }
	 }
	 else if(Copy_u8Value==DIO_LOW)
    135e:	8c 81       	ldd	r24, Y+4	; 0x04
    1360:	88 23       	and	r24, r24
    1362:	09 f0       	breq	.+2      	; 0x1366 <DIO_u8SetPinValue+0x12a>
    1364:	73 c0       	rjmp	.+230    	; 0x144c <DIO_u8SetPinValue+0x210>
	 {
		 switch(Copy_u8Port)
    1366:	8a 81       	ldd	r24, Y+2	; 0x02
    1368:	28 2f       	mov	r18, r24
    136a:	30 e0       	ldi	r19, 0x00	; 0
    136c:	3e 83       	std	Y+6, r19	; 0x06
    136e:	2d 83       	std	Y+5, r18	; 0x05
    1370:	8d 81       	ldd	r24, Y+5	; 0x05
    1372:	9e 81       	ldd	r25, Y+6	; 0x06
    1374:	81 30       	cpi	r24, 0x01	; 1
    1376:	91 05       	cpc	r25, r1
    1378:	59 f1       	breq	.+86     	; 0x13d0 <DIO_u8SetPinValue+0x194>
    137a:	2d 81       	ldd	r18, Y+5	; 0x05
    137c:	3e 81       	ldd	r19, Y+6	; 0x06
    137e:	22 30       	cpi	r18, 0x02	; 2
    1380:	31 05       	cpc	r19, r1
    1382:	2c f4       	brge	.+10     	; 0x138e <DIO_u8SetPinValue+0x152>
    1384:	8d 81       	ldd	r24, Y+5	; 0x05
    1386:	9e 81       	ldd	r25, Y+6	; 0x06
    1388:	00 97       	sbiw	r24, 0x00	; 0
    138a:	69 f0       	breq	.+26     	; 0x13a6 <DIO_u8SetPinValue+0x16a>
    138c:	5f c0       	rjmp	.+190    	; 0x144c <DIO_u8SetPinValue+0x210>
    138e:	2d 81       	ldd	r18, Y+5	; 0x05
    1390:	3e 81       	ldd	r19, Y+6	; 0x06
    1392:	22 30       	cpi	r18, 0x02	; 2
    1394:	31 05       	cpc	r19, r1
    1396:	89 f1       	breq	.+98     	; 0x13fa <DIO_u8SetPinValue+0x1be>
    1398:	8d 81       	ldd	r24, Y+5	; 0x05
    139a:	9e 81       	ldd	r25, Y+6	; 0x06
    139c:	83 30       	cpi	r24, 0x03	; 3
    139e:	91 05       	cpc	r25, r1
    13a0:	09 f4       	brne	.+2      	; 0x13a4 <DIO_u8SetPinValue+0x168>
    13a2:	40 c0       	rjmp	.+128    	; 0x1424 <DIO_u8SetPinValue+0x1e8>
    13a4:	53 c0       	rjmp	.+166    	; 0x144c <DIO_u8SetPinValue+0x210>
		 		 {
		 case DIO_PORTA:CLR_BIT(PORTA,Copy_u8Pin);break;
    13a6:	ab e3       	ldi	r26, 0x3B	; 59
    13a8:	b0 e0       	ldi	r27, 0x00	; 0
    13aa:	eb e3       	ldi	r30, 0x3B	; 59
    13ac:	f0 e0       	ldi	r31, 0x00	; 0
    13ae:	80 81       	ld	r24, Z
    13b0:	48 2f       	mov	r20, r24
    13b2:	8b 81       	ldd	r24, Y+3	; 0x03
    13b4:	28 2f       	mov	r18, r24
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	02 2e       	mov	r0, r18
    13be:	02 c0       	rjmp	.+4      	; 0x13c4 <DIO_u8SetPinValue+0x188>
    13c0:	88 0f       	add	r24, r24
    13c2:	99 1f       	adc	r25, r25
    13c4:	0a 94       	dec	r0
    13c6:	e2 f7       	brpl	.-8      	; 0x13c0 <DIO_u8SetPinValue+0x184>
    13c8:	80 95       	com	r24
    13ca:	84 23       	and	r24, r20
    13cc:	8c 93       	st	X, r24
    13ce:	3e c0       	rjmp	.+124    	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTB:CLR_BIT(PORTB,Copy_u8Pin);break;
    13d0:	a8 e3       	ldi	r26, 0x38	; 56
    13d2:	b0 e0       	ldi	r27, 0x00	; 0
    13d4:	e8 e3       	ldi	r30, 0x38	; 56
    13d6:	f0 e0       	ldi	r31, 0x00	; 0
    13d8:	80 81       	ld	r24, Z
    13da:	48 2f       	mov	r20, r24
    13dc:	8b 81       	ldd	r24, Y+3	; 0x03
    13de:	28 2f       	mov	r18, r24
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	90 e0       	ldi	r25, 0x00	; 0
    13e6:	02 2e       	mov	r0, r18
    13e8:	02 c0       	rjmp	.+4      	; 0x13ee <DIO_u8SetPinValue+0x1b2>
    13ea:	88 0f       	add	r24, r24
    13ec:	99 1f       	adc	r25, r25
    13ee:	0a 94       	dec	r0
    13f0:	e2 f7       	brpl	.-8      	; 0x13ea <DIO_u8SetPinValue+0x1ae>
    13f2:	80 95       	com	r24
    13f4:	84 23       	and	r24, r20
    13f6:	8c 93       	st	X, r24
    13f8:	29 c0       	rjmp	.+82     	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTC:CLR_BIT(PORTC,Copy_u8Pin);break;
    13fa:	a5 e3       	ldi	r26, 0x35	; 53
    13fc:	b0 e0       	ldi	r27, 0x00	; 0
    13fe:	e5 e3       	ldi	r30, 0x35	; 53
    1400:	f0 e0       	ldi	r31, 0x00	; 0
    1402:	80 81       	ld	r24, Z
    1404:	48 2f       	mov	r20, r24
    1406:	8b 81       	ldd	r24, Y+3	; 0x03
    1408:	28 2f       	mov	r18, r24
    140a:	30 e0       	ldi	r19, 0x00	; 0
    140c:	81 e0       	ldi	r24, 0x01	; 1
    140e:	90 e0       	ldi	r25, 0x00	; 0
    1410:	02 2e       	mov	r0, r18
    1412:	02 c0       	rjmp	.+4      	; 0x1418 <DIO_u8SetPinValue+0x1dc>
    1414:	88 0f       	add	r24, r24
    1416:	99 1f       	adc	r25, r25
    1418:	0a 94       	dec	r0
    141a:	e2 f7       	brpl	.-8      	; 0x1414 <DIO_u8SetPinValue+0x1d8>
    141c:	80 95       	com	r24
    141e:	84 23       	and	r24, r20
    1420:	8c 93       	st	X, r24
    1422:	14 c0       	rjmp	.+40     	; 0x144c <DIO_u8SetPinValue+0x210>
		 case DIO_PORTD:CLR_BIT(PORTD,Copy_u8Pin);break;
    1424:	a2 e3       	ldi	r26, 0x32	; 50
    1426:	b0 e0       	ldi	r27, 0x00	; 0
    1428:	e2 e3       	ldi	r30, 0x32	; 50
    142a:	f0 e0       	ldi	r31, 0x00	; 0
    142c:	80 81       	ld	r24, Z
    142e:	48 2f       	mov	r20, r24
    1430:	8b 81       	ldd	r24, Y+3	; 0x03
    1432:	28 2f       	mov	r18, r24
    1434:	30 e0       	ldi	r19, 0x00	; 0
    1436:	81 e0       	ldi	r24, 0x01	; 1
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	02 2e       	mov	r0, r18
    143c:	02 c0       	rjmp	.+4      	; 0x1442 <DIO_u8SetPinValue+0x206>
    143e:	88 0f       	add	r24, r24
    1440:	99 1f       	adc	r25, r25
    1442:	0a 94       	dec	r0
    1444:	e2 f7       	brpl	.-8      	; 0x143e <DIO_u8SetPinValue+0x202>
    1446:	80 95       	com	r24
    1448:	84 23       	and	r24, r20
    144a:	8c 93       	st	X, r24
		 default:;
		 		 }
	 }
 }
 return Local_u8ErrorState;
    144c:	99 81       	ldd	r25, Y+1	; 0x01
    144e:	99 87       	std	Y+9, r25	; 0x09
    1450:	89 85       	ldd	r24, Y+9	; 0x09
}
    1452:	29 96       	adiw	r28, 0x09	; 9
    1454:	0f b6       	in	r0, 0x3f	; 63
    1456:	f8 94       	cli
    1458:	de bf       	out	0x3e, r29	; 62
    145a:	0f be       	out	0x3f, r0	; 63
    145c:	cd bf       	out	0x3d, r28	; 61
    145e:	cf 91       	pop	r28
    1460:	df 91       	pop	r29
    1462:	08 95       	ret

00001464 <DIO_u8SetPortDir>:

u8 DIO_u8SetPortDir(u8 Copy_u8Port,u8 Copy_u8Direction)
{
    1464:	df 93       	push	r29
    1466:	cf 93       	push	r28
    1468:	00 d0       	rcall	.+0      	; 0x146a <DIO_u8SetPortDir+0x6>
    146a:	00 d0       	rcall	.+0      	; 0x146c <DIO_u8SetPortDir+0x8>
    146c:	00 d0       	rcall	.+0      	; 0x146e <DIO_u8SetPortDir+0xa>
    146e:	cd b7       	in	r28, 0x3d	; 61
    1470:	de b7       	in	r29, 0x3e	; 62
    1472:	8a 83       	std	Y+2, r24	; 0x02
    1474:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    1476:	19 82       	std	Y+1, r1	; 0x01
if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    1478:	8a 81       	ldd	r24, Y+2	; 0x02
    147a:	84 30       	cpi	r24, 0x04	; 4
    147c:	28 f0       	brcs	.+10     	; 0x1488 <DIO_u8SetPortDir+0x24>
{
	   Local_u8ErrorState=1;
    147e:	81 e0       	ldi	r24, 0x01	; 1
    1480:	89 83       	std	Y+1, r24	; 0x01
	  return Local_u8ErrorState;
    1482:	29 81       	ldd	r18, Y+1	; 0x01
    1484:	2e 83       	std	Y+6, r18	; 0x06
    1486:	34 c0       	rjmp	.+104    	; 0x14f0 <DIO_u8SetPortDir+0x8c>
}
else
{

     switch(Copy_u8Port)
    1488:	8a 81       	ldd	r24, Y+2	; 0x02
    148a:	28 2f       	mov	r18, r24
    148c:	30 e0       	ldi	r19, 0x00	; 0
    148e:	3d 83       	std	Y+5, r19	; 0x05
    1490:	2c 83       	std	Y+4, r18	; 0x04
    1492:	8c 81       	ldd	r24, Y+4	; 0x04
    1494:	9d 81       	ldd	r25, Y+5	; 0x05
    1496:	81 30       	cpi	r24, 0x01	; 1
    1498:	91 05       	cpc	r25, r1
    149a:	d1 f0       	breq	.+52     	; 0x14d0 <DIO_u8SetPortDir+0x6c>
    149c:	2c 81       	ldd	r18, Y+4	; 0x04
    149e:	3d 81       	ldd	r19, Y+5	; 0x05
    14a0:	22 30       	cpi	r18, 0x02	; 2
    14a2:	31 05       	cpc	r19, r1
    14a4:	2c f4       	brge	.+10     	; 0x14b0 <DIO_u8SetPortDir+0x4c>
    14a6:	8c 81       	ldd	r24, Y+4	; 0x04
    14a8:	9d 81       	ldd	r25, Y+5	; 0x05
    14aa:	00 97       	sbiw	r24, 0x00	; 0
    14ac:	61 f0       	breq	.+24     	; 0x14c6 <DIO_u8SetPortDir+0x62>
    14ae:	1e c0       	rjmp	.+60     	; 0x14ec <DIO_u8SetPortDir+0x88>
    14b0:	2c 81       	ldd	r18, Y+4	; 0x04
    14b2:	3d 81       	ldd	r19, Y+5	; 0x05
    14b4:	22 30       	cpi	r18, 0x02	; 2
    14b6:	31 05       	cpc	r19, r1
    14b8:	81 f0       	breq	.+32     	; 0x14da <DIO_u8SetPortDir+0x76>
    14ba:	8c 81       	ldd	r24, Y+4	; 0x04
    14bc:	9d 81       	ldd	r25, Y+5	; 0x05
    14be:	83 30       	cpi	r24, 0x03	; 3
    14c0:	91 05       	cpc	r25, r1
    14c2:	81 f0       	breq	.+32     	; 0x14e4 <DIO_u8SetPortDir+0x80>
    14c4:	13 c0       	rjmp	.+38     	; 0x14ec <DIO_u8SetPortDir+0x88>
     {
     case DIO_PORTA:DDRA=Copy_u8Direction;break;
    14c6:	ea e3       	ldi	r30, 0x3A	; 58
    14c8:	f0 e0       	ldi	r31, 0x00	; 0
    14ca:	8b 81       	ldd	r24, Y+3	; 0x03
    14cc:	80 83       	st	Z, r24
    14ce:	0e c0       	rjmp	.+28     	; 0x14ec <DIO_u8SetPortDir+0x88>
     case DIO_PORTB:DDRB=Copy_u8Direction;break;
    14d0:	e7 e3       	ldi	r30, 0x37	; 55
    14d2:	f0 e0       	ldi	r31, 0x00	; 0
    14d4:	8b 81       	ldd	r24, Y+3	; 0x03
    14d6:	80 83       	st	Z, r24
    14d8:	09 c0       	rjmp	.+18     	; 0x14ec <DIO_u8SetPortDir+0x88>
     case DIO_PORTC:DDRC=Copy_u8Direction;break;
    14da:	e4 e3       	ldi	r30, 0x34	; 52
    14dc:	f0 e0       	ldi	r31, 0x00	; 0
    14de:	8b 81       	ldd	r24, Y+3	; 0x03
    14e0:	80 83       	st	Z, r24
    14e2:	04 c0       	rjmp	.+8      	; 0x14ec <DIO_u8SetPortDir+0x88>
     case DIO_PORTD:DDRD=Copy_u8Direction;break;
    14e4:	e1 e3       	ldi	r30, 0x31	; 49
    14e6:	f0 e0       	ldi	r31, 0x00	; 0
    14e8:	8b 81       	ldd	r24, Y+3	; 0x03
    14ea:	80 83       	st	Z, r24




  }
return Local_u8ErrorState;
    14ec:	99 81       	ldd	r25, Y+1	; 0x01
    14ee:	9e 83       	std	Y+6, r25	; 0x06
    14f0:	8e 81       	ldd	r24, Y+6	; 0x06
}
    14f2:	26 96       	adiw	r28, 0x06	; 6
    14f4:	0f b6       	in	r0, 0x3f	; 63
    14f6:	f8 94       	cli
    14f8:	de bf       	out	0x3e, r29	; 62
    14fa:	0f be       	out	0x3f, r0	; 63
    14fc:	cd bf       	out	0x3d, r28	; 61
    14fe:	cf 91       	pop	r28
    1500:	df 91       	pop	r29
    1502:	08 95       	ret

00001504 <DIO_u8SetPinDir>:


u8 DIO_u8SetPinDir(u8 Copy_u8Port,u8 Copy_u8Pin,u8 Copy_u8Direction)
{
    1504:	df 93       	push	r29
    1506:	cf 93       	push	r28
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
    150c:	29 97       	sbiw	r28, 0x09	; 9
    150e:	0f b6       	in	r0, 0x3f	; 63
    1510:	f8 94       	cli
    1512:	de bf       	out	0x3e, r29	; 62
    1514:	0f be       	out	0x3f, r0	; 63
    1516:	cd bf       	out	0x3d, r28	; 61
    1518:	8a 83       	std	Y+2, r24	; 0x02
    151a:	6b 83       	std	Y+3, r22	; 0x03
    151c:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    151e:	19 82       	std	Y+1, r1	; 0x01

	 if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    1520:	8a 81       	ldd	r24, Y+2	; 0x02
    1522:	84 30       	cpi	r24, 0x04	; 4
    1524:	28 f0       	brcs	.+10     	; 0x1530 <DIO_u8SetPinDir+0x2c>
	    {
	 	   Local_u8ErrorState=1;
    1526:	81 e0       	ldi	r24, 0x01	; 1
    1528:	89 83       	std	Y+1, r24	; 0x01
	 	  return Local_u8ErrorState;
    152a:	29 81       	ldd	r18, Y+1	; 0x01
    152c:	29 87       	std	Y+9, r18	; 0x09
    152e:	f4 c0       	rjmp	.+488    	; 0x1718 <DIO_u8SetPinDir+0x214>
	    }
	 else if ((Copy_u8Pin>DIO_PIN7)||(Copy_u8Pin<DIO_PIN0))
    1530:	8b 81       	ldd	r24, Y+3	; 0x03
    1532:	88 30       	cpi	r24, 0x08	; 8
    1534:	28 f0       	brcs	.+10     	; 0x1540 <DIO_u8SetPinDir+0x3c>
	 {
		   Local_u8ErrorState=1;
    1536:	81 e0       	ldi	r24, 0x01	; 1
    1538:	89 83       	std	Y+1, r24	; 0x01
	       return Local_u8ErrorState;
    153a:	39 81       	ldd	r19, Y+1	; 0x01
    153c:	39 87       	std	Y+9, r19	; 0x09
    153e:	ec c0       	rjmp	.+472    	; 0x1718 <DIO_u8SetPinDir+0x214>
	 }
	 else
	 {
		 if(Copy_u8Direction==DIO_PIN_OUT)
    1540:	8c 81       	ldd	r24, Y+4	; 0x04
    1542:	81 30       	cpi	r24, 0x01	; 1
    1544:	09 f0       	breq	.+2      	; 0x1548 <DIO_u8SetPinDir+0x44>
    1546:	6f c0       	rjmp	.+222    	; 0x1626 <DIO_u8SetPinDir+0x122>
		 {
			switch(Copy_u8Port)
    1548:	8a 81       	ldd	r24, Y+2	; 0x02
    154a:	28 2f       	mov	r18, r24
    154c:	30 e0       	ldi	r19, 0x00	; 0
    154e:	38 87       	std	Y+8, r19	; 0x08
    1550:	2f 83       	std	Y+7, r18	; 0x07
    1552:	8f 81       	ldd	r24, Y+7	; 0x07
    1554:	98 85       	ldd	r25, Y+8	; 0x08
    1556:	81 30       	cpi	r24, 0x01	; 1
    1558:	91 05       	cpc	r25, r1
    155a:	49 f1       	breq	.+82     	; 0x15ae <DIO_u8SetPinDir+0xaa>
    155c:	2f 81       	ldd	r18, Y+7	; 0x07
    155e:	38 85       	ldd	r19, Y+8	; 0x08
    1560:	22 30       	cpi	r18, 0x02	; 2
    1562:	31 05       	cpc	r19, r1
    1564:	2c f4       	brge	.+10     	; 0x1570 <DIO_u8SetPinDir+0x6c>
    1566:	8f 81       	ldd	r24, Y+7	; 0x07
    1568:	98 85       	ldd	r25, Y+8	; 0x08
    156a:	00 97       	sbiw	r24, 0x00	; 0
    156c:	61 f0       	breq	.+24     	; 0x1586 <DIO_u8SetPinDir+0x82>
    156e:	d2 c0       	rjmp	.+420    	; 0x1714 <DIO_u8SetPinDir+0x210>
    1570:	2f 81       	ldd	r18, Y+7	; 0x07
    1572:	38 85       	ldd	r19, Y+8	; 0x08
    1574:	22 30       	cpi	r18, 0x02	; 2
    1576:	31 05       	cpc	r19, r1
    1578:	71 f1       	breq	.+92     	; 0x15d6 <DIO_u8SetPinDir+0xd2>
    157a:	8f 81       	ldd	r24, Y+7	; 0x07
    157c:	98 85       	ldd	r25, Y+8	; 0x08
    157e:	83 30       	cpi	r24, 0x03	; 3
    1580:	91 05       	cpc	r25, r1
    1582:	e9 f1       	breq	.+122    	; 0x15fe <DIO_u8SetPinDir+0xfa>
    1584:	c7 c0       	rjmp	.+398    	; 0x1714 <DIO_u8SetPinDir+0x210>
			{case DIO_PORTA:SET_BIT(DDRA,Copy_u8Pin);break;
    1586:	aa e3       	ldi	r26, 0x3A	; 58
    1588:	b0 e0       	ldi	r27, 0x00	; 0
    158a:	ea e3       	ldi	r30, 0x3A	; 58
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	80 81       	ld	r24, Z
    1590:	48 2f       	mov	r20, r24
    1592:	8b 81       	ldd	r24, Y+3	; 0x03
    1594:	28 2f       	mov	r18, r24
    1596:	30 e0       	ldi	r19, 0x00	; 0
    1598:	81 e0       	ldi	r24, 0x01	; 1
    159a:	90 e0       	ldi	r25, 0x00	; 0
    159c:	02 2e       	mov	r0, r18
    159e:	02 c0       	rjmp	.+4      	; 0x15a4 <DIO_u8SetPinDir+0xa0>
    15a0:	88 0f       	add	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	0a 94       	dec	r0
    15a6:	e2 f7       	brpl	.-8      	; 0x15a0 <DIO_u8SetPinDir+0x9c>
    15a8:	84 2b       	or	r24, r20
    15aa:	8c 93       	st	X, r24
    15ac:	b3 c0       	rjmp	.+358    	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTB:SET_BIT(DDRB,Copy_u8Pin);break;
    15ae:	a7 e3       	ldi	r26, 0x37	; 55
    15b0:	b0 e0       	ldi	r27, 0x00	; 0
    15b2:	e7 e3       	ldi	r30, 0x37	; 55
    15b4:	f0 e0       	ldi	r31, 0x00	; 0
    15b6:	80 81       	ld	r24, Z
    15b8:	48 2f       	mov	r20, r24
    15ba:	8b 81       	ldd	r24, Y+3	; 0x03
    15bc:	28 2f       	mov	r18, r24
    15be:	30 e0       	ldi	r19, 0x00	; 0
    15c0:	81 e0       	ldi	r24, 0x01	; 1
    15c2:	90 e0       	ldi	r25, 0x00	; 0
    15c4:	02 2e       	mov	r0, r18
    15c6:	02 c0       	rjmp	.+4      	; 0x15cc <DIO_u8SetPinDir+0xc8>
    15c8:	88 0f       	add	r24, r24
    15ca:	99 1f       	adc	r25, r25
    15cc:	0a 94       	dec	r0
    15ce:	e2 f7       	brpl	.-8      	; 0x15c8 <DIO_u8SetPinDir+0xc4>
    15d0:	84 2b       	or	r24, r20
    15d2:	8c 93       	st	X, r24
    15d4:	9f c0       	rjmp	.+318    	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTC:SET_BIT(DDRC,Copy_u8Pin);break;
    15d6:	a4 e3       	ldi	r26, 0x34	; 52
    15d8:	b0 e0       	ldi	r27, 0x00	; 0
    15da:	e4 e3       	ldi	r30, 0x34	; 52
    15dc:	f0 e0       	ldi	r31, 0x00	; 0
    15de:	80 81       	ld	r24, Z
    15e0:	48 2f       	mov	r20, r24
    15e2:	8b 81       	ldd	r24, Y+3	; 0x03
    15e4:	28 2f       	mov	r18, r24
    15e6:	30 e0       	ldi	r19, 0x00	; 0
    15e8:	81 e0       	ldi	r24, 0x01	; 1
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	02 2e       	mov	r0, r18
    15ee:	02 c0       	rjmp	.+4      	; 0x15f4 <DIO_u8SetPinDir+0xf0>
    15f0:	88 0f       	add	r24, r24
    15f2:	99 1f       	adc	r25, r25
    15f4:	0a 94       	dec	r0
    15f6:	e2 f7       	brpl	.-8      	; 0x15f0 <DIO_u8SetPinDir+0xec>
    15f8:	84 2b       	or	r24, r20
    15fa:	8c 93       	st	X, r24
    15fc:	8b c0       	rjmp	.+278    	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTD:SET_BIT(DDRD,Copy_u8Pin);break;
    15fe:	a1 e3       	ldi	r26, 0x31	; 49
    1600:	b0 e0       	ldi	r27, 0x00	; 0
    1602:	e1 e3       	ldi	r30, 0x31	; 49
    1604:	f0 e0       	ldi	r31, 0x00	; 0
    1606:	80 81       	ld	r24, Z
    1608:	48 2f       	mov	r20, r24
    160a:	8b 81       	ldd	r24, Y+3	; 0x03
    160c:	28 2f       	mov	r18, r24
    160e:	30 e0       	ldi	r19, 0x00	; 0
    1610:	81 e0       	ldi	r24, 0x01	; 1
    1612:	90 e0       	ldi	r25, 0x00	; 0
    1614:	02 2e       	mov	r0, r18
    1616:	02 c0       	rjmp	.+4      	; 0x161c <DIO_u8SetPinDir+0x118>
    1618:	88 0f       	add	r24, r24
    161a:	99 1f       	adc	r25, r25
    161c:	0a 94       	dec	r0
    161e:	e2 f7       	brpl	.-8      	; 0x1618 <DIO_u8SetPinDir+0x114>
    1620:	84 2b       	or	r24, r20
    1622:	8c 93       	st	X, r24
    1624:	77 c0       	rjmp	.+238    	; 0x1714 <DIO_u8SetPinDir+0x210>
			}
		 }
		 else if(Copy_u8Direction==DIO_PIN_IN)
    1626:	8c 81       	ldd	r24, Y+4	; 0x04
    1628:	88 23       	and	r24, r24
    162a:	09 f0       	breq	.+2      	; 0x162e <DIO_u8SetPinDir+0x12a>
    162c:	73 c0       	rjmp	.+230    	; 0x1714 <DIO_u8SetPinDir+0x210>
		 {
			 switch(Copy_u8Port)
    162e:	8a 81       	ldd	r24, Y+2	; 0x02
    1630:	28 2f       	mov	r18, r24
    1632:	30 e0       	ldi	r19, 0x00	; 0
    1634:	3e 83       	std	Y+6, r19	; 0x06
    1636:	2d 83       	std	Y+5, r18	; 0x05
    1638:	8d 81       	ldd	r24, Y+5	; 0x05
    163a:	9e 81       	ldd	r25, Y+6	; 0x06
    163c:	81 30       	cpi	r24, 0x01	; 1
    163e:	91 05       	cpc	r25, r1
    1640:	59 f1       	breq	.+86     	; 0x1698 <DIO_u8SetPinDir+0x194>
    1642:	2d 81       	ldd	r18, Y+5	; 0x05
    1644:	3e 81       	ldd	r19, Y+6	; 0x06
    1646:	22 30       	cpi	r18, 0x02	; 2
    1648:	31 05       	cpc	r19, r1
    164a:	2c f4       	brge	.+10     	; 0x1656 <DIO_u8SetPinDir+0x152>
    164c:	8d 81       	ldd	r24, Y+5	; 0x05
    164e:	9e 81       	ldd	r25, Y+6	; 0x06
    1650:	00 97       	sbiw	r24, 0x00	; 0
    1652:	69 f0       	breq	.+26     	; 0x166e <DIO_u8SetPinDir+0x16a>
    1654:	5f c0       	rjmp	.+190    	; 0x1714 <DIO_u8SetPinDir+0x210>
    1656:	2d 81       	ldd	r18, Y+5	; 0x05
    1658:	3e 81       	ldd	r19, Y+6	; 0x06
    165a:	22 30       	cpi	r18, 0x02	; 2
    165c:	31 05       	cpc	r19, r1
    165e:	89 f1       	breq	.+98     	; 0x16c2 <DIO_u8SetPinDir+0x1be>
    1660:	8d 81       	ldd	r24, Y+5	; 0x05
    1662:	9e 81       	ldd	r25, Y+6	; 0x06
    1664:	83 30       	cpi	r24, 0x03	; 3
    1666:	91 05       	cpc	r25, r1
    1668:	09 f4       	brne	.+2      	; 0x166c <DIO_u8SetPinDir+0x168>
    166a:	40 c0       	rjmp	.+128    	; 0x16ec <DIO_u8SetPinDir+0x1e8>
    166c:	53 c0       	rjmp	.+166    	; 0x1714 <DIO_u8SetPinDir+0x210>
			{
		    case DIO_PORTA:CLR_BIT(DDRA,Copy_u8Pin);break;
    166e:	aa e3       	ldi	r26, 0x3A	; 58
    1670:	b0 e0       	ldi	r27, 0x00	; 0
    1672:	ea e3       	ldi	r30, 0x3A	; 58
    1674:	f0 e0       	ldi	r31, 0x00	; 0
    1676:	80 81       	ld	r24, Z
    1678:	48 2f       	mov	r20, r24
    167a:	8b 81       	ldd	r24, Y+3	; 0x03
    167c:	28 2f       	mov	r18, r24
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	81 e0       	ldi	r24, 0x01	; 1
    1682:	90 e0       	ldi	r25, 0x00	; 0
    1684:	02 2e       	mov	r0, r18
    1686:	02 c0       	rjmp	.+4      	; 0x168c <DIO_u8SetPinDir+0x188>
    1688:	88 0f       	add	r24, r24
    168a:	99 1f       	adc	r25, r25
    168c:	0a 94       	dec	r0
    168e:	e2 f7       	brpl	.-8      	; 0x1688 <DIO_u8SetPinDir+0x184>
    1690:	80 95       	com	r24
    1692:	84 23       	and	r24, r20
    1694:	8c 93       	st	X, r24
    1696:	3e c0       	rjmp	.+124    	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTB:CLR_BIT(DDRB,Copy_u8Pin);break;
    1698:	a7 e3       	ldi	r26, 0x37	; 55
    169a:	b0 e0       	ldi	r27, 0x00	; 0
    169c:	e7 e3       	ldi	r30, 0x37	; 55
    169e:	f0 e0       	ldi	r31, 0x00	; 0
    16a0:	80 81       	ld	r24, Z
    16a2:	48 2f       	mov	r20, r24
    16a4:	8b 81       	ldd	r24, Y+3	; 0x03
    16a6:	28 2f       	mov	r18, r24
    16a8:	30 e0       	ldi	r19, 0x00	; 0
    16aa:	81 e0       	ldi	r24, 0x01	; 1
    16ac:	90 e0       	ldi	r25, 0x00	; 0
    16ae:	02 2e       	mov	r0, r18
    16b0:	02 c0       	rjmp	.+4      	; 0x16b6 <DIO_u8SetPinDir+0x1b2>
    16b2:	88 0f       	add	r24, r24
    16b4:	99 1f       	adc	r25, r25
    16b6:	0a 94       	dec	r0
    16b8:	e2 f7       	brpl	.-8      	; 0x16b2 <DIO_u8SetPinDir+0x1ae>
    16ba:	80 95       	com	r24
    16bc:	84 23       	and	r24, r20
    16be:	8c 93       	st	X, r24
    16c0:	29 c0       	rjmp	.+82     	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTC:CLR_BIT(DDRC,Copy_u8Pin);break;
    16c2:	a4 e3       	ldi	r26, 0x34	; 52
    16c4:	b0 e0       	ldi	r27, 0x00	; 0
    16c6:	e4 e3       	ldi	r30, 0x34	; 52
    16c8:	f0 e0       	ldi	r31, 0x00	; 0
    16ca:	80 81       	ld	r24, Z
    16cc:	48 2f       	mov	r20, r24
    16ce:	8b 81       	ldd	r24, Y+3	; 0x03
    16d0:	28 2f       	mov	r18, r24
    16d2:	30 e0       	ldi	r19, 0x00	; 0
    16d4:	81 e0       	ldi	r24, 0x01	; 1
    16d6:	90 e0       	ldi	r25, 0x00	; 0
    16d8:	02 2e       	mov	r0, r18
    16da:	02 c0       	rjmp	.+4      	; 0x16e0 <DIO_u8SetPinDir+0x1dc>
    16dc:	88 0f       	add	r24, r24
    16de:	99 1f       	adc	r25, r25
    16e0:	0a 94       	dec	r0
    16e2:	e2 f7       	brpl	.-8      	; 0x16dc <DIO_u8SetPinDir+0x1d8>
    16e4:	80 95       	com	r24
    16e6:	84 23       	and	r24, r20
    16e8:	8c 93       	st	X, r24
    16ea:	14 c0       	rjmp	.+40     	; 0x1714 <DIO_u8SetPinDir+0x210>
			case DIO_PORTD:CLR_BIT(DDRD,Copy_u8Pin);break;
    16ec:	a1 e3       	ldi	r26, 0x31	; 49
    16ee:	b0 e0       	ldi	r27, 0x00	; 0
    16f0:	e1 e3       	ldi	r30, 0x31	; 49
    16f2:	f0 e0       	ldi	r31, 0x00	; 0
    16f4:	80 81       	ld	r24, Z
    16f6:	48 2f       	mov	r20, r24
    16f8:	8b 81       	ldd	r24, Y+3	; 0x03
    16fa:	28 2f       	mov	r18, r24
    16fc:	30 e0       	ldi	r19, 0x00	; 0
    16fe:	81 e0       	ldi	r24, 0x01	; 1
    1700:	90 e0       	ldi	r25, 0x00	; 0
    1702:	02 2e       	mov	r0, r18
    1704:	02 c0       	rjmp	.+4      	; 0x170a <DIO_u8SetPinDir+0x206>
    1706:	88 0f       	add	r24, r24
    1708:	99 1f       	adc	r25, r25
    170a:	0a 94       	dec	r0
    170c:	e2 f7       	brpl	.-8      	; 0x1706 <DIO_u8SetPinDir+0x202>
    170e:	80 95       	com	r24
    1710:	84 23       	and	r24, r20
    1712:	8c 93       	st	X, r24
			}

		 }

	 }
return Local_u8ErrorState;
    1714:	99 81       	ldd	r25, Y+1	; 0x01
    1716:	99 87       	std	Y+9, r25	; 0x09
    1718:	89 85       	ldd	r24, Y+9	; 0x09
}
    171a:	29 96       	adiw	r28, 0x09	; 9
    171c:	0f b6       	in	r0, 0x3f	; 63
    171e:	f8 94       	cli
    1720:	de bf       	out	0x3e, r29	; 62
    1722:	0f be       	out	0x3f, r0	; 63
    1724:	cd bf       	out	0x3d, r28	; 61
    1726:	cf 91       	pop	r28
    1728:	df 91       	pop	r29
    172a:	08 95       	ret

0000172c <DIO_u8GetPortValue>:

u8 DIO_u8GetPortValue(u8 Copy_u8Port,u8 *Copy_u8Value)
{
    172c:	df 93       	push	r29
    172e:	cf 93       	push	r28
    1730:	cd b7       	in	r28, 0x3d	; 61
    1732:	de b7       	in	r29, 0x3e	; 62
    1734:	27 97       	sbiw	r28, 0x07	; 7
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	de bf       	out	0x3e, r29	; 62
    173c:	0f be       	out	0x3f, r0	; 63
    173e:	cd bf       	out	0x3d, r28	; 61
    1740:	8a 83       	std	Y+2, r24	; 0x02
    1742:	7c 83       	std	Y+4, r23	; 0x04
    1744:	6b 83       	std	Y+3, r22	; 0x03
	u8 Local_u8ErrorState=0;
    1746:	19 82       	std	Y+1, r1	; 0x01
	if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    1748:	8a 81       	ldd	r24, Y+2	; 0x02
    174a:	84 30       	cpi	r24, 0x04	; 4
    174c:	28 f0       	brcs	.+10     	; 0x1758 <DIO_u8GetPortValue+0x2c>
	{
		   Local_u8ErrorState=1;
    174e:	81 e0       	ldi	r24, 0x01	; 1
    1750:	89 83       	std	Y+1, r24	; 0x01
		  return Local_u8ErrorState;
    1752:	29 81       	ldd	r18, Y+1	; 0x01
    1754:	2f 83       	std	Y+7, r18	; 0x07
    1756:	3c c0       	rjmp	.+120    	; 0x17d0 <DIO_u8GetPortValue+0xa4>
	}
	else
	{
		switch(Copy_u8Port)
    1758:	8a 81       	ldd	r24, Y+2	; 0x02
    175a:	28 2f       	mov	r18, r24
    175c:	30 e0       	ldi	r19, 0x00	; 0
    175e:	3e 83       	std	Y+6, r19	; 0x06
    1760:	2d 83       	std	Y+5, r18	; 0x05
    1762:	8d 81       	ldd	r24, Y+5	; 0x05
    1764:	9e 81       	ldd	r25, Y+6	; 0x06
    1766:	81 30       	cpi	r24, 0x01	; 1
    1768:	91 05       	cpc	r25, r1
    176a:	e1 f0       	breq	.+56     	; 0x17a4 <DIO_u8GetPortValue+0x78>
    176c:	2d 81       	ldd	r18, Y+5	; 0x05
    176e:	3e 81       	ldd	r19, Y+6	; 0x06
    1770:	22 30       	cpi	r18, 0x02	; 2
    1772:	31 05       	cpc	r19, r1
    1774:	2c f4       	brge	.+10     	; 0x1780 <DIO_u8GetPortValue+0x54>
    1776:	8d 81       	ldd	r24, Y+5	; 0x05
    1778:	9e 81       	ldd	r25, Y+6	; 0x06
    177a:	00 97       	sbiw	r24, 0x00	; 0
    177c:	61 f0       	breq	.+24     	; 0x1796 <DIO_u8GetPortValue+0x6a>
    177e:	26 c0       	rjmp	.+76     	; 0x17cc <DIO_u8GetPortValue+0xa0>
    1780:	2d 81       	ldd	r18, Y+5	; 0x05
    1782:	3e 81       	ldd	r19, Y+6	; 0x06
    1784:	22 30       	cpi	r18, 0x02	; 2
    1786:	31 05       	cpc	r19, r1
    1788:	a1 f0       	breq	.+40     	; 0x17b2 <DIO_u8GetPortValue+0x86>
    178a:	8d 81       	ldd	r24, Y+5	; 0x05
    178c:	9e 81       	ldd	r25, Y+6	; 0x06
    178e:	83 30       	cpi	r24, 0x03	; 3
    1790:	91 05       	cpc	r25, r1
    1792:	b1 f0       	breq	.+44     	; 0x17c0 <DIO_u8GetPortValue+0x94>
    1794:	1b c0       	rjmp	.+54     	; 0x17cc <DIO_u8GetPortValue+0xa0>
		{
		case DIO_PORTA:*Copy_u8Value=PINA;break;
    1796:	e9 e3       	ldi	r30, 0x39	; 57
    1798:	f0 e0       	ldi	r31, 0x00	; 0
    179a:	80 81       	ld	r24, Z
    179c:	eb 81       	ldd	r30, Y+3	; 0x03
    179e:	fc 81       	ldd	r31, Y+4	; 0x04
    17a0:	80 83       	st	Z, r24
    17a2:	14 c0       	rjmp	.+40     	; 0x17cc <DIO_u8GetPortValue+0xa0>
		case DIO_PORTB:*Copy_u8Value=PINB;break;
    17a4:	e6 e3       	ldi	r30, 0x36	; 54
    17a6:	f0 e0       	ldi	r31, 0x00	; 0
    17a8:	80 81       	ld	r24, Z
    17aa:	eb 81       	ldd	r30, Y+3	; 0x03
    17ac:	fc 81       	ldd	r31, Y+4	; 0x04
    17ae:	80 83       	st	Z, r24
    17b0:	0d c0       	rjmp	.+26     	; 0x17cc <DIO_u8GetPortValue+0xa0>
		case DIO_PORTC:*Copy_u8Value=PINC;break;
    17b2:	e3 e3       	ldi	r30, 0x33	; 51
    17b4:	f0 e0       	ldi	r31, 0x00	; 0
    17b6:	80 81       	ld	r24, Z
    17b8:	eb 81       	ldd	r30, Y+3	; 0x03
    17ba:	fc 81       	ldd	r31, Y+4	; 0x04
    17bc:	80 83       	st	Z, r24
    17be:	06 c0       	rjmp	.+12     	; 0x17cc <DIO_u8GetPortValue+0xa0>
		case DIO_PORTD:*Copy_u8Value=PIND;break;
    17c0:	e0 e3       	ldi	r30, 0x30	; 48
    17c2:	f0 e0       	ldi	r31, 0x00	; 0
    17c4:	80 81       	ld	r24, Z
    17c6:	eb 81       	ldd	r30, Y+3	; 0x03
    17c8:	fc 81       	ldd	r31, Y+4	; 0x04
    17ca:	80 83       	st	Z, r24
default:;

		}
	}
return Local_u8ErrorState;
    17cc:	99 81       	ldd	r25, Y+1	; 0x01
    17ce:	9f 83       	std	Y+7, r25	; 0x07
    17d0:	8f 81       	ldd	r24, Y+7	; 0x07

}
    17d2:	27 96       	adiw	r28, 0x07	; 7
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	f8 94       	cli
    17d8:	de bf       	out	0x3e, r29	; 62
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	cd bf       	out	0x3d, r28	; 61
    17de:	cf 91       	pop	r28
    17e0:	df 91       	pop	r29
    17e2:	08 95       	ret

000017e4 <DIO_u8GetPinValue>:
u8 DIO_u8GetPinValue(u8 Copy_u8Port,u8 Copy_u8Pin,u8 *Copy_u8Value)
{
    17e4:	df 93       	push	r29
    17e6:	cf 93       	push	r28
    17e8:	cd b7       	in	r28, 0x3d	; 61
    17ea:	de b7       	in	r29, 0x3e	; 62
    17ec:	28 97       	sbiw	r28, 0x08	; 8
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	f8 94       	cli
    17f2:	de bf       	out	0x3e, r29	; 62
    17f4:	0f be       	out	0x3f, r0	; 63
    17f6:	cd bf       	out	0x3d, r28	; 61
    17f8:	8a 83       	std	Y+2, r24	; 0x02
    17fa:	6b 83       	std	Y+3, r22	; 0x03
    17fc:	5d 83       	std	Y+5, r21	; 0x05
    17fe:	4c 83       	std	Y+4, r20	; 0x04
	u8 Local_u8ErrorState=0;
    1800:	19 82       	std	Y+1, r1	; 0x01

		 if((Copy_u8Port>DIO_PORTD)||(Copy_u8Port<DIO_PORTA))
    1802:	8a 81       	ldd	r24, Y+2	; 0x02
    1804:	84 30       	cpi	r24, 0x04	; 4
    1806:	28 f0       	brcs	.+10     	; 0x1812 <DIO_u8GetPinValue+0x2e>
		    {
		 	   Local_u8ErrorState=1;
    1808:	81 e0       	ldi	r24, 0x01	; 1
    180a:	89 83       	std	Y+1, r24	; 0x01
		 	  return Local_u8ErrorState;
    180c:	29 81       	ldd	r18, Y+1	; 0x01
    180e:	28 87       	std	Y+8, r18	; 0x08
    1810:	7a c0       	rjmp	.+244    	; 0x1906 <DIO_u8GetPinValue+0x122>
		    }
		 else if ((Copy_u8Pin>DIO_PIN7)||(Copy_u8Pin<DIO_PIN0))
    1812:	8b 81       	ldd	r24, Y+3	; 0x03
    1814:	88 30       	cpi	r24, 0x08	; 8
    1816:	28 f0       	brcs	.+10     	; 0x1822 <DIO_u8GetPinValue+0x3e>
		 {
			   Local_u8ErrorState=1;
    1818:	81 e0       	ldi	r24, 0x01	; 1
    181a:	89 83       	std	Y+1, r24	; 0x01
		       return Local_u8ErrorState;
    181c:	39 81       	ldd	r19, Y+1	; 0x01
    181e:	38 87       	std	Y+8, r19	; 0x08
    1820:	72 c0       	rjmp	.+228    	; 0x1906 <DIO_u8GetPinValue+0x122>
		 }
		 else
		 {
			switch(Copy_u8Port)
    1822:	8a 81       	ldd	r24, Y+2	; 0x02
    1824:	48 2f       	mov	r20, r24
    1826:	50 e0       	ldi	r21, 0x00	; 0
    1828:	5f 83       	std	Y+7, r21	; 0x07
    182a:	4e 83       	std	Y+6, r20	; 0x06
    182c:	8e 81       	ldd	r24, Y+6	; 0x06
    182e:	9f 81       	ldd	r25, Y+7	; 0x07
    1830:	81 30       	cpi	r24, 0x01	; 1
    1832:	91 05       	cpc	r25, r1
    1834:	59 f1       	breq	.+86     	; 0x188c <DIO_u8GetPinValue+0xa8>
    1836:	2e 81       	ldd	r18, Y+6	; 0x06
    1838:	3f 81       	ldd	r19, Y+7	; 0x07
    183a:	22 30       	cpi	r18, 0x02	; 2
    183c:	31 05       	cpc	r19, r1
    183e:	34 f4       	brge	.+12     	; 0x184c <DIO_u8GetPinValue+0x68>
    1840:	4e 81       	ldd	r20, Y+6	; 0x06
    1842:	5f 81       	ldd	r21, Y+7	; 0x07
    1844:	41 15       	cp	r20, r1
    1846:	51 05       	cpc	r21, r1
    1848:	69 f0       	breq	.+26     	; 0x1864 <DIO_u8GetPinValue+0x80>
    184a:	5b c0       	rjmp	.+182    	; 0x1902 <DIO_u8GetPinValue+0x11e>
    184c:	8e 81       	ldd	r24, Y+6	; 0x06
    184e:	9f 81       	ldd	r25, Y+7	; 0x07
    1850:	82 30       	cpi	r24, 0x02	; 2
    1852:	91 05       	cpc	r25, r1
    1854:	79 f1       	breq	.+94     	; 0x18b4 <DIO_u8GetPinValue+0xd0>
    1856:	2e 81       	ldd	r18, Y+6	; 0x06
    1858:	3f 81       	ldd	r19, Y+7	; 0x07
    185a:	23 30       	cpi	r18, 0x03	; 3
    185c:	31 05       	cpc	r19, r1
    185e:	09 f4       	brne	.+2      	; 0x1862 <DIO_u8GetPinValue+0x7e>
    1860:	3d c0       	rjmp	.+122    	; 0x18dc <DIO_u8GetPinValue+0xf8>
    1862:	4f c0       	rjmp	.+158    	; 0x1902 <DIO_u8GetPinValue+0x11e>
			{
			case DIO_PORTA:*Copy_u8Value=GET_BIT(PINA,Copy_u8Pin);break;
    1864:	e9 e3       	ldi	r30, 0x39	; 57
    1866:	f0 e0       	ldi	r31, 0x00	; 0
    1868:	80 81       	ld	r24, Z
    186a:	28 2f       	mov	r18, r24
    186c:	30 e0       	ldi	r19, 0x00	; 0
    186e:	8b 81       	ldd	r24, Y+3	; 0x03
    1870:	88 2f       	mov	r24, r24
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	a9 01       	movw	r20, r18
    1876:	02 c0       	rjmp	.+4      	; 0x187c <DIO_u8GetPinValue+0x98>
    1878:	55 95       	asr	r21
    187a:	47 95       	ror	r20
    187c:	8a 95       	dec	r24
    187e:	e2 f7       	brpl	.-8      	; 0x1878 <DIO_u8GetPinValue+0x94>
    1880:	ca 01       	movw	r24, r20
    1882:	81 70       	andi	r24, 0x01	; 1
    1884:	ec 81       	ldd	r30, Y+4	; 0x04
    1886:	fd 81       	ldd	r31, Y+5	; 0x05
    1888:	80 83       	st	Z, r24
    188a:	3b c0       	rjmp	.+118    	; 0x1902 <DIO_u8GetPinValue+0x11e>
			case DIO_PORTB:*Copy_u8Value=GET_BIT(PINB,Copy_u8Pin);break;
    188c:	e6 e3       	ldi	r30, 0x36	; 54
    188e:	f0 e0       	ldi	r31, 0x00	; 0
    1890:	80 81       	ld	r24, Z
    1892:	28 2f       	mov	r18, r24
    1894:	30 e0       	ldi	r19, 0x00	; 0
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	88 2f       	mov	r24, r24
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	a9 01       	movw	r20, r18
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <DIO_u8GetPinValue+0xc0>
    18a0:	55 95       	asr	r21
    18a2:	47 95       	ror	r20
    18a4:	8a 95       	dec	r24
    18a6:	e2 f7       	brpl	.-8      	; 0x18a0 <DIO_u8GetPinValue+0xbc>
    18a8:	ca 01       	movw	r24, r20
    18aa:	81 70       	andi	r24, 0x01	; 1
    18ac:	ec 81       	ldd	r30, Y+4	; 0x04
    18ae:	fd 81       	ldd	r31, Y+5	; 0x05
    18b0:	80 83       	st	Z, r24
    18b2:	27 c0       	rjmp	.+78     	; 0x1902 <DIO_u8GetPinValue+0x11e>
			case DIO_PORTC:*Copy_u8Value=GET_BIT(PINC,Copy_u8Pin);break;
    18b4:	e3 e3       	ldi	r30, 0x33	; 51
    18b6:	f0 e0       	ldi	r31, 0x00	; 0
    18b8:	80 81       	ld	r24, Z
    18ba:	28 2f       	mov	r18, r24
    18bc:	30 e0       	ldi	r19, 0x00	; 0
    18be:	8b 81       	ldd	r24, Y+3	; 0x03
    18c0:	88 2f       	mov	r24, r24
    18c2:	90 e0       	ldi	r25, 0x00	; 0
    18c4:	a9 01       	movw	r20, r18
    18c6:	02 c0       	rjmp	.+4      	; 0x18cc <DIO_u8GetPinValue+0xe8>
    18c8:	55 95       	asr	r21
    18ca:	47 95       	ror	r20
    18cc:	8a 95       	dec	r24
    18ce:	e2 f7       	brpl	.-8      	; 0x18c8 <DIO_u8GetPinValue+0xe4>
    18d0:	ca 01       	movw	r24, r20
    18d2:	81 70       	andi	r24, 0x01	; 1
    18d4:	ec 81       	ldd	r30, Y+4	; 0x04
    18d6:	fd 81       	ldd	r31, Y+5	; 0x05
    18d8:	80 83       	st	Z, r24
    18da:	13 c0       	rjmp	.+38     	; 0x1902 <DIO_u8GetPinValue+0x11e>
			case DIO_PORTD:*Copy_u8Value=GET_BIT(PIND,Copy_u8Pin);break;
    18dc:	e0 e3       	ldi	r30, 0x30	; 48
    18de:	f0 e0       	ldi	r31, 0x00	; 0
    18e0:	80 81       	ld	r24, Z
    18e2:	28 2f       	mov	r18, r24
    18e4:	30 e0       	ldi	r19, 0x00	; 0
    18e6:	8b 81       	ldd	r24, Y+3	; 0x03
    18e8:	88 2f       	mov	r24, r24
    18ea:	90 e0       	ldi	r25, 0x00	; 0
    18ec:	a9 01       	movw	r20, r18
    18ee:	02 c0       	rjmp	.+4      	; 0x18f4 <DIO_u8GetPinValue+0x110>
    18f0:	55 95       	asr	r21
    18f2:	47 95       	ror	r20
    18f4:	8a 95       	dec	r24
    18f6:	e2 f7       	brpl	.-8      	; 0x18f0 <DIO_u8GetPinValue+0x10c>
    18f8:	ca 01       	movw	r24, r20
    18fa:	81 70       	andi	r24, 0x01	; 1
    18fc:	ec 81       	ldd	r30, Y+4	; 0x04
    18fe:	fd 81       	ldd	r31, Y+5	; 0x05
    1900:	80 83       	st	Z, r24
			}
		 }
return Local_u8ErrorState;
    1902:	59 81       	ldd	r21, Y+1	; 0x01
    1904:	58 87       	std	Y+8, r21	; 0x08
    1906:	88 85       	ldd	r24, Y+8	; 0x08
}
    1908:	28 96       	adiw	r28, 0x08	; 8
    190a:	0f b6       	in	r0, 0x3f	; 63
    190c:	f8 94       	cli
    190e:	de bf       	out	0x3e, r29	; 62
    1910:	0f be       	out	0x3f, r0	; 63
    1912:	cd bf       	out	0x3d, r28	; 61
    1914:	cf 91       	pop	r28
    1916:	df 91       	pop	r29
    1918:	08 95       	ret

0000191a <EEBROM_Send>:
#include "BIT_MATH.h"
#include "i2c.h"
#include "EEPROM.h"
#include <avr/io.h>
void EEBROM_Send(u16 address,u8 data)
{
    191a:	df 93       	push	r29
    191c:	cf 93       	push	r28
    191e:	00 d0       	rcall	.+0      	; 0x1920 <EEBROM_Send+0x6>
    1920:	00 d0       	rcall	.+0      	; 0x1922 <EEBROM_Send+0x8>
    1922:	cd b7       	in	r28, 0x3d	; 61
    1924:	de b7       	in	r29, 0x3e	; 62
    1926:	9b 83       	std	Y+3, r25	; 0x03
    1928:	8a 83       	std	Y+2, r24	; 0x02
    192a:	6c 83       	std	Y+4, r22	; 0x04
	u8 SLV_W=0b10100000;
    192c:	80 ea       	ldi	r24, 0xA0	; 160
    192e:	89 83       	std	Y+1, r24	; 0x01
	TWI_Start();
    1930:	0e 94 5d 16 	call	0x2cba	; 0x2cba <TWI_Start>
	TWI_Send(SLV_W);
    1934:	89 81       	ldd	r24, Y+1	; 0x01
    1936:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	TWI_Send((u8)address);
    193a:	8a 81       	ldd	r24, Y+2	; 0x02
    193c:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	TWI_Send(data);
    1940:	8c 81       	ldd	r24, Y+4	; 0x04
    1942:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	TWI_Stop();
    1946:	0e 94 6d 16 	call	0x2cda	; 0x2cda <TWI_Stop>

}
    194a:	0f 90       	pop	r0
    194c:	0f 90       	pop	r0
    194e:	0f 90       	pop	r0
    1950:	0f 90       	pop	r0
    1952:	cf 91       	pop	r28
    1954:	df 91       	pop	r29
    1956:	08 95       	ret

00001958 <EEPROM_Receive>:
u8 EEPROM_Receive(u16 address)
{
    1958:	df 93       	push	r29
    195a:	cf 93       	push	r28
    195c:	00 d0       	rcall	.+0      	; 0x195e <EEPROM_Receive+0x6>
    195e:	00 d0       	rcall	.+0      	; 0x1960 <EEPROM_Receive+0x8>
    1960:	0f 92       	push	r0
    1962:	cd b7       	in	r28, 0x3d	; 61
    1964:	de b7       	in	r29, 0x3e	; 62
    1966:	9d 83       	std	Y+5, r25	; 0x05
    1968:	8c 83       	std	Y+4, r24	; 0x04
	u8 SLV_W=0b10100000;
    196a:	80 ea       	ldi	r24, 0xA0	; 160
    196c:	8b 83       	std	Y+3, r24	; 0x03
	u8 SLV_R=SLV_W+1;
    196e:	8b 81       	ldd	r24, Y+3	; 0x03
    1970:	8f 5f       	subi	r24, 0xFF	; 255
    1972:	8a 83       	std	Y+2, r24	; 0x02
	TWI_Start();
    1974:	0e 94 5d 16 	call	0x2cba	; 0x2cba <TWI_Start>
	TWI_Send(SLV_W);
    1978:	8b 81       	ldd	r24, Y+3	; 0x03
    197a:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	TWI_Send((u8)address);
    197e:	8c 81       	ldd	r24, Y+4	; 0x04
    1980:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	TWI_Start();
    1984:	0e 94 5d 16 	call	0x2cba	; 0x2cba <TWI_Start>
	TWI_Send(SLV_R);
    1988:	8a 81       	ldd	r24, Y+2	; 0x02
    198a:	0e 94 78 16 	call	0x2cf0	; 0x2cf0 <TWI_Send>
	u8 data=TWI_Receive();
    198e:	0e 94 8f 16 	call	0x2d1e	; 0x2d1e <TWI_Receive>
    1992:	89 83       	std	Y+1, r24	; 0x01
	TWI_Stop();
    1994:	0e 94 6d 16 	call	0x2cda	; 0x2cda <TWI_Stop>
	return data;
    1998:	89 81       	ldd	r24, Y+1	; 0x01
}
    199a:	0f 90       	pop	r0
    199c:	0f 90       	pop	r0
    199e:	0f 90       	pop	r0
    19a0:	0f 90       	pop	r0
    19a2:	0f 90       	pop	r0
    19a4:	cf 91       	pop	r28
    19a6:	df 91       	pop	r29
    19a8:	08 95       	ret

000019aa <EEPROM_voidSendData>:
#include "TWI_interface.h"
#include "EEPROM_interface.h"


void EEPROM_voidSendData(u16 Copy_u16Address,u8 Copy_u8Data)
{
    19aa:	df 93       	push	r29
    19ac:	cf 93       	push	r28
    19ae:	00 d0       	rcall	.+0      	; 0x19b0 <EEPROM_voidSendData+0x6>
    19b0:	00 d0       	rcall	.+0      	; 0x19b2 <EEPROM_voidSendData+0x8>
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62
    19b6:	9b 83       	std	Y+3, r25	; 0x03
    19b8:	8a 83       	std	Y+2, r24	; 0x02
    19ba:	6c 83       	std	Y+4, r22	; 0x04
	/*1010(A2)(B1)(B0)(W/R)*/
	u8 SLV_W=0b10100000;
    19bc:	80 ea       	ldi	r24, 0xA0	; 160
    19be:	89 83       	std	Y+1, r24	; 0x01

	TWI_voidStartCondition();
    19c0:	0e 94 b7 12 	call	0x256e	; 0x256e <TWI_voidStartCondition>

	/*BLOCK SELECTION WITH WRITE*/
	TWI_voidSendData(SLV_W);
    19c4:	89 81       	ldd	r24, Y+1	; 0x01
    19c6:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>

	/*BYTE SELECTION IN THE DESIRED BLOCK*/
	TWI_voidSendData((u8)Copy_u16Address);
    19ca:	8a 81       	ldd	r24, Y+2	; 0x02
    19cc:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>

	/*SENDING THE DATA*/
	TWI_voidSendData(Copy_u8Data);
    19d0:	8c 81       	ldd	r24, Y+4	; 0x04
    19d2:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>

	TWI_voidStopCondition();
    19d6:	0e 94 c7 12 	call	0x258e	; 0x258e <TWI_voidStopCondition>
}
    19da:	0f 90       	pop	r0
    19dc:	0f 90       	pop	r0
    19de:	0f 90       	pop	r0
    19e0:	0f 90       	pop	r0
    19e2:	cf 91       	pop	r28
    19e4:	df 91       	pop	r29
    19e6:	08 95       	ret

000019e8 <EEPROM_voidReceiveData>:

u8 EEPROM_voidReceiveData(u16 Copy_u16Address)
{
    19e8:	df 93       	push	r29
    19ea:	cf 93       	push	r28
    19ec:	00 d0       	rcall	.+0      	; 0x19ee <EEPROM_voidReceiveData+0x6>
    19ee:	00 d0       	rcall	.+0      	; 0x19f0 <EEPROM_voidReceiveData+0x8>
    19f0:	0f 92       	push	r0
    19f2:	cd b7       	in	r28, 0x3d	; 61
    19f4:	de b7       	in	r29, 0x3e	; 62
    19f6:	9d 83       	std	Y+5, r25	; 0x05
    19f8:	8c 83       	std	Y+4, r24	; 0x04
	u8 SLV_W=0b10100000;
    19fa:	80 ea       	ldi	r24, 0xA0	; 160
    19fc:	8b 83       	std	Y+3, r24	; 0x03
	u8 SLV_R=SLV_W+1;
    19fe:	8b 81       	ldd	r24, Y+3	; 0x03
    1a00:	8f 5f       	subi	r24, 0xFF	; 255
    1a02:	8a 83       	std	Y+2, r24	; 0x02

	TWI_voidStartCondition();
    1a04:	0e 94 b7 12 	call	0x256e	; 0x256e <TWI_voidStartCondition>
	TWI_voidSendData(SLV_W);
    1a08:	8b 81       	ldd	r24, Y+3	; 0x03
    1a0a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>
	TWI_voidSendData((u8)Copy_u16Address);
    1a0e:	8c 81       	ldd	r24, Y+4	; 0x04
    1a10:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>


	TWI_voidStartCondition();
    1a14:	0e 94 b7 12 	call	0x256e	; 0x256e <TWI_voidStartCondition>
	TWI_voidSendData(SLV_R);
    1a18:	8a 81       	ldd	r24, Y+2	; 0x02
    1a1a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <TWI_voidSendData>

	u8 Data=TWI_u8ReceiveData();
    1a1e:	0e 94 e9 12 	call	0x25d2	; 0x25d2 <TWI_u8ReceiveData>
    1a22:	89 83       	std	Y+1, r24	; 0x01

	TWI_voidStopCondition();
    1a24:	0e 94 c7 12 	call	0x258e	; 0x258e <TWI_voidStopCondition>
	return Data;
    1a28:	89 81       	ldd	r24, Y+1	; 0x01
}
    1a2a:	0f 90       	pop	r0
    1a2c:	0f 90       	pop	r0
    1a2e:	0f 90       	pop	r0
    1a30:	0f 90       	pop	r0
    1a32:	0f 90       	pop	r0
    1a34:	cf 91       	pop	r28
    1a36:	df 91       	pop	r29
    1a38:	08 95       	ret

00001a3a <EXTI_u8SenseControl>:
#include "DIO_INTERFACE.h"
#include <avr/interrupt.h>


u8 EXTI_u8SenseControl(u8 Copy_Int,u8 Copy_Sense)
{
    1a3a:	df 93       	push	r29
    1a3c:	cf 93       	push	r28
    1a3e:	cd b7       	in	r28, 0x3d	; 61
    1a40:	de b7       	in	r29, 0x3e	; 62
    1a42:	29 97       	sbiw	r28, 0x09	; 9
    1a44:	0f b6       	in	r0, 0x3f	; 63
    1a46:	f8 94       	cli
    1a48:	de bf       	out	0x3e, r29	; 62
    1a4a:	0f be       	out	0x3f, r0	; 63
    1a4c:	cd bf       	out	0x3d, r28	; 61
    1a4e:	8a 83       	std	Y+2, r24	; 0x02
    1a50:	6b 83       	std	Y+3, r22	; 0x03
	u8 LocalError=0;
    1a52:	19 82       	std	Y+1, r1	; 0x01

	if(Copy_Int==INT0)
    1a54:	8a 81       	ldd	r24, Y+2	; 0x02
    1a56:	86 30       	cpi	r24, 0x06	; 6
    1a58:	09 f0       	breq	.+2      	; 0x1a5c <EXTI_u8SenseControl+0x22>
    1a5a:	5f c0       	rjmp	.+190    	; 0x1b1a <EXTI_u8SenseControl+0xe0>
	{
		switch(Copy_Sense)
    1a5c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a5e:	28 2f       	mov	r18, r24
    1a60:	30 e0       	ldi	r19, 0x00	; 0
    1a62:	39 87       	std	Y+9, r19	; 0x09
    1a64:	28 87       	std	Y+8, r18	; 0x08
    1a66:	88 85       	ldd	r24, Y+8	; 0x08
    1a68:	99 85       	ldd	r25, Y+9	; 0x09
    1a6a:	82 30       	cpi	r24, 0x02	; 2
    1a6c:	91 05       	cpc	r25, r1
    1a6e:	29 f1       	breq	.+74     	; 0x1aba <EXTI_u8SenseControl+0x80>
    1a70:	28 85       	ldd	r18, Y+8	; 0x08
    1a72:	39 85       	ldd	r19, Y+9	; 0x09
    1a74:	23 30       	cpi	r18, 0x03	; 3
    1a76:	31 05       	cpc	r19, r1
    1a78:	34 f4       	brge	.+12     	; 0x1a86 <EXTI_u8SenseControl+0x4c>
    1a7a:	88 85       	ldd	r24, Y+8	; 0x08
    1a7c:	99 85       	ldd	r25, Y+9	; 0x09
    1a7e:	81 30       	cpi	r24, 0x01	; 1
    1a80:	91 05       	cpc	r25, r1
    1a82:	61 f0       	breq	.+24     	; 0x1a9c <EXTI_u8SenseControl+0x62>
    1a84:	47 c0       	rjmp	.+142    	; 0x1b14 <EXTI_u8SenseControl+0xda>
    1a86:	28 85       	ldd	r18, Y+8	; 0x08
    1a88:	39 85       	ldd	r19, Y+9	; 0x09
    1a8a:	23 30       	cpi	r18, 0x03	; 3
    1a8c:	31 05       	cpc	r19, r1
    1a8e:	21 f1       	breq	.+72     	; 0x1ad8 <EXTI_u8SenseControl+0x9e>
    1a90:	88 85       	ldd	r24, Y+8	; 0x08
    1a92:	99 85       	ldd	r25, Y+9	; 0x09
    1a94:	84 30       	cpi	r24, 0x04	; 4
    1a96:	91 05       	cpc	r25, r1
    1a98:	71 f1       	breq	.+92     	; 0x1af6 <EXTI_u8SenseControl+0xbc>
    1a9a:	3c c0       	rjmp	.+120    	; 0x1b14 <EXTI_u8SenseControl+0xda>
		{
		case LOW_LEVEL:CLR_BIT(MCUCR,0);CLR_BIT(MCUCR,0);break;
    1a9c:	a5 e5       	ldi	r26, 0x55	; 85
    1a9e:	b0 e0       	ldi	r27, 0x00	; 0
    1aa0:	e5 e5       	ldi	r30, 0x55	; 85
    1aa2:	f0 e0       	ldi	r31, 0x00	; 0
    1aa4:	80 81       	ld	r24, Z
    1aa6:	8e 7f       	andi	r24, 0xFE	; 254
    1aa8:	8c 93       	st	X, r24
    1aaa:	a5 e5       	ldi	r26, 0x55	; 85
    1aac:	b0 e0       	ldi	r27, 0x00	; 0
    1aae:	e5 e5       	ldi	r30, 0x55	; 85
    1ab0:	f0 e0       	ldi	r31, 0x00	; 0
    1ab2:	80 81       	ld	r24, Z
    1ab4:	8e 7f       	andi	r24, 0xFE	; 254
    1ab6:	8c 93       	st	X, r24
    1ab8:	bb c0       	rjmp	.+374    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case ANY_CHANGE:SET_BIT(MCUCR,0);CLR_BIT(MCUCR,1);break;
    1aba:	a5 e5       	ldi	r26, 0x55	; 85
    1abc:	b0 e0       	ldi	r27, 0x00	; 0
    1abe:	e5 e5       	ldi	r30, 0x55	; 85
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	80 81       	ld	r24, Z
    1ac4:	81 60       	ori	r24, 0x01	; 1
    1ac6:	8c 93       	st	X, r24
    1ac8:	a5 e5       	ldi	r26, 0x55	; 85
    1aca:	b0 e0       	ldi	r27, 0x00	; 0
    1acc:	e5 e5       	ldi	r30, 0x55	; 85
    1ace:	f0 e0       	ldi	r31, 0x00	; 0
    1ad0:	80 81       	ld	r24, Z
    1ad2:	8d 7f       	andi	r24, 0xFD	; 253
    1ad4:	8c 93       	st	X, r24
    1ad6:	ac c0       	rjmp	.+344    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case FALLING_EDGE:CLR_BIT(MCUCR,0);SET_BIT(MCUCR,1);break;
    1ad8:	a5 e5       	ldi	r26, 0x55	; 85
    1ada:	b0 e0       	ldi	r27, 0x00	; 0
    1adc:	e5 e5       	ldi	r30, 0x55	; 85
    1ade:	f0 e0       	ldi	r31, 0x00	; 0
    1ae0:	80 81       	ld	r24, Z
    1ae2:	8e 7f       	andi	r24, 0xFE	; 254
    1ae4:	8c 93       	st	X, r24
    1ae6:	a5 e5       	ldi	r26, 0x55	; 85
    1ae8:	b0 e0       	ldi	r27, 0x00	; 0
    1aea:	e5 e5       	ldi	r30, 0x55	; 85
    1aec:	f0 e0       	ldi	r31, 0x00	; 0
    1aee:	80 81       	ld	r24, Z
    1af0:	82 60       	ori	r24, 0x02	; 2
    1af2:	8c 93       	st	X, r24
    1af4:	9d c0       	rjmp	.+314    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case RISING_EDGE:SET_BIT(MCUCR,0);SET_BIT(MCUCR,1);break;
    1af6:	a5 e5       	ldi	r26, 0x55	; 85
    1af8:	b0 e0       	ldi	r27, 0x00	; 0
    1afa:	e5 e5       	ldi	r30, 0x55	; 85
    1afc:	f0 e0       	ldi	r31, 0x00	; 0
    1afe:	80 81       	ld	r24, Z
    1b00:	81 60       	ori	r24, 0x01	; 1
    1b02:	8c 93       	st	X, r24
    1b04:	a5 e5       	ldi	r26, 0x55	; 85
    1b06:	b0 e0       	ldi	r27, 0x00	; 0
    1b08:	e5 e5       	ldi	r30, 0x55	; 85
    1b0a:	f0 e0       	ldi	r31, 0x00	; 0
    1b0c:	80 81       	ld	r24, Z
    1b0e:	82 60       	ori	r24, 0x02	; 2
    1b10:	8c 93       	st	X, r24
    1b12:	8e c0       	rjmp	.+284    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		default : LocalError=1;
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	89 83       	std	Y+1, r24	; 0x01
    1b18:	8b c0       	rjmp	.+278    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		}
	}
	else if(Copy_Int==INT1)
    1b1a:	8a 81       	ldd	r24, Y+2	; 0x02
    1b1c:	87 30       	cpi	r24, 0x07	; 7
    1b1e:	09 f0       	breq	.+2      	; 0x1b22 <EXTI_u8SenseControl+0xe8>
    1b20:	5f c0       	rjmp	.+190    	; 0x1be0 <EXTI_u8SenseControl+0x1a6>
	{
		switch(Copy_Sense)
    1b22:	8b 81       	ldd	r24, Y+3	; 0x03
    1b24:	28 2f       	mov	r18, r24
    1b26:	30 e0       	ldi	r19, 0x00	; 0
    1b28:	3f 83       	std	Y+7, r19	; 0x07
    1b2a:	2e 83       	std	Y+6, r18	; 0x06
    1b2c:	8e 81       	ldd	r24, Y+6	; 0x06
    1b2e:	9f 81       	ldd	r25, Y+7	; 0x07
    1b30:	82 30       	cpi	r24, 0x02	; 2
    1b32:	91 05       	cpc	r25, r1
    1b34:	29 f1       	breq	.+74     	; 0x1b80 <EXTI_u8SenseControl+0x146>
    1b36:	2e 81       	ldd	r18, Y+6	; 0x06
    1b38:	3f 81       	ldd	r19, Y+7	; 0x07
    1b3a:	23 30       	cpi	r18, 0x03	; 3
    1b3c:	31 05       	cpc	r19, r1
    1b3e:	34 f4       	brge	.+12     	; 0x1b4c <EXTI_u8SenseControl+0x112>
    1b40:	8e 81       	ldd	r24, Y+6	; 0x06
    1b42:	9f 81       	ldd	r25, Y+7	; 0x07
    1b44:	81 30       	cpi	r24, 0x01	; 1
    1b46:	91 05       	cpc	r25, r1
    1b48:	61 f0       	breq	.+24     	; 0x1b62 <EXTI_u8SenseControl+0x128>
    1b4a:	47 c0       	rjmp	.+142    	; 0x1bda <EXTI_u8SenseControl+0x1a0>
    1b4c:	2e 81       	ldd	r18, Y+6	; 0x06
    1b4e:	3f 81       	ldd	r19, Y+7	; 0x07
    1b50:	23 30       	cpi	r18, 0x03	; 3
    1b52:	31 05       	cpc	r19, r1
    1b54:	21 f1       	breq	.+72     	; 0x1b9e <EXTI_u8SenseControl+0x164>
    1b56:	8e 81       	ldd	r24, Y+6	; 0x06
    1b58:	9f 81       	ldd	r25, Y+7	; 0x07
    1b5a:	84 30       	cpi	r24, 0x04	; 4
    1b5c:	91 05       	cpc	r25, r1
    1b5e:	71 f1       	breq	.+92     	; 0x1bbc <EXTI_u8SenseControl+0x182>
    1b60:	3c c0       	rjmp	.+120    	; 0x1bda <EXTI_u8SenseControl+0x1a0>
		{
		case LOW_LEVEL:CLR_BIT(MCUCR,3);CLR_BIT(MCUCR,2);break;
    1b62:	a5 e5       	ldi	r26, 0x55	; 85
    1b64:	b0 e0       	ldi	r27, 0x00	; 0
    1b66:	e5 e5       	ldi	r30, 0x55	; 85
    1b68:	f0 e0       	ldi	r31, 0x00	; 0
    1b6a:	80 81       	ld	r24, Z
    1b6c:	87 7f       	andi	r24, 0xF7	; 247
    1b6e:	8c 93       	st	X, r24
    1b70:	a5 e5       	ldi	r26, 0x55	; 85
    1b72:	b0 e0       	ldi	r27, 0x00	; 0
    1b74:	e5 e5       	ldi	r30, 0x55	; 85
    1b76:	f0 e0       	ldi	r31, 0x00	; 0
    1b78:	80 81       	ld	r24, Z
    1b7a:	8b 7f       	andi	r24, 0xFB	; 251
    1b7c:	8c 93       	st	X, r24
    1b7e:	58 c0       	rjmp	.+176    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case ANY_CHANGE:SET_BIT(MCUCR,2);CLR_BIT(MCUCR,3);break;
    1b80:	a5 e5       	ldi	r26, 0x55	; 85
    1b82:	b0 e0       	ldi	r27, 0x00	; 0
    1b84:	e5 e5       	ldi	r30, 0x55	; 85
    1b86:	f0 e0       	ldi	r31, 0x00	; 0
    1b88:	80 81       	ld	r24, Z
    1b8a:	84 60       	ori	r24, 0x04	; 4
    1b8c:	8c 93       	st	X, r24
    1b8e:	a5 e5       	ldi	r26, 0x55	; 85
    1b90:	b0 e0       	ldi	r27, 0x00	; 0
    1b92:	e5 e5       	ldi	r30, 0x55	; 85
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	80 81       	ld	r24, Z
    1b98:	87 7f       	andi	r24, 0xF7	; 247
    1b9a:	8c 93       	st	X, r24
    1b9c:	49 c0       	rjmp	.+146    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case FALLING_EDGE:CLR_BIT(MCUCR,2);SET_BIT(MCUCR,3);break;
    1b9e:	a5 e5       	ldi	r26, 0x55	; 85
    1ba0:	b0 e0       	ldi	r27, 0x00	; 0
    1ba2:	e5 e5       	ldi	r30, 0x55	; 85
    1ba4:	f0 e0       	ldi	r31, 0x00	; 0
    1ba6:	80 81       	ld	r24, Z
    1ba8:	8b 7f       	andi	r24, 0xFB	; 251
    1baa:	8c 93       	st	X, r24
    1bac:	a5 e5       	ldi	r26, 0x55	; 85
    1bae:	b0 e0       	ldi	r27, 0x00	; 0
    1bb0:	e5 e5       	ldi	r30, 0x55	; 85
    1bb2:	f0 e0       	ldi	r31, 0x00	; 0
    1bb4:	80 81       	ld	r24, Z
    1bb6:	88 60       	ori	r24, 0x08	; 8
    1bb8:	8c 93       	st	X, r24
    1bba:	3a c0       	rjmp	.+116    	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		case RISING_EDGE:SET_BIT(MCUCR,3);SET_BIT(MCUCR,2);break;
    1bbc:	a5 e5       	ldi	r26, 0x55	; 85
    1bbe:	b0 e0       	ldi	r27, 0x00	; 0
    1bc0:	e5 e5       	ldi	r30, 0x55	; 85
    1bc2:	f0 e0       	ldi	r31, 0x00	; 0
    1bc4:	80 81       	ld	r24, Z
    1bc6:	88 60       	ori	r24, 0x08	; 8
    1bc8:	8c 93       	st	X, r24
    1bca:	a5 e5       	ldi	r26, 0x55	; 85
    1bcc:	b0 e0       	ldi	r27, 0x00	; 0
    1bce:	e5 e5       	ldi	r30, 0x55	; 85
    1bd0:	f0 e0       	ldi	r31, 0x00	; 0
    1bd2:	80 81       	ld	r24, Z
    1bd4:	84 60       	ori	r24, 0x04	; 4
    1bd6:	8c 93       	st	X, r24
    1bd8:	2b c0       	rjmp	.+86     	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		default : LocalError=1;
    1bda:	81 e0       	ldi	r24, 0x01	; 1
    1bdc:	89 83       	std	Y+1, r24	; 0x01
    1bde:	28 c0       	rjmp	.+80     	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
		}
	}
	else if(Copy_Int==INT2)
    1be0:	8a 81       	ldd	r24, Y+2	; 0x02
    1be2:	85 30       	cpi	r24, 0x05	; 5
    1be4:	19 f5       	brne	.+70     	; 0x1c2c <EXTI_u8SenseControl+0x1f2>
	{
		switch(Copy_Sense)
    1be6:	8b 81       	ldd	r24, Y+3	; 0x03
    1be8:	28 2f       	mov	r18, r24
    1bea:	30 e0       	ldi	r19, 0x00	; 0
    1bec:	3d 83       	std	Y+5, r19	; 0x05
    1bee:	2c 83       	std	Y+4, r18	; 0x04
    1bf0:	8c 81       	ldd	r24, Y+4	; 0x04
    1bf2:	9d 81       	ldd	r25, Y+5	; 0x05
    1bf4:	83 30       	cpi	r24, 0x03	; 3
    1bf6:	91 05       	cpc	r25, r1
    1bf8:	31 f0       	breq	.+12     	; 0x1c06 <EXTI_u8SenseControl+0x1cc>
    1bfa:	2c 81       	ldd	r18, Y+4	; 0x04
    1bfc:	3d 81       	ldd	r19, Y+5	; 0x05
    1bfe:	24 30       	cpi	r18, 0x04	; 4
    1c00:	31 05       	cpc	r19, r1
    1c02:	49 f0       	breq	.+18     	; 0x1c16 <EXTI_u8SenseControl+0x1dc>
    1c04:	10 c0       	rjmp	.+32     	; 0x1c26 <EXTI_u8SenseControl+0x1ec>
				{
				case FALLING_EDGE:CLR_BIT(MCUCSR,6);break;
    1c06:	a4 e5       	ldi	r26, 0x54	; 84
    1c08:	b0 e0       	ldi	r27, 0x00	; 0
    1c0a:	e4 e5       	ldi	r30, 0x54	; 84
    1c0c:	f0 e0       	ldi	r31, 0x00	; 0
    1c0e:	80 81       	ld	r24, Z
    1c10:	8f 7b       	andi	r24, 0xBF	; 191
    1c12:	8c 93       	st	X, r24
    1c14:	0d c0       	rjmp	.+26     	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
				case RISING_EDGE:SET_BIT(MCUCSR,6);break;
    1c16:	a4 e5       	ldi	r26, 0x54	; 84
    1c18:	b0 e0       	ldi	r27, 0x00	; 0
    1c1a:	e4 e5       	ldi	r30, 0x54	; 84
    1c1c:	f0 e0       	ldi	r31, 0x00	; 0
    1c1e:	80 81       	ld	r24, Z
    1c20:	80 64       	ori	r24, 0x40	; 64
    1c22:	8c 93       	st	X, r24
    1c24:	05 c0       	rjmp	.+10     	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
				default : LocalError=1;
    1c26:	81 e0       	ldi	r24, 0x01	; 1
    1c28:	89 83       	std	Y+1, r24	; 0x01
    1c2a:	02 c0       	rjmp	.+4      	; 0x1c30 <EXTI_u8SenseControl+0x1f6>
				}
	}
	else
	{
		//do nothing
		LocalError=1;
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	89 83       	std	Y+1, r24	; 0x01
 }
 return LocalError;
    1c30:	89 81       	ldd	r24, Y+1	; 0x01

}
    1c32:	29 96       	adiw	r28, 0x09	; 9
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	de bf       	out	0x3e, r29	; 62
    1c3a:	0f be       	out	0x3f, r0	; 63
    1c3c:	cd bf       	out	0x3d, r28	; 61
    1c3e:	cf 91       	pop	r28
    1c40:	df 91       	pop	r29
    1c42:	08 95       	ret

00001c44 <EXTI_u8IntEnable>:
u8 EXTI_u8IntEnable(u8 Copy_Int)
{
    1c44:	df 93       	push	r29
    1c46:	cf 93       	push	r28
    1c48:	00 d0       	rcall	.+0      	; 0x1c4a <EXTI_u8IntEnable+0x6>
    1c4a:	00 d0       	rcall	.+0      	; 0x1c4c <EXTI_u8IntEnable+0x8>
    1c4c:	cd b7       	in	r28, 0x3d	; 61
    1c4e:	de b7       	in	r29, 0x3e	; 62
    1c50:	8a 83       	std	Y+2, r24	; 0x02
	u8 LocalError=0;
    1c52:	19 82       	std	Y+1, r1	; 0x01

		 switch(Copy_Int)
    1c54:	8a 81       	ldd	r24, Y+2	; 0x02
    1c56:	28 2f       	mov	r18, r24
    1c58:	30 e0       	ldi	r19, 0x00	; 0
    1c5a:	3c 83       	std	Y+4, r19	; 0x04
    1c5c:	2b 83       	std	Y+3, r18	; 0x03
    1c5e:	8b 81       	ldd	r24, Y+3	; 0x03
    1c60:	9c 81       	ldd	r25, Y+4	; 0x04
    1c62:	86 30       	cpi	r24, 0x06	; 6
    1c64:	91 05       	cpc	r25, r1
    1c66:	59 f0       	breq	.+22     	; 0x1c7e <EXTI_u8IntEnable+0x3a>
    1c68:	2b 81       	ldd	r18, Y+3	; 0x03
    1c6a:	3c 81       	ldd	r19, Y+4	; 0x04
    1c6c:	27 30       	cpi	r18, 0x07	; 7
    1c6e:	31 05       	cpc	r19, r1
    1c70:	71 f0       	breq	.+28     	; 0x1c8e <EXTI_u8IntEnable+0x4a>
    1c72:	8b 81       	ldd	r24, Y+3	; 0x03
    1c74:	9c 81       	ldd	r25, Y+4	; 0x04
    1c76:	85 30       	cpi	r24, 0x05	; 5
    1c78:	91 05       	cpc	r25, r1
    1c7a:	89 f0       	breq	.+34     	; 0x1c9e <EXTI_u8IntEnable+0x5a>
    1c7c:	18 c0       	rjmp	.+48     	; 0x1cae <EXTI_u8IntEnable+0x6a>
		 {
		 case INT0:SET_BIT(GICR,6);break;
    1c7e:	ab e5       	ldi	r26, 0x5B	; 91
    1c80:	b0 e0       	ldi	r27, 0x00	; 0
    1c82:	eb e5       	ldi	r30, 0x5B	; 91
    1c84:	f0 e0       	ldi	r31, 0x00	; 0
    1c86:	80 81       	ld	r24, Z
    1c88:	80 64       	ori	r24, 0x40	; 64
    1c8a:	8c 93       	st	X, r24
    1c8c:	12 c0       	rjmp	.+36     	; 0x1cb2 <EXTI_u8IntEnable+0x6e>
		 case INT1:SET_BIT(GICR,7);break;
    1c8e:	ab e5       	ldi	r26, 0x5B	; 91
    1c90:	b0 e0       	ldi	r27, 0x00	; 0
    1c92:	eb e5       	ldi	r30, 0x5B	; 91
    1c94:	f0 e0       	ldi	r31, 0x00	; 0
    1c96:	80 81       	ld	r24, Z
    1c98:	80 68       	ori	r24, 0x80	; 128
    1c9a:	8c 93       	st	X, r24
    1c9c:	0a c0       	rjmp	.+20     	; 0x1cb2 <EXTI_u8IntEnable+0x6e>
		 case INT2:SET_BIT(GICR,5);break;
    1c9e:	ab e5       	ldi	r26, 0x5B	; 91
    1ca0:	b0 e0       	ldi	r27, 0x00	; 0
    1ca2:	eb e5       	ldi	r30, 0x5B	; 91
    1ca4:	f0 e0       	ldi	r31, 0x00	; 0
    1ca6:	80 81       	ld	r24, Z
    1ca8:	80 62       	ori	r24, 0x20	; 32
    1caa:	8c 93       	st	X, r24
    1cac:	02 c0       	rjmp	.+4      	; 0x1cb2 <EXTI_u8IntEnable+0x6e>
		 default:LocalError=1;
    1cae:	81 e0       	ldi	r24, 0x01	; 1
    1cb0:	89 83       	std	Y+1, r24	; 0x01
		 }


return LocalError;
    1cb2:	89 81       	ldd	r24, Y+1	; 0x01
}
    1cb4:	0f 90       	pop	r0
    1cb6:	0f 90       	pop	r0
    1cb8:	0f 90       	pop	r0
    1cba:	0f 90       	pop	r0
    1cbc:	cf 91       	pop	r28
    1cbe:	df 91       	pop	r29
    1cc0:	08 95       	ret

00001cc2 <EXTI_u8IntDisable>:
u8 EXTI_u8IntDisable(u8 Copy_Int)
{
    1cc2:	df 93       	push	r29
    1cc4:	cf 93       	push	r28
    1cc6:	00 d0       	rcall	.+0      	; 0x1cc8 <EXTI_u8IntDisable+0x6>
    1cc8:	00 d0       	rcall	.+0      	; 0x1cca <EXTI_u8IntDisable+0x8>
    1cca:	cd b7       	in	r28, 0x3d	; 61
    1ccc:	de b7       	in	r29, 0x3e	; 62
    1cce:	8a 83       	std	Y+2, r24	; 0x02
u8 LocalError=0;
    1cd0:	19 82       	std	Y+1, r1	; 0x01
	 {
		 switch(Copy_Int)
    1cd2:	8a 81       	ldd	r24, Y+2	; 0x02
    1cd4:	28 2f       	mov	r18, r24
    1cd6:	30 e0       	ldi	r19, 0x00	; 0
    1cd8:	3c 83       	std	Y+4, r19	; 0x04
    1cda:	2b 83       	std	Y+3, r18	; 0x03
    1cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    1cde:	9c 81       	ldd	r25, Y+4	; 0x04
    1ce0:	86 30       	cpi	r24, 0x06	; 6
    1ce2:	91 05       	cpc	r25, r1
    1ce4:	59 f0       	breq	.+22     	; 0x1cfc <EXTI_u8IntDisable+0x3a>
    1ce6:	2b 81       	ldd	r18, Y+3	; 0x03
    1ce8:	3c 81       	ldd	r19, Y+4	; 0x04
    1cea:	27 30       	cpi	r18, 0x07	; 7
    1cec:	31 05       	cpc	r19, r1
    1cee:	71 f0       	breq	.+28     	; 0x1d0c <EXTI_u8IntDisable+0x4a>
    1cf0:	8b 81       	ldd	r24, Y+3	; 0x03
    1cf2:	9c 81       	ldd	r25, Y+4	; 0x04
    1cf4:	85 30       	cpi	r24, 0x05	; 5
    1cf6:	91 05       	cpc	r25, r1
    1cf8:	89 f0       	breq	.+34     	; 0x1d1c <EXTI_u8IntDisable+0x5a>
    1cfa:	18 c0       	rjmp	.+48     	; 0x1d2c <EXTI_u8IntDisable+0x6a>
		 {
		 case INT0:CLR_BIT(GICR,6);break;
    1cfc:	ab e5       	ldi	r26, 0x5B	; 91
    1cfe:	b0 e0       	ldi	r27, 0x00	; 0
    1d00:	eb e5       	ldi	r30, 0x5B	; 91
    1d02:	f0 e0       	ldi	r31, 0x00	; 0
    1d04:	80 81       	ld	r24, Z
    1d06:	8f 7b       	andi	r24, 0xBF	; 191
    1d08:	8c 93       	st	X, r24
    1d0a:	12 c0       	rjmp	.+36     	; 0x1d30 <EXTI_u8IntDisable+0x6e>
		 case INT1:CLR_BIT(GICR,7);break;
    1d0c:	ab e5       	ldi	r26, 0x5B	; 91
    1d0e:	b0 e0       	ldi	r27, 0x00	; 0
    1d10:	eb e5       	ldi	r30, 0x5B	; 91
    1d12:	f0 e0       	ldi	r31, 0x00	; 0
    1d14:	80 81       	ld	r24, Z
    1d16:	8f 77       	andi	r24, 0x7F	; 127
    1d18:	8c 93       	st	X, r24
    1d1a:	0a c0       	rjmp	.+20     	; 0x1d30 <EXTI_u8IntDisable+0x6e>
		 case INT2:CLR_BIT(GICR,5);break;
    1d1c:	ab e5       	ldi	r26, 0x5B	; 91
    1d1e:	b0 e0       	ldi	r27, 0x00	; 0
    1d20:	eb e5       	ldi	r30, 0x5B	; 91
    1d22:	f0 e0       	ldi	r31, 0x00	; 0
    1d24:	80 81       	ld	r24, Z
    1d26:	8f 7d       	andi	r24, 0xDF	; 223
    1d28:	8c 93       	st	X, r24
    1d2a:	02 c0       	rjmp	.+4      	; 0x1d30 <EXTI_u8IntDisable+0x6e>
		 default: LocalError=1;
    1d2c:	81 e0       	ldi	r24, 0x01	; 1
    1d2e:	89 83       	std	Y+1, r24	; 0x01
		 }
	 }
return LocalError;
    1d30:	89 81       	ldd	r24, Y+1	; 0x01
}
    1d32:	0f 90       	pop	r0
    1d34:	0f 90       	pop	r0
    1d36:	0f 90       	pop	r0
    1d38:	0f 90       	pop	r0
    1d3a:	cf 91       	pop	r28
    1d3c:	df 91       	pop	r29
    1d3e:	08 95       	ret

00001d40 <GIE_voidEnable>:
#include "BIT_MATH.h"
#include <avr/interrupt.h>
#include "GIE_REGISTER.h"
#include "GIE_interface.h"
void GIE_voidEnable(void)
{
    1d40:	df 93       	push	r29
    1d42:	cf 93       	push	r28
    1d44:	cd b7       	in	r28, 0x3d	; 61
    1d46:	de b7       	in	r29, 0x3e	; 62
SET_BIT(SREG,SREG_I);
    1d48:	af e5       	ldi	r26, 0x5F	; 95
    1d4a:	b0 e0       	ldi	r27, 0x00	; 0
    1d4c:	ef e5       	ldi	r30, 0x5F	; 95
    1d4e:	f0 e0       	ldi	r31, 0x00	; 0
    1d50:	80 81       	ld	r24, Z
    1d52:	80 68       	ori	r24, 0x80	; 128
    1d54:	8c 93       	st	X, r24
}
    1d56:	cf 91       	pop	r28
    1d58:	df 91       	pop	r29
    1d5a:	08 95       	ret

00001d5c <GIE_voidDisable>:
void GIE_voidDisable(void)
{
    1d5c:	df 93       	push	r29
    1d5e:	cf 93       	push	r28
    1d60:	cd b7       	in	r28, 0x3d	; 61
    1d62:	de b7       	in	r29, 0x3e	; 62
	CLR_BIT(SREG,SREG_I);
    1d64:	af e5       	ldi	r26, 0x5F	; 95
    1d66:	b0 e0       	ldi	r27, 0x00	; 0
    1d68:	ef e5       	ldi	r30, 0x5F	; 95
    1d6a:	f0 e0       	ldi	r31, 0x00	; 0
    1d6c:	80 81       	ld	r24, Z
    1d6e:	8f 77       	andi	r24, 0x7F	; 127
    1d70:	8c 93       	st	X, r24
}
    1d72:	cf 91       	pop	r28
    1d74:	df 91       	pop	r29
    1d76:	08 95       	ret

00001d78 <LCD_voidSendCommand>:
#include "DIO_INTERFACE.h"
#include <util/delay.h>


void LCD_voidSendCommand(u8 copy_u8Command)
{
    1d78:	df 93       	push	r29
    1d7a:	cf 93       	push	r28
    1d7c:	cd b7       	in	r28, 0x3d	; 61
    1d7e:	de b7       	in	r29, 0x3e	; 62
    1d80:	2f 97       	sbiw	r28, 0x0f	; 15
    1d82:	0f b6       	in	r0, 0x3f	; 63
    1d84:	f8 94       	cli
    1d86:	de bf       	out	0x3e, r29	; 62
    1d88:	0f be       	out	0x3f, r0	; 63
    1d8a:	cd bf       	out	0x3d, r28	; 61
    1d8c:	8f 87       	std	Y+15, r24	; 0x0f
/*  DIRCTION OF LCD   */
DIO_u8SetPortDir(LCD_DATA_PORT,DIO_PIN_OUT);
    1d8e:	82 e0       	ldi	r24, 0x02	; 2
    1d90:	61 e0       	ldi	r22, 0x01	; 1
    1d92:	0e 94 32 0a 	call	0x1464	; 0x1464 <DIO_u8SetPortDir>
/*   DIRCTION OF RS/RW/E   */
DIO_u8SetPinDir(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_PIN_OUT);
    1d96:	83 e0       	ldi	r24, 0x03	; 3
    1d98:	60 e0       	ldi	r22, 0x00	; 0
    1d9a:	41 e0       	ldi	r20, 0x01	; 1
    1d9c:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
DIO_u8SetPinDir(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_PIN_OUT);
    1da0:	83 e0       	ldi	r24, 0x03	; 3
    1da2:	61 e0       	ldi	r22, 0x01	; 1
    1da4:	41 e0       	ldi	r20, 0x01	; 1
    1da6:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
DIO_u8SetPinDir(LCD_CONTROL_PORT,LCD_E_PIN,DIO_PIN_OUT);
    1daa:	83 e0       	ldi	r24, 0x03	; 3
    1dac:	62 e0       	ldi	r22, 0x02	; 2
    1dae:	41 e0       	ldi	r20, 0x01	; 1
    1db0:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>

/*Setting RS pin to low*/
DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_LOW);
    1db4:	83 e0       	ldi	r24, 0x03	; 3
    1db6:	60 e0       	ldi	r22, 0x00	; 0
    1db8:	40 e0       	ldi	r20, 0x00	; 0
    1dba:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
/*Setting RW pin low for write*/
DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_LOW);
    1dbe:	83 e0       	ldi	r24, 0x03	; 3
    1dc0:	61 e0       	ldi	r22, 0x01	; 1
    1dc2:	40 e0       	ldi	r20, 0x00	; 0
    1dc4:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
/*Set command data pins*/
DIO_u8SetPortValue(LCD_DATA_PORT,copy_u8Command);
    1dc8:	82 e0       	ldi	r24, 0x02	; 2
    1dca:	6f 85       	ldd	r22, Y+15	; 0x0f
    1dcc:	0e 94 ce 08 	call	0x119c	; 0x119c <DIO_u8SetPortValue>
/*Send Enable pulse*/
DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_HIGH);
    1dd0:	83 e0       	ldi	r24, 0x03	; 3
    1dd2:	62 e0       	ldi	r22, 0x02	; 2
    1dd4:	41 e0       	ldi	r20, 0x01	; 1
    1dd6:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
    1dda:	80 e0       	ldi	r24, 0x00	; 0
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	a0 e0       	ldi	r26, 0x00	; 0
    1de0:	b0 e4       	ldi	r27, 0x40	; 64
    1de2:	8b 87       	std	Y+11, r24	; 0x0b
    1de4:	9c 87       	std	Y+12, r25	; 0x0c
    1de6:	ad 87       	std	Y+13, r26	; 0x0d
    1de8:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1dea:	6b 85       	ldd	r22, Y+11	; 0x0b
    1dec:	7c 85       	ldd	r23, Y+12	; 0x0c
    1dee:	8d 85       	ldd	r24, Y+13	; 0x0d
    1df0:	9e 85       	ldd	r25, Y+14	; 0x0e
    1df2:	20 e0       	ldi	r18, 0x00	; 0
    1df4:	30 e0       	ldi	r19, 0x00	; 0
    1df6:	4a e7       	ldi	r20, 0x7A	; 122
    1df8:	53 e4       	ldi	r21, 0x43	; 67
    1dfa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1dfe:	dc 01       	movw	r26, r24
    1e00:	cb 01       	movw	r24, r22
    1e02:	8f 83       	std	Y+7, r24	; 0x07
    1e04:	98 87       	std	Y+8, r25	; 0x08
    1e06:	a9 87       	std	Y+9, r26	; 0x09
    1e08:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1e0a:	6f 81       	ldd	r22, Y+7	; 0x07
    1e0c:	78 85       	ldd	r23, Y+8	; 0x08
    1e0e:	89 85       	ldd	r24, Y+9	; 0x09
    1e10:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e12:	20 e0       	ldi	r18, 0x00	; 0
    1e14:	30 e0       	ldi	r19, 0x00	; 0
    1e16:	40 e8       	ldi	r20, 0x80	; 128
    1e18:	5f e3       	ldi	r21, 0x3F	; 63
    1e1a:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1e1e:	88 23       	and	r24, r24
    1e20:	2c f4       	brge	.+10     	; 0x1e2c <LCD_voidSendCommand+0xb4>
		__ticks = 1;
    1e22:	81 e0       	ldi	r24, 0x01	; 1
    1e24:	90 e0       	ldi	r25, 0x00	; 0
    1e26:	9e 83       	std	Y+6, r25	; 0x06
    1e28:	8d 83       	std	Y+5, r24	; 0x05
    1e2a:	3f c0       	rjmp	.+126    	; 0x1eaa <LCD_voidSendCommand+0x132>
	else if (__tmp > 65535)
    1e2c:	6f 81       	ldd	r22, Y+7	; 0x07
    1e2e:	78 85       	ldd	r23, Y+8	; 0x08
    1e30:	89 85       	ldd	r24, Y+9	; 0x09
    1e32:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	3f ef       	ldi	r19, 0xFF	; 255
    1e38:	4f e7       	ldi	r20, 0x7F	; 127
    1e3a:	57 e4       	ldi	r21, 0x47	; 71
    1e3c:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1e40:	18 16       	cp	r1, r24
    1e42:	4c f5       	brge	.+82     	; 0x1e96 <LCD_voidSendCommand+0x11e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1e44:	6b 85       	ldd	r22, Y+11	; 0x0b
    1e46:	7c 85       	ldd	r23, Y+12	; 0x0c
    1e48:	8d 85       	ldd	r24, Y+13	; 0x0d
    1e4a:	9e 85       	ldd	r25, Y+14	; 0x0e
    1e4c:	20 e0       	ldi	r18, 0x00	; 0
    1e4e:	30 e0       	ldi	r19, 0x00	; 0
    1e50:	40 e2       	ldi	r20, 0x20	; 32
    1e52:	51 e4       	ldi	r21, 0x41	; 65
    1e54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1e58:	dc 01       	movw	r26, r24
    1e5a:	cb 01       	movw	r24, r22
    1e5c:	bc 01       	movw	r22, r24
    1e5e:	cd 01       	movw	r24, r26
    1e60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1e64:	dc 01       	movw	r26, r24
    1e66:	cb 01       	movw	r24, r22
    1e68:	9e 83       	std	Y+6, r25	; 0x06
    1e6a:	8d 83       	std	Y+5, r24	; 0x05
    1e6c:	0f c0       	rjmp	.+30     	; 0x1e8c <LCD_voidSendCommand+0x114>
    1e6e:	89 e1       	ldi	r24, 0x19	; 25
    1e70:	90 e0       	ldi	r25, 0x00	; 0
    1e72:	9c 83       	std	Y+4, r25	; 0x04
    1e74:	8b 83       	std	Y+3, r24	; 0x03
    1e76:	8b 81       	ldd	r24, Y+3	; 0x03
    1e78:	9c 81       	ldd	r25, Y+4	; 0x04
    1e7a:	01 97       	sbiw	r24, 0x01	; 1
    1e7c:	f1 f7       	brne	.-4      	; 0x1e7a <LCD_voidSendCommand+0x102>
    1e7e:	9c 83       	std	Y+4, r25	; 0x04
    1e80:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1e82:	8d 81       	ldd	r24, Y+5	; 0x05
    1e84:	9e 81       	ldd	r25, Y+6	; 0x06
    1e86:	01 97       	sbiw	r24, 0x01	; 1
    1e88:	9e 83       	std	Y+6, r25	; 0x06
    1e8a:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1e8c:	8d 81       	ldd	r24, Y+5	; 0x05
    1e8e:	9e 81       	ldd	r25, Y+6	; 0x06
    1e90:	00 97       	sbiw	r24, 0x00	; 0
    1e92:	69 f7       	brne	.-38     	; 0x1e6e <LCD_voidSendCommand+0xf6>
    1e94:	14 c0       	rjmp	.+40     	; 0x1ebe <LCD_voidSendCommand+0x146>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1e96:	6f 81       	ldd	r22, Y+7	; 0x07
    1e98:	78 85       	ldd	r23, Y+8	; 0x08
    1e9a:	89 85       	ldd	r24, Y+9	; 0x09
    1e9c:	9a 85       	ldd	r25, Y+10	; 0x0a
    1e9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1ea2:	dc 01       	movw	r26, r24
    1ea4:	cb 01       	movw	r24, r22
    1ea6:	9e 83       	std	Y+6, r25	; 0x06
    1ea8:	8d 83       	std	Y+5, r24	; 0x05
    1eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    1eac:	9e 81       	ldd	r25, Y+6	; 0x06
    1eae:	9a 83       	std	Y+2, r25	; 0x02
    1eb0:	89 83       	std	Y+1, r24	; 0x01
    1eb2:	89 81       	ldd	r24, Y+1	; 0x01
    1eb4:	9a 81       	ldd	r25, Y+2	; 0x02
    1eb6:	01 97       	sbiw	r24, 0x01	; 1
    1eb8:	f1 f7       	brne	.-4      	; 0x1eb6 <LCD_voidSendCommand+0x13e>
    1eba:	9a 83       	std	Y+2, r25	; 0x02
    1ebc:	89 83       	std	Y+1, r24	; 0x01
_delay_ms(2);
DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_LOW);
    1ebe:	83 e0       	ldi	r24, 0x03	; 3
    1ec0:	62 e0       	ldi	r22, 0x02	; 2
    1ec2:	40 e0       	ldi	r20, 0x00	; 0
    1ec4:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
}
    1ec8:	2f 96       	adiw	r28, 0x0f	; 15
    1eca:	0f b6       	in	r0, 0x3f	; 63
    1ecc:	f8 94       	cli
    1ece:	de bf       	out	0x3e, r29	; 62
    1ed0:	0f be       	out	0x3f, r0	; 63
    1ed2:	cd bf       	out	0x3d, r28	; 61
    1ed4:	cf 91       	pop	r28
    1ed6:	df 91       	pop	r29
    1ed8:	08 95       	ret

00001eda <LCD_voidInit>:

void LCD_voidInit(void)
{
    1eda:	df 93       	push	r29
    1edc:	cf 93       	push	r28
    1ede:	cd b7       	in	r28, 0x3d	; 61
    1ee0:	de b7       	in	r29, 0x3e	; 62
    1ee2:	2e 97       	sbiw	r28, 0x0e	; 14
    1ee4:	0f b6       	in	r0, 0x3f	; 63
    1ee6:	f8 94       	cli
    1ee8:	de bf       	out	0x3e, r29	; 62
    1eea:	0f be       	out	0x3f, r0	; 63
    1eec:	cd bf       	out	0x3d, r28	; 61
    1eee:	80 e0       	ldi	r24, 0x00	; 0
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	a0 e2       	ldi	r26, 0x20	; 32
    1ef4:	b2 e4       	ldi	r27, 0x42	; 66
    1ef6:	8b 87       	std	Y+11, r24	; 0x0b
    1ef8:	9c 87       	std	Y+12, r25	; 0x0c
    1efa:	ad 87       	std	Y+13, r26	; 0x0d
    1efc:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1efe:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f00:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f02:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f04:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f06:	20 e0       	ldi	r18, 0x00	; 0
    1f08:	30 e0       	ldi	r19, 0x00	; 0
    1f0a:	4a e7       	ldi	r20, 0x7A	; 122
    1f0c:	53 e4       	ldi	r21, 0x43	; 67
    1f0e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f12:	dc 01       	movw	r26, r24
    1f14:	cb 01       	movw	r24, r22
    1f16:	8f 83       	std	Y+7, r24	; 0x07
    1f18:	98 87       	std	Y+8, r25	; 0x08
    1f1a:	a9 87       	std	Y+9, r26	; 0x09
    1f1c:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1f1e:	6f 81       	ldd	r22, Y+7	; 0x07
    1f20:	78 85       	ldd	r23, Y+8	; 0x08
    1f22:	89 85       	ldd	r24, Y+9	; 0x09
    1f24:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f26:	20 e0       	ldi	r18, 0x00	; 0
    1f28:	30 e0       	ldi	r19, 0x00	; 0
    1f2a:	40 e8       	ldi	r20, 0x80	; 128
    1f2c:	5f e3       	ldi	r21, 0x3F	; 63
    1f2e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    1f32:	88 23       	and	r24, r24
    1f34:	2c f4       	brge	.+10     	; 0x1f40 <LCD_voidInit+0x66>
		__ticks = 1;
    1f36:	81 e0       	ldi	r24, 0x01	; 1
    1f38:	90 e0       	ldi	r25, 0x00	; 0
    1f3a:	9e 83       	std	Y+6, r25	; 0x06
    1f3c:	8d 83       	std	Y+5, r24	; 0x05
    1f3e:	3f c0       	rjmp	.+126    	; 0x1fbe <LCD_voidInit+0xe4>
	else if (__tmp > 65535)
    1f40:	6f 81       	ldd	r22, Y+7	; 0x07
    1f42:	78 85       	ldd	r23, Y+8	; 0x08
    1f44:	89 85       	ldd	r24, Y+9	; 0x09
    1f46:	9a 85       	ldd	r25, Y+10	; 0x0a
    1f48:	20 e0       	ldi	r18, 0x00	; 0
    1f4a:	3f ef       	ldi	r19, 0xFF	; 255
    1f4c:	4f e7       	ldi	r20, 0x7F	; 127
    1f4e:	57 e4       	ldi	r21, 0x47	; 71
    1f50:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    1f54:	18 16       	cp	r1, r24
    1f56:	4c f5       	brge	.+82     	; 0x1faa <LCD_voidInit+0xd0>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1f58:	6b 85       	ldd	r22, Y+11	; 0x0b
    1f5a:	7c 85       	ldd	r23, Y+12	; 0x0c
    1f5c:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f5e:	9e 85       	ldd	r25, Y+14	; 0x0e
    1f60:	20 e0       	ldi	r18, 0x00	; 0
    1f62:	30 e0       	ldi	r19, 0x00	; 0
    1f64:	40 e2       	ldi	r20, 0x20	; 32
    1f66:	51 e4       	ldi	r21, 0x41	; 65
    1f68:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1f6c:	dc 01       	movw	r26, r24
    1f6e:	cb 01       	movw	r24, r22
    1f70:	bc 01       	movw	r22, r24
    1f72:	cd 01       	movw	r24, r26
    1f74:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1f78:	dc 01       	movw	r26, r24
    1f7a:	cb 01       	movw	r24, r22
    1f7c:	9e 83       	std	Y+6, r25	; 0x06
    1f7e:	8d 83       	std	Y+5, r24	; 0x05
    1f80:	0f c0       	rjmp	.+30     	; 0x1fa0 <LCD_voidInit+0xc6>
    1f82:	89 e1       	ldi	r24, 0x19	; 25
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	9c 83       	std	Y+4, r25	; 0x04
    1f88:	8b 83       	std	Y+3, r24	; 0x03
    1f8a:	8b 81       	ldd	r24, Y+3	; 0x03
    1f8c:	9c 81       	ldd	r25, Y+4	; 0x04
    1f8e:	01 97       	sbiw	r24, 0x01	; 1
    1f90:	f1 f7       	brne	.-4      	; 0x1f8e <LCD_voidInit+0xb4>
    1f92:	9c 83       	std	Y+4, r25	; 0x04
    1f94:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1f96:	8d 81       	ldd	r24, Y+5	; 0x05
    1f98:	9e 81       	ldd	r25, Y+6	; 0x06
    1f9a:	01 97       	sbiw	r24, 0x01	; 1
    1f9c:	9e 83       	std	Y+6, r25	; 0x06
    1f9e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1fa0:	8d 81       	ldd	r24, Y+5	; 0x05
    1fa2:	9e 81       	ldd	r25, Y+6	; 0x06
    1fa4:	00 97       	sbiw	r24, 0x00	; 0
    1fa6:	69 f7       	brne	.-38     	; 0x1f82 <LCD_voidInit+0xa8>
    1fa8:	14 c0       	rjmp	.+40     	; 0x1fd2 <LCD_voidInit+0xf8>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1faa:	6f 81       	ldd	r22, Y+7	; 0x07
    1fac:	78 85       	ldd	r23, Y+8	; 0x08
    1fae:	89 85       	ldd	r24, Y+9	; 0x09
    1fb0:	9a 85       	ldd	r25, Y+10	; 0x0a
    1fb2:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1fb6:	dc 01       	movw	r26, r24
    1fb8:	cb 01       	movw	r24, r22
    1fba:	9e 83       	std	Y+6, r25	; 0x06
    1fbc:	8d 83       	std	Y+5, r24	; 0x05
    1fbe:	8d 81       	ldd	r24, Y+5	; 0x05
    1fc0:	9e 81       	ldd	r25, Y+6	; 0x06
    1fc2:	9a 83       	std	Y+2, r25	; 0x02
    1fc4:	89 83       	std	Y+1, r24	; 0x01
    1fc6:	89 81       	ldd	r24, Y+1	; 0x01
    1fc8:	9a 81       	ldd	r25, Y+2	; 0x02
    1fca:	01 97       	sbiw	r24, 0x01	; 1
    1fcc:	f1 f7       	brne	.-4      	; 0x1fca <LCD_voidInit+0xf0>
    1fce:	9a 83       	std	Y+2, r25	; 0x02
    1fd0:	89 83       	std	Y+1, r24	; 0x01
	/*Wait more that 40 ms*/
	_delay_ms(40);
	LCD_voidSendCommand(Fun_Enable);
    1fd2:	88 e3       	ldi	r24, 0x38	; 56
    1fd4:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <LCD_voidSendCommand>

	LCD_voidSendCommand(DISPLAY_ON_OF);
    1fd8:	8c e0       	ldi	r24, 0x0C	; 12
    1fda:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <LCD_voidSendCommand>

	LCD_voidSendCommand(DISPLAY_Clr);
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <LCD_voidSendCommand>



}
    1fe4:	2e 96       	adiw	r28, 0x0e	; 14
    1fe6:	0f b6       	in	r0, 0x3f	; 63
    1fe8:	f8 94       	cli
    1fea:	de bf       	out	0x3e, r29	; 62
    1fec:	0f be       	out	0x3f, r0	; 63
    1fee:	cd bf       	out	0x3d, r28	; 61
    1ff0:	cf 91       	pop	r28
    1ff2:	df 91       	pop	r29
    1ff4:	08 95       	ret

00001ff6 <LCD_voidSendData>:


void LCD_voidSendData(u8 copy_u8Data)
{
    1ff6:	df 93       	push	r29
    1ff8:	cf 93       	push	r28
    1ffa:	cd b7       	in	r28, 0x3d	; 61
    1ffc:	de b7       	in	r29, 0x3e	; 62
    1ffe:	2f 97       	sbiw	r28, 0x0f	; 15
    2000:	0f b6       	in	r0, 0x3f	; 63
    2002:	f8 94       	cli
    2004:	de bf       	out	0x3e, r29	; 62
    2006:	0f be       	out	0x3f, r0	; 63
    2008:	cd bf       	out	0x3d, r28	; 61
    200a:	8f 87       	std	Y+15, r24	; 0x0f

	/*Setting RS pin to HIGH*/
	DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_RS_PIN,DIO_HIGH);
    200c:	83 e0       	ldi	r24, 0x03	; 3
    200e:	60 e0       	ldi	r22, 0x00	; 0
    2010:	41 e0       	ldi	r20, 0x01	; 1
    2012:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
	/*Setting RW pin low for write*/
	DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_RW_PIN,DIO_LOW);
    2016:	83 e0       	ldi	r24, 0x03	; 3
    2018:	61 e0       	ldi	r22, 0x01	; 1
    201a:	40 e0       	ldi	r20, 0x00	; 0
    201c:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>

	/*Set data pins*/
	DIO_u8SetPortValue(LCD_DATA_PORT,copy_u8Data);
    2020:	82 e0       	ldi	r24, 0x02	; 2
    2022:	6f 85       	ldd	r22, Y+15	; 0x0f
    2024:	0e 94 ce 08 	call	0x119c	; 0x119c <DIO_u8SetPortValue>

	/*Send Enable pulse*/
	DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_HIGH);
    2028:	83 e0       	ldi	r24, 0x03	; 3
    202a:	62 e0       	ldi	r22, 0x02	; 2
    202c:	41 e0       	ldi	r20, 0x01	; 1
    202e:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	90 e0       	ldi	r25, 0x00	; 0
    2036:	a0 e0       	ldi	r26, 0x00	; 0
    2038:	b0 e4       	ldi	r27, 0x40	; 64
    203a:	8b 87       	std	Y+11, r24	; 0x0b
    203c:	9c 87       	std	Y+12, r25	; 0x0c
    203e:	ad 87       	std	Y+13, r26	; 0x0d
    2040:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    2042:	6b 85       	ldd	r22, Y+11	; 0x0b
    2044:	7c 85       	ldd	r23, Y+12	; 0x0c
    2046:	8d 85       	ldd	r24, Y+13	; 0x0d
    2048:	9e 85       	ldd	r25, Y+14	; 0x0e
    204a:	20 e0       	ldi	r18, 0x00	; 0
    204c:	30 e0       	ldi	r19, 0x00	; 0
    204e:	4a e7       	ldi	r20, 0x7A	; 122
    2050:	53 e4       	ldi	r21, 0x43	; 67
    2052:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    2056:	dc 01       	movw	r26, r24
    2058:	cb 01       	movw	r24, r22
    205a:	8f 83       	std	Y+7, r24	; 0x07
    205c:	98 87       	std	Y+8, r25	; 0x08
    205e:	a9 87       	std	Y+9, r26	; 0x09
    2060:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    2062:	6f 81       	ldd	r22, Y+7	; 0x07
    2064:	78 85       	ldd	r23, Y+8	; 0x08
    2066:	89 85       	ldd	r24, Y+9	; 0x09
    2068:	9a 85       	ldd	r25, Y+10	; 0x0a
    206a:	20 e0       	ldi	r18, 0x00	; 0
    206c:	30 e0       	ldi	r19, 0x00	; 0
    206e:	40 e8       	ldi	r20, 0x80	; 128
    2070:	5f e3       	ldi	r21, 0x3F	; 63
    2072:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    2076:	88 23       	and	r24, r24
    2078:	2c f4       	brge	.+10     	; 0x2084 <LCD_voidSendData+0x8e>
		__ticks = 1;
    207a:	81 e0       	ldi	r24, 0x01	; 1
    207c:	90 e0       	ldi	r25, 0x00	; 0
    207e:	9e 83       	std	Y+6, r25	; 0x06
    2080:	8d 83       	std	Y+5, r24	; 0x05
    2082:	3f c0       	rjmp	.+126    	; 0x2102 <LCD_voidSendData+0x10c>
	else if (__tmp > 65535)
    2084:	6f 81       	ldd	r22, Y+7	; 0x07
    2086:	78 85       	ldd	r23, Y+8	; 0x08
    2088:	89 85       	ldd	r24, Y+9	; 0x09
    208a:	9a 85       	ldd	r25, Y+10	; 0x0a
    208c:	20 e0       	ldi	r18, 0x00	; 0
    208e:	3f ef       	ldi	r19, 0xFF	; 255
    2090:	4f e7       	ldi	r20, 0x7F	; 127
    2092:	57 e4       	ldi	r21, 0x47	; 71
    2094:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    2098:	18 16       	cp	r1, r24
    209a:	4c f5       	brge	.+82     	; 0x20ee <LCD_voidSendData+0xf8>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    209c:	6b 85       	ldd	r22, Y+11	; 0x0b
    209e:	7c 85       	ldd	r23, Y+12	; 0x0c
    20a0:	8d 85       	ldd	r24, Y+13	; 0x0d
    20a2:	9e 85       	ldd	r25, Y+14	; 0x0e
    20a4:	20 e0       	ldi	r18, 0x00	; 0
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	40 e2       	ldi	r20, 0x20	; 32
    20aa:	51 e4       	ldi	r21, 0x41	; 65
    20ac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    20b0:	dc 01       	movw	r26, r24
    20b2:	cb 01       	movw	r24, r22
    20b4:	bc 01       	movw	r22, r24
    20b6:	cd 01       	movw	r24, r26
    20b8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20bc:	dc 01       	movw	r26, r24
    20be:	cb 01       	movw	r24, r22
    20c0:	9e 83       	std	Y+6, r25	; 0x06
    20c2:	8d 83       	std	Y+5, r24	; 0x05
    20c4:	0f c0       	rjmp	.+30     	; 0x20e4 <LCD_voidSendData+0xee>
    20c6:	89 e1       	ldi	r24, 0x19	; 25
    20c8:	90 e0       	ldi	r25, 0x00	; 0
    20ca:	9c 83       	std	Y+4, r25	; 0x04
    20cc:	8b 83       	std	Y+3, r24	; 0x03
    20ce:	8b 81       	ldd	r24, Y+3	; 0x03
    20d0:	9c 81       	ldd	r25, Y+4	; 0x04
    20d2:	01 97       	sbiw	r24, 0x01	; 1
    20d4:	f1 f7       	brne	.-4      	; 0x20d2 <LCD_voidSendData+0xdc>
    20d6:	9c 83       	std	Y+4, r25	; 0x04
    20d8:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    20da:	8d 81       	ldd	r24, Y+5	; 0x05
    20dc:	9e 81       	ldd	r25, Y+6	; 0x06
    20de:	01 97       	sbiw	r24, 0x01	; 1
    20e0:	9e 83       	std	Y+6, r25	; 0x06
    20e2:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    20e4:	8d 81       	ldd	r24, Y+5	; 0x05
    20e6:	9e 81       	ldd	r25, Y+6	; 0x06
    20e8:	00 97       	sbiw	r24, 0x00	; 0
    20ea:	69 f7       	brne	.-38     	; 0x20c6 <LCD_voidSendData+0xd0>
    20ec:	14 c0       	rjmp	.+40     	; 0x2116 <LCD_voidSendData+0x120>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    20ee:	6f 81       	ldd	r22, Y+7	; 0x07
    20f0:	78 85       	ldd	r23, Y+8	; 0x08
    20f2:	89 85       	ldd	r24, Y+9	; 0x09
    20f4:	9a 85       	ldd	r25, Y+10	; 0x0a
    20f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    20fa:	dc 01       	movw	r26, r24
    20fc:	cb 01       	movw	r24, r22
    20fe:	9e 83       	std	Y+6, r25	; 0x06
    2100:	8d 83       	std	Y+5, r24	; 0x05
    2102:	8d 81       	ldd	r24, Y+5	; 0x05
    2104:	9e 81       	ldd	r25, Y+6	; 0x06
    2106:	9a 83       	std	Y+2, r25	; 0x02
    2108:	89 83       	std	Y+1, r24	; 0x01
    210a:	89 81       	ldd	r24, Y+1	; 0x01
    210c:	9a 81       	ldd	r25, Y+2	; 0x02
    210e:	01 97       	sbiw	r24, 0x01	; 1
    2110:	f1 f7       	brne	.-4      	; 0x210e <LCD_voidSendData+0x118>
    2112:	9a 83       	std	Y+2, r25	; 0x02
    2114:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
	DIO_u8SetPinValue(LCD_CONTROL_PORT,LCD_E_PIN,DIO_LOW);
    2116:	83 e0       	ldi	r24, 0x03	; 3
    2118:	62 e0       	ldi	r22, 0x02	; 2
    211a:	40 e0       	ldi	r20, 0x00	; 0
    211c:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>


}
    2120:	2f 96       	adiw	r28, 0x0f	; 15
    2122:	0f b6       	in	r0, 0x3f	; 63
    2124:	f8 94       	cli
    2126:	de bf       	out	0x3e, r29	; 62
    2128:	0f be       	out	0x3f, r0	; 63
    212a:	cd bf       	out	0x3d, r28	; 61
    212c:	cf 91       	pop	r28
    212e:	df 91       	pop	r29
    2130:	08 95       	ret

00002132 <LCD_voidSendString>:

void LCD_voidSendString(const char* Copy_u8String)
{
    2132:	df 93       	push	r29
    2134:	cf 93       	push	r28
    2136:	00 d0       	rcall	.+0      	; 0x2138 <LCD_voidSendString+0x6>
    2138:	0f 92       	push	r0
    213a:	cd b7       	in	r28, 0x3d	; 61
    213c:	de b7       	in	r29, 0x3e	; 62
    213e:	9b 83       	std	Y+3, r25	; 0x03
    2140:	8a 83       	std	Y+2, r24	; 0x02
u8 Local_u8Counter=0;
    2142:	19 82       	std	Y+1, r1	; 0x01
    2144:	0e c0       	rjmp	.+28     	; 0x2162 <LCD_voidSendString+0x30>
while(Copy_u8String[Local_u8Counter]!='\0')
{
    LCD_voidSendData(Copy_u8String[Local_u8Counter]);
    2146:	89 81       	ldd	r24, Y+1	; 0x01
    2148:	28 2f       	mov	r18, r24
    214a:	30 e0       	ldi	r19, 0x00	; 0
    214c:	8a 81       	ldd	r24, Y+2	; 0x02
    214e:	9b 81       	ldd	r25, Y+3	; 0x03
    2150:	fc 01       	movw	r30, r24
    2152:	e2 0f       	add	r30, r18
    2154:	f3 1f       	adc	r31, r19
    2156:	80 81       	ld	r24, Z
    2158:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <LCD_voidSendData>
    Local_u8Counter++;
    215c:	89 81       	ldd	r24, Y+1	; 0x01
    215e:	8f 5f       	subi	r24, 0xFF	; 255
    2160:	89 83       	std	Y+1, r24	; 0x01
}

void LCD_voidSendString(const char* Copy_u8String)
{
u8 Local_u8Counter=0;
while(Copy_u8String[Local_u8Counter]!='\0')
    2162:	89 81       	ldd	r24, Y+1	; 0x01
    2164:	28 2f       	mov	r18, r24
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	8a 81       	ldd	r24, Y+2	; 0x02
    216a:	9b 81       	ldd	r25, Y+3	; 0x03
    216c:	fc 01       	movw	r30, r24
    216e:	e2 0f       	add	r30, r18
    2170:	f3 1f       	adc	r31, r19
    2172:	80 81       	ld	r24, Z
    2174:	88 23       	and	r24, r24
    2176:	39 f7       	brne	.-50     	; 0x2146 <LCD_voidSendString+0x14>
{
    LCD_voidSendData(Copy_u8String[Local_u8Counter]);
    Local_u8Counter++;
}

}
    2178:	0f 90       	pop	r0
    217a:	0f 90       	pop	r0
    217c:	0f 90       	pop	r0
    217e:	cf 91       	pop	r28
    2180:	df 91       	pop	r29
    2182:	08 95       	ret

00002184 <LCD_voidGoToXY>:


void LCD_voidGoToXY(u8 Copy_u8Xposition,u8 Copy_u8Yposition)
{
    2184:	df 93       	push	r29
    2186:	cf 93       	push	r28
    2188:	00 d0       	rcall	.+0      	; 0x218a <LCD_voidGoToXY+0x6>
    218a:	0f 92       	push	r0
    218c:	cd b7       	in	r28, 0x3d	; 61
    218e:	de b7       	in	r29, 0x3e	; 62
    2190:	8a 83       	std	Y+2, r24	; 0x02
    2192:	6b 83       	std	Y+3, r22	; 0x03
  u8 Local_u8Address;

  if(Copy_u8Xposition==0)
    2194:	8a 81       	ldd	r24, Y+2	; 0x02
    2196:	88 23       	and	r24, r24
    2198:	19 f4       	brne	.+6      	; 0x21a0 <LCD_voidGoToXY+0x1c>
  {
	  Local_u8Address=Copy_u8Yposition;
    219a:	8b 81       	ldd	r24, Y+3	; 0x03
    219c:	89 83       	std	Y+1, r24	; 0x01
    219e:	06 c0       	rjmp	.+12     	; 0x21ac <LCD_voidGoToXY+0x28>
  }
  else if(Copy_u8Xposition==1)
    21a0:	8a 81       	ldd	r24, Y+2	; 0x02
    21a2:	81 30       	cpi	r24, 0x01	; 1
    21a4:	19 f4       	brne	.+6      	; 0x21ac <LCD_voidGoToXY+0x28>

  {
	  Local_u8Address=Copy_u8Yposition+0x40;
    21a6:	8b 81       	ldd	r24, Y+3	; 0x03
    21a8:	80 5c       	subi	r24, 0xC0	; 192
    21aa:	89 83       	std	Y+1, r24	; 0x01
  }

  LCD_voidSendCommand(Local_u8Address|(1<<7));
    21ac:	89 81       	ldd	r24, Y+1	; 0x01
    21ae:	80 68       	ori	r24, 0x80	; 128
    21b0:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <LCD_voidSendCommand>

  //LCD_voidSendCommand(SET_BIT(Local_u8Address,7));
}
    21b4:	0f 90       	pop	r0
    21b6:	0f 90       	pop	r0
    21b8:	0f 90       	pop	r0
    21ba:	cf 91       	pop	r28
    21bc:	df 91       	pop	r29
    21be:	08 95       	ret

000021c0 <LCD_voidWriteNumber>:


void LCD_voidWriteNumber(u32 copy_u32Number)
{
    21c0:	df 93       	push	r29
    21c2:	cf 93       	push	r28
    21c4:	cd b7       	in	r28, 0x3d	; 61
    21c6:	de b7       	in	r29, 0x3e	; 62
    21c8:	27 97       	sbiw	r28, 0x07	; 7
    21ca:	0f b6       	in	r0, 0x3f	; 63
    21cc:	f8 94       	cli
    21ce:	de bf       	out	0x3e, r29	; 62
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	cd bf       	out	0x3d, r28	; 61
    21d4:	6c 83       	std	Y+4, r22	; 0x04
    21d6:	7d 83       	std	Y+5, r23	; 0x05
    21d8:	8e 83       	std	Y+6, r24	; 0x06
    21da:	9f 83       	std	Y+7, r25	; 0x07
	u8 Local_u8Digit;
	u8 Local_u8Counter1=0;
    21dc:	1a 82       	std	Y+2, r1	; 0x02
	s8 Local_u8Counter2;
	static u8 Local_ArrayOfChar[10]={'0','1','2','3','4','5','6','7','8','9'};
	static u8 Local_ArrayOfDigits[10];

	if(copy_u32Number==0)
    21de:	8c 81       	ldd	r24, Y+4	; 0x04
    21e0:	9d 81       	ldd	r25, Y+5	; 0x05
    21e2:	ae 81       	ldd	r26, Y+6	; 0x06
    21e4:	bf 81       	ldd	r27, Y+7	; 0x07
    21e6:	00 97       	sbiw	r24, 0x00	; 0
    21e8:	a1 05       	cpc	r26, r1
    21ea:	b1 05       	cpc	r27, r1
    21ec:	b9 f5       	brne	.+110    	; 0x225c <LCD_voidWriteNumber+0x9c>
	{
		LCD_voidSendData(Local_ArrayOfChar[0]);
    21ee:	80 91 06 01 	lds	r24, 0x0106
    21f2:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <LCD_voidSendData>
    21f6:	4e c0       	rjmp	.+156    	; 0x2294 <LCD_voidWriteNumber+0xd4>
	else
	{

		while(copy_u32Number>0)
		{
			Local_u8Digit=copy_u32Number%10;
    21f8:	8c 81       	ldd	r24, Y+4	; 0x04
    21fa:	9d 81       	ldd	r25, Y+5	; 0x05
    21fc:	ae 81       	ldd	r26, Y+6	; 0x06
    21fe:	bf 81       	ldd	r27, Y+7	; 0x07
    2200:	2a e0       	ldi	r18, 0x0A	; 10
    2202:	30 e0       	ldi	r19, 0x00	; 0
    2204:	40 e0       	ldi	r20, 0x00	; 0
    2206:	50 e0       	ldi	r21, 0x00	; 0
    2208:	bc 01       	movw	r22, r24
    220a:	cd 01       	movw	r24, r26
    220c:	0e 94 ac 29 	call	0x5358	; 0x5358 <__udivmodsi4>
    2210:	dc 01       	movw	r26, r24
    2212:	cb 01       	movw	r24, r22
    2214:	8b 83       	std	Y+3, r24	; 0x03
			copy_u32Number=copy_u32Number/10;
    2216:	8c 81       	ldd	r24, Y+4	; 0x04
    2218:	9d 81       	ldd	r25, Y+5	; 0x05
    221a:	ae 81       	ldd	r26, Y+6	; 0x06
    221c:	bf 81       	ldd	r27, Y+7	; 0x07
    221e:	2a e0       	ldi	r18, 0x0A	; 10
    2220:	30 e0       	ldi	r19, 0x00	; 0
    2222:	40 e0       	ldi	r20, 0x00	; 0
    2224:	50 e0       	ldi	r21, 0x00	; 0
    2226:	bc 01       	movw	r22, r24
    2228:	cd 01       	movw	r24, r26
    222a:	0e 94 ac 29 	call	0x5358	; 0x5358 <__udivmodsi4>
    222e:	da 01       	movw	r26, r20
    2230:	c9 01       	movw	r24, r18
    2232:	8c 83       	std	Y+4, r24	; 0x04
    2234:	9d 83       	std	Y+5, r25	; 0x05
    2236:	ae 83       	std	Y+6, r26	; 0x06
    2238:	bf 83       	std	Y+7, r27	; 0x07
			Local_ArrayOfDigits[Local_u8Counter1]=Local_ArrayOfChar[Local_u8Digit];
    223a:	8a 81       	ldd	r24, Y+2	; 0x02
    223c:	28 2f       	mov	r18, r24
    223e:	30 e0       	ldi	r19, 0x00	; 0
    2240:	8b 81       	ldd	r24, Y+3	; 0x03
    2242:	88 2f       	mov	r24, r24
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	fc 01       	movw	r30, r24
    2248:	ea 5f       	subi	r30, 0xFA	; 250
    224a:	fe 4f       	sbci	r31, 0xFE	; 254
    224c:	80 81       	ld	r24, Z
    224e:	f9 01       	movw	r30, r18
    2250:	ec 5c       	subi	r30, 0xCC	; 204
    2252:	fe 4f       	sbci	r31, 0xFE	; 254
    2254:	80 83       	st	Z, r24
			Local_u8Counter1++;
    2256:	8a 81       	ldd	r24, Y+2	; 0x02
    2258:	8f 5f       	subi	r24, 0xFF	; 255
    225a:	8a 83       	std	Y+2, r24	; 0x02
		LCD_voidSendData(Local_ArrayOfChar[0]);
	}
	else
	{

		while(copy_u32Number>0)
    225c:	8c 81       	ldd	r24, Y+4	; 0x04
    225e:	9d 81       	ldd	r25, Y+5	; 0x05
    2260:	ae 81       	ldd	r26, Y+6	; 0x06
    2262:	bf 81       	ldd	r27, Y+7	; 0x07
    2264:	00 97       	sbiw	r24, 0x00	; 0
    2266:	a1 05       	cpc	r26, r1
    2268:	b1 05       	cpc	r27, r1
    226a:	31 f6       	brne	.-116    	; 0x21f8 <LCD_voidWriteNumber+0x38>
			copy_u32Number=copy_u32Number/10;
			Local_ArrayOfDigits[Local_u8Counter1]=Local_ArrayOfChar[Local_u8Digit];
			Local_u8Counter1++;
		}

		for(Local_u8Counter2=Local_u8Counter1-1;Local_u8Counter2>=0;Local_u8Counter2--)
    226c:	8a 81       	ldd	r24, Y+2	; 0x02
    226e:	81 50       	subi	r24, 0x01	; 1
    2270:	89 83       	std	Y+1, r24	; 0x01
    2272:	0d c0       	rjmp	.+26     	; 0x228e <LCD_voidWriteNumber+0xce>
		{
			LCD_voidSendData(Local_ArrayOfDigits[Local_u8Counter2]);
    2274:	89 81       	ldd	r24, Y+1	; 0x01
    2276:	99 27       	eor	r25, r25
    2278:	87 fd       	sbrc	r24, 7
    227a:	90 95       	com	r25
    227c:	fc 01       	movw	r30, r24
    227e:	ec 5c       	subi	r30, 0xCC	; 204
    2280:	fe 4f       	sbci	r31, 0xFE	; 254
    2282:	80 81       	ld	r24, Z
    2284:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <LCD_voidSendData>
			copy_u32Number=copy_u32Number/10;
			Local_ArrayOfDigits[Local_u8Counter1]=Local_ArrayOfChar[Local_u8Digit];
			Local_u8Counter1++;
		}

		for(Local_u8Counter2=Local_u8Counter1-1;Local_u8Counter2>=0;Local_u8Counter2--)
    2288:	89 81       	ldd	r24, Y+1	; 0x01
    228a:	81 50       	subi	r24, 0x01	; 1
    228c:	89 83       	std	Y+1, r24	; 0x01
    228e:	89 81       	ldd	r24, Y+1	; 0x01
    2290:	88 23       	and	r24, r24
    2292:	84 f7       	brge	.-32     	; 0x2274 <LCD_voidWriteNumber+0xb4>
		{
			LCD_voidSendData(Local_ArrayOfDigits[Local_u8Counter2]);
		}
	}
}
    2294:	27 96       	adiw	r28, 0x07	; 7
    2296:	0f b6       	in	r0, 0x3f	; 63
    2298:	f8 94       	cli
    229a:	de bf       	out	0x3e, r29	; 62
    229c:	0f be       	out	0x3f, r0	; 63
    229e:	cd bf       	out	0x3d, r28	; 61
    22a0:	cf 91       	pop	r28
    22a2:	df 91       	pop	r29
    22a4:	08 95       	ret

000022a6 <LCD_voidClearScreen>:

void LCD_voidClearScreen(void){
    22a6:	df 93       	push	r29
    22a8:	cf 93       	push	r28
    22aa:	cd b7       	in	r28, 0x3d	; 61
    22ac:	de b7       	in	r29, 0x3e	; 62
	LCD_voidSendCommand(DISPLAY_Clr);
    22ae:	81 e0       	ldi	r24, 0x01	; 1
    22b0:	0e 94 bc 0e 	call	0x1d78	; 0x1d78 <LCD_voidSendCommand>
}
    22b4:	cf 91       	pop	r28
    22b6:	df 91       	pop	r29
    22b8:	08 95       	ret

000022ba <SPI_voidINITMaster>:
#include"SPI_REGISTER.h"
#include"SPI_INTERFACE.h"


void  SPI_voidINITMaster(void)
{      /*Master DIRECTION*/
    22ba:	df 93       	push	r29
    22bc:	cf 93       	push	r28
    22be:	cd b7       	in	r28, 0x3d	; 61
    22c0:	de b7       	in	r29, 0x3e	; 62
	    DIO_u8SetPinDir(DIO_PORTB,DIO_PIN4,DIO_PIN_IN);
    22c2:	81 e0       	ldi	r24, 0x01	; 1
    22c4:	64 e0       	ldi	r22, 0x04	; 4
    22c6:	40 e0       	ldi	r20, 0x00	; 0
    22c8:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
		DIO_u8SetPinValue(DIO_PORTB,DIO_PIN4,DIO_HIGH);
    22cc:	81 e0       	ldi	r24, 0x01	; 1
    22ce:	64 e0       	ldi	r22, 0x04	; 4
    22d0:	41 e0       	ldi	r20, 0x01	; 1
    22d2:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
		DIO_u8SetPinDir(DIO_PORTB,DIO_PIN5,DIO_PIN_OUT);
    22d6:	81 e0       	ldi	r24, 0x01	; 1
    22d8:	65 e0       	ldi	r22, 0x05	; 5
    22da:	41 e0       	ldi	r20, 0x01	; 1
    22dc:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
		DIO_u8SetPinDir(DIO_PORTB,DIO_PIN6,DIO_PIN_IN);
    22e0:	81 e0       	ldi	r24, 0x01	; 1
    22e2:	66 e0       	ldi	r22, 0x06	; 6
    22e4:	40 e0       	ldi	r20, 0x00	; 0
    22e6:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
		DIO_u8SetPinDir(DIO_PORTB,DIO_PIN7,DIO_PIN_OUT);
    22ea:	81 e0       	ldi	r24, 0x01	; 1
    22ec:	67 e0       	ldi	r22, 0x07	; 7
    22ee:	41 e0       	ldi	r20, 0x01	; 1
    22f0:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	/* Master Initialization */
	   SET_BIT(SPCR,SPCR_MSTR);
    22f4:	ad e2       	ldi	r26, 0x2D	; 45
    22f6:	b0 e0       	ldi	r27, 0x00	; 0
    22f8:	ed e2       	ldi	r30, 0x2D	; 45
    22fa:	f0 e0       	ldi	r31, 0x00	; 0
    22fc:	80 81       	ld	r24, Z
    22fe:	80 61       	ori	r24, 0x10	; 16
    2300:	8c 93       	st	X, r24

    /*Set Prescaler Devision Factor: Div_By_16*/
	   SET_BIT(SPCR,SPCR_SPR0);
    2302:	ad e2       	ldi	r26, 0x2D	; 45
    2304:	b0 e0       	ldi	r27, 0x00	; 0
    2306:	ed e2       	ldi	r30, 0x2D	; 45
    2308:	f0 e0       	ldi	r31, 0x00	; 0
    230a:	80 81       	ld	r24, Z
    230c:	81 60       	ori	r24, 0x01	; 1
    230e:	8c 93       	st	X, r24
	   CLR_BIT(SPCR,SPCR_SPR1);
    2310:	ad e2       	ldi	r26, 0x2D	; 45
    2312:	b0 e0       	ldi	r27, 0x00	; 0
    2314:	ed e2       	ldi	r30, 0x2D	; 45
    2316:	f0 e0       	ldi	r31, 0x00	; 0
    2318:	80 81       	ld	r24, Z
    231a:	8d 7f       	andi	r24, 0xFD	; 253
    231c:	8c 93       	st	X, r24
	   CLR_BIT(SPSR,SPSR_SPI2X);
    231e:	ae e2       	ldi	r26, 0x2E	; 46
    2320:	b0 e0       	ldi	r27, 0x00	; 0
    2322:	ee e2       	ldi	r30, 0x2E	; 46
    2324:	f0 e0       	ldi	r31, 0x00	; 0
    2326:	80 81       	ld	r24, Z
    2328:	8e 7f       	andi	r24, 0xFE	; 254
    232a:	8c 93       	st	X, r24

	/* Set SPI Enable State*/
	   SET_BIT(SPCR,SPCR_SPE);
    232c:	ad e2       	ldi	r26, 0x2D	; 45
    232e:	b0 e0       	ldi	r27, 0x00	; 0
    2330:	ed e2       	ldi	r30, 0x2D	; 45
    2332:	f0 e0       	ldi	r31, 0x00	; 0
    2334:	80 81       	ld	r24, Z
    2336:	80 64       	ori	r24, 0x40	; 64
    2338:	8c 93       	st	X, r24

}
    233a:	cf 91       	pop	r28
    233c:	df 91       	pop	r29
    233e:	08 95       	ret

00002340 <SPI_voidINITSlave>:

void  SPI_voidINITSlave(void)
{
    2340:	df 93       	push	r29
    2342:	cf 93       	push	r28
    2344:	cd b7       	in	r28, 0x3d	; 61
    2346:	de b7       	in	r29, 0x3e	; 62
	/** Slave Direction**/
	        DIO_u8SetPinDir(DIO_PORTB,DIO_PIN4,DIO_PIN_IN);
    2348:	81 e0       	ldi	r24, 0x01	; 1
    234a:	64 e0       	ldi	r22, 0x04	; 4
    234c:	40 e0       	ldi	r20, 0x00	; 0
    234e:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
			DIO_u8SetPinDir(DIO_PORTB,DIO_PIN5,DIO_PIN_IN);
    2352:	81 e0       	ldi	r24, 0x01	; 1
    2354:	65 e0       	ldi	r22, 0x05	; 5
    2356:	40 e0       	ldi	r20, 0x00	; 0
    2358:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
			DIO_u8SetPinDir(DIO_PORTB,DIO_PIN6,DIO_PIN_OUT);
    235c:	81 e0       	ldi	r24, 0x01	; 1
    235e:	66 e0       	ldi	r22, 0x06	; 6
    2360:	41 e0       	ldi	r20, 0x01	; 1
    2362:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
			DIO_u8SetPinDir(DIO_PORTB,DIO_PIN7,DIO_PIN_IN);
    2366:	81 e0       	ldi	r24, 0x01	; 1
    2368:	67 e0       	ldi	r22, 0x07	; 7
    236a:	40 e0       	ldi	r20, 0x00	; 0
    236c:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
			DIO_u8SetPinDir(DIO_PORTA,DIO_PIN0,DIO_PIN_OUT);
    2370:	80 e0       	ldi	r24, 0x00	; 0
    2372:	60 e0       	ldi	r22, 0x00	; 0
    2374:	41 e0       	ldi	r20, 0x01	; 1
    2376:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>

	/* Slave Initialization */
	   CLR_BIT(SPCR,SPCR_MSTR);
    237a:	ad e2       	ldi	r26, 0x2D	; 45
    237c:	b0 e0       	ldi	r27, 0x00	; 0
    237e:	ed e2       	ldi	r30, 0x2D	; 45
    2380:	f0 e0       	ldi	r31, 0x00	; 0
    2382:	80 81       	ld	r24, Z
    2384:	8f 7e       	andi	r24, 0xEF	; 239
    2386:	8c 93       	st	X, r24

    /* Set SPI Enable State*/
	   SET_BIT(SPCR,SPCR_SPE);
    2388:	ad e2       	ldi	r26, 0x2D	; 45
    238a:	b0 e0       	ldi	r27, 0x00	; 0
    238c:	ed e2       	ldi	r30, 0x2D	; 45
    238e:	f0 e0       	ldi	r31, 0x00	; 0
    2390:	80 81       	ld	r24, Z
    2392:	80 64       	ori	r24, 0x40	; 64
    2394:	8c 93       	st	X, r24

}
    2396:	cf 91       	pop	r28
    2398:	df 91       	pop	r29
    239a:	08 95       	ret

0000239c <SPI_u8Transceive>:

u8   SPI_u8Transceive(u8  Copy_u8Data)
{
    239c:	df 93       	push	r29
    239e:	cf 93       	push	r28
    23a0:	0f 92       	push	r0
    23a2:	cd b7       	in	r28, 0x3d	; 61
    23a4:	de b7       	in	r29, 0x3e	; 62
    23a6:	89 83       	std	Y+1, r24	; 0x01
	/*Sending The Data*/
        SPDR = Copy_u8Data;
    23a8:	ef e2       	ldi	r30, 0x2F	; 47
    23aa:	f0 e0       	ldi	r31, 0x00	; 0
    23ac:	89 81       	ldd	r24, Y+1	; 0x01
    23ae:	80 83       	st	Z, r24

    /*Busy Waiting Until Complete Transfer */
       while(GET_BIT(SPSR,SPSR_SPIF)==0);
    23b0:	ee e2       	ldi	r30, 0x2E	; 46
    23b2:	f0 e0       	ldi	r31, 0x00	; 0
    23b4:	80 81       	ld	r24, Z
    23b6:	88 23       	and	r24, r24
    23b8:	dc f7       	brge	.-10     	; 0x23b0 <SPI_u8Transceive+0x14>

   /*Get The Exchanged Data*/
       return SPDR;
    23ba:	ef e2       	ldi	r30, 0x2F	; 47
    23bc:	f0 e0       	ldi	r31, 0x00	; 0
    23be:	80 81       	ld	r24, Z
}
    23c0:	0f 90       	pop	r0
    23c2:	cf 91       	pop	r28
    23c4:	df 91       	pop	r29
    23c6:	08 95       	ret

000023c8 <TIMER0_voidOfInit>:
#include "TIMER_INTERFACE.h"



void TIMER0_voidOfInit(void)
{
    23c8:	df 93       	push	r29
    23ca:	cf 93       	push	r28
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
/*NORMAL MODE WAVEFORM*/
	CLR_BIT(TCCR0,WGM01);
    23d0:	a3 e5       	ldi	r26, 0x53	; 83
    23d2:	b0 e0       	ldi	r27, 0x00	; 0
    23d4:	e3 e5       	ldi	r30, 0x53	; 83
    23d6:	f0 e0       	ldi	r31, 0x00	; 0
    23d8:	80 81       	ld	r24, Z
    23da:	87 7f       	andi	r24, 0xF7	; 247
    23dc:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,WGM00);
    23de:	a3 e5       	ldi	r26, 0x53	; 83
    23e0:	b0 e0       	ldi	r27, 0x00	; 0
    23e2:	e3 e5       	ldi	r30, 0x53	; 83
    23e4:	f0 e0       	ldi	r31, 0x00	; 0
    23e6:	80 81       	ld	r24, Z
    23e8:	8f 7b       	andi	r24, 0xBF	; 191
    23ea:	8c 93       	st	X, r24

	/*PRESCALLER BY 8*/

	CLR_BIT(TCCR0,CS00);
    23ec:	a3 e5       	ldi	r26, 0x53	; 83
    23ee:	b0 e0       	ldi	r27, 0x00	; 0
    23f0:	e3 e5       	ldi	r30, 0x53	; 83
    23f2:	f0 e0       	ldi	r31, 0x00	; 0
    23f4:	80 81       	ld	r24, Z
    23f6:	8e 7f       	andi	r24, 0xFE	; 254
    23f8:	8c 93       	st	X, r24
	SET_BIT(TCCR0,CS01);
    23fa:	a3 e5       	ldi	r26, 0x53	; 83
    23fc:	b0 e0       	ldi	r27, 0x00	; 0
    23fe:	e3 e5       	ldi	r30, 0x53	; 83
    2400:	f0 e0       	ldi	r31, 0x00	; 0
    2402:	80 81       	ld	r24, Z
    2404:	82 60       	ori	r24, 0x02	; 2
    2406:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
    2408:	a3 e5       	ldi	r26, 0x53	; 83
    240a:	b0 e0       	ldi	r27, 0x00	; 0
    240c:	e3 e5       	ldi	r30, 0x53	; 83
    240e:	f0 e0       	ldi	r31, 0x00	; 0
    2410:	80 81       	ld	r24, Z
    2412:	8b 7f       	andi	r24, 0xFB	; 251
    2414:	8c 93       	st	X, r24

	/*ENABLE THE INTERRUPT*/

	SET_BIT(TIMSK,TOIE0);
    2416:	a9 e5       	ldi	r26, 0x59	; 89
    2418:	b0 e0       	ldi	r27, 0x00	; 0
    241a:	e9 e5       	ldi	r30, 0x59	; 89
    241c:	f0 e0       	ldi	r31, 0x00	; 0
    241e:	80 81       	ld	r24, Z
    2420:	81 60       	ori	r24, 0x01	; 1
    2422:	8c 93       	st	X, r24


}
    2424:	cf 91       	pop	r28
    2426:	df 91       	pop	r29
    2428:	08 95       	ret

0000242a <TIMER0_voidCtcInit>:
void TIMER0_voidCtcInit(void)
{
    242a:	df 93       	push	r29
    242c:	cf 93       	push	r28
    242e:	cd b7       	in	r28, 0x3d	; 61
    2430:	de b7       	in	r29, 0x3e	; 62

	/*CTC MODE WAVEFORM*/
		SET_BIT(TCCR0,WGM01);
    2432:	a3 e5       	ldi	r26, 0x53	; 83
    2434:	b0 e0       	ldi	r27, 0x00	; 0
    2436:	e3 e5       	ldi	r30, 0x53	; 83
    2438:	f0 e0       	ldi	r31, 0x00	; 0
    243a:	80 81       	ld	r24, Z
    243c:	88 60       	ori	r24, 0x08	; 8
    243e:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,WGM00);
    2440:	a3 e5       	ldi	r26, 0x53	; 83
    2442:	b0 e0       	ldi	r27, 0x00	; 0
    2444:	e3 e5       	ldi	r30, 0x53	; 83
    2446:	f0 e0       	ldi	r31, 0x00	; 0
    2448:	80 81       	ld	r24, Z
    244a:	8f 7b       	andi	r24, 0xBF	; 191
    244c:	8c 93       	st	X, r24

	/*PRESCALLER BY 64*/

		SET_BIT(TCCR0,CS00);
    244e:	a3 e5       	ldi	r26, 0x53	; 83
    2450:	b0 e0       	ldi	r27, 0x00	; 0
    2452:	e3 e5       	ldi	r30, 0x53	; 83
    2454:	f0 e0       	ldi	r31, 0x00	; 0
    2456:	80 81       	ld	r24, Z
    2458:	81 60       	ori	r24, 0x01	; 1
    245a:	8c 93       	st	X, r24
		SET_BIT(TCCR0,CS01);
    245c:	a3 e5       	ldi	r26, 0x53	; 83
    245e:	b0 e0       	ldi	r27, 0x00	; 0
    2460:	e3 e5       	ldi	r30, 0x53	; 83
    2462:	f0 e0       	ldi	r31, 0x00	; 0
    2464:	80 81       	ld	r24, Z
    2466:	82 60       	ori	r24, 0x02	; 2
    2468:	8c 93       	st	X, r24
		CLR_BIT(TCCR0,CS02);
    246a:	a3 e5       	ldi	r26, 0x53	; 83
    246c:	b0 e0       	ldi	r27, 0x00	; 0
    246e:	e3 e5       	ldi	r30, 0x53	; 83
    2470:	f0 e0       	ldi	r31, 0x00	; 0
    2472:	80 81       	ld	r24, Z
    2474:	8b 7f       	andi	r24, 0xFB	; 251
    2476:	8c 93       	st	X, r24

		/*ENABLE THE INTERRUPT*/

		SET_BIT(TIMSK,OCIE0);
    2478:	a9 e5       	ldi	r26, 0x59	; 89
    247a:	b0 e0       	ldi	r27, 0x00	; 0
    247c:	e9 e5       	ldi	r30, 0x59	; 89
    247e:	f0 e0       	ldi	r31, 0x00	; 0
    2480:	80 81       	ld	r24, Z
    2482:	82 60       	ori	r24, 0x02	; 2
    2484:	8c 93       	st	X, r24
}
    2486:	cf 91       	pop	r28
    2488:	df 91       	pop	r29
    248a:	08 95       	ret

0000248c <TIMER0_voidPWMFastInit>:


void TIMER0_voidPWMFastInit(void)
{
    248c:	df 93       	push	r29
    248e:	cf 93       	push	r28
    2490:	cd b7       	in	r28, 0x3d	; 61
    2492:	de b7       	in	r29, 0x3e	; 62
	/*FAST PMW*/
		SET_BIT(TCCR0,WGM01);
    2494:	a3 e5       	ldi	r26, 0x53	; 83
    2496:	b0 e0       	ldi	r27, 0x00	; 0
    2498:	e3 e5       	ldi	r30, 0x53	; 83
    249a:	f0 e0       	ldi	r31, 0x00	; 0
    249c:	80 81       	ld	r24, Z
    249e:	88 60       	ori	r24, 0x08	; 8
    24a0:	8c 93       	st	X, r24
		SET_BIT(TCCR0,WGM00);
    24a2:	a3 e5       	ldi	r26, 0x53	; 83
    24a4:	b0 e0       	ldi	r27, 0x00	; 0
    24a6:	e3 e5       	ldi	r30, 0x53	; 83
    24a8:	f0 e0       	ldi	r31, 0x00	; 0
    24aa:	80 81       	ld	r24, Z
    24ac:	80 64       	ori	r24, 0x40	; 64
    24ae:	8c 93       	st	X, r24

	/*NON-INVERTED MODE*/

	SET_BIT(TCCR0,COM01);
    24b0:	a3 e5       	ldi	r26, 0x53	; 83
    24b2:	b0 e0       	ldi	r27, 0x00	; 0
    24b4:	e3 e5       	ldi	r30, 0x53	; 83
    24b6:	f0 e0       	ldi	r31, 0x00	; 0
    24b8:	80 81       	ld	r24, Z
    24ba:	80 62       	ori	r24, 0x20	; 32
    24bc:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,COM00);
    24be:	a3 e5       	ldi	r26, 0x53	; 83
    24c0:	b0 e0       	ldi	r27, 0x00	; 0
    24c2:	e3 e5       	ldi	r30, 0x53	; 83
    24c4:	f0 e0       	ldi	r31, 0x00	; 0
    24c6:	80 81       	ld	r24, Z
    24c8:	8f 7e       	andi	r24, 0xEF	; 239
    24ca:	8c 93       	st	X, r24

	/*PRESCALLER BY 8*/
	CLR_BIT(TCCR0,CS00);
    24cc:	a3 e5       	ldi	r26, 0x53	; 83
    24ce:	b0 e0       	ldi	r27, 0x00	; 0
    24d0:	e3 e5       	ldi	r30, 0x53	; 83
    24d2:	f0 e0       	ldi	r31, 0x00	; 0
    24d4:	80 81       	ld	r24, Z
    24d6:	8e 7f       	andi	r24, 0xFE	; 254
    24d8:	8c 93       	st	X, r24
	SET_BIT(TCCR0,CS01);
    24da:	a3 e5       	ldi	r26, 0x53	; 83
    24dc:	b0 e0       	ldi	r27, 0x00	; 0
    24de:	e3 e5       	ldi	r30, 0x53	; 83
    24e0:	f0 e0       	ldi	r31, 0x00	; 0
    24e2:	80 81       	ld	r24, Z
    24e4:	82 60       	ori	r24, 0x02	; 2
    24e6:	8c 93       	st	X, r24
	CLR_BIT(TCCR0,CS02);
    24e8:	a3 e5       	ldi	r26, 0x53	; 83
    24ea:	b0 e0       	ldi	r27, 0x00	; 0
    24ec:	e3 e5       	ldi	r30, 0x53	; 83
    24ee:	f0 e0       	ldi	r31, 0x00	; 0
    24f0:	80 81       	ld	r24, Z
    24f2:	8b 7f       	andi	r24, 0xFB	; 251
    24f4:	8c 93       	st	X, r24
}
    24f6:	cf 91       	pop	r28
    24f8:	df 91       	pop	r29
    24fa:	08 95       	ret

000024fc <TIMER0_voidCtcValue>:


void TIMER0_voidCtcValue(u8 Copy_u8Value)
{
    24fc:	df 93       	push	r29
    24fe:	cf 93       	push	r28
    2500:	0f 92       	push	r0
    2502:	cd b7       	in	r28, 0x3d	; 61
    2504:	de b7       	in	r29, 0x3e	; 62
    2506:	89 83       	std	Y+1, r24	; 0x01
	OCR0=Copy_u8Value;
    2508:	ec e5       	ldi	r30, 0x5C	; 92
    250a:	f0 e0       	ldi	r31, 0x00	; 0
    250c:	89 81       	ldd	r24, Y+1	; 0x01
    250e:	80 83       	st	Z, r24
}
    2510:	0f 90       	pop	r0
    2512:	cf 91       	pop	r28
    2514:	df 91       	pop	r29
    2516:	08 95       	ret

00002518 <TIMER0_voidPreLoadValue>:
void TIMER0_voidPreLoadValue(u8 Copy_u8Value)
{
    2518:	df 93       	push	r29
    251a:	cf 93       	push	r28
    251c:	0f 92       	push	r0
    251e:	cd b7       	in	r28, 0x3d	; 61
    2520:	de b7       	in	r29, 0x3e	; 62
    2522:	89 83       	std	Y+1, r24	; 0x01
	TCNT0=Copy_u8Value;
    2524:	e2 e5       	ldi	r30, 0x52	; 82
    2526:	f0 e0       	ldi	r31, 0x00	; 0
    2528:	89 81       	ldd	r24, Y+1	; 0x01
    252a:	80 83       	st	Z, r24
}
    252c:	0f 90       	pop	r0
    252e:	cf 91       	pop	r28
    2530:	df 91       	pop	r29
    2532:	08 95       	ret

00002534 <TWI_voidMasterInit>:
#include "BIT_MATH.h"
#include "TWI_interface.h"
#include <avr/io.h>

void TWI_voidMasterInit(void)
{
    2534:	df 93       	push	r29
    2536:	cf 93       	push	r28
    2538:	cd b7       	in	r28, 0x3d	; 61
    253a:	de b7       	in	r29, 0x3e	; 62
	/*SCL CLOCK*/
TWBR =255;
    253c:	e0 e2       	ldi	r30, 0x20	; 32
    253e:	f0 e0       	ldi	r31, 0x00	; 0
    2540:	8f ef       	ldi	r24, 0xFF	; 255
    2542:	80 83       	st	Z, r24
CLR_BIT(TWSR,TWPS0);
    2544:	a1 e2       	ldi	r26, 0x21	; 33
    2546:	b0 e0       	ldi	r27, 0x00	; 0
    2548:	e1 e2       	ldi	r30, 0x21	; 33
    254a:	f0 e0       	ldi	r31, 0x00	; 0
    254c:	80 81       	ld	r24, Z
    254e:	8e 7f       	andi	r24, 0xFE	; 254
    2550:	8c 93       	st	X, r24
CLR_BIT(TWSR,TWPS1);
    2552:	a1 e2       	ldi	r26, 0x21	; 33
    2554:	b0 e0       	ldi	r27, 0x00	; 0
    2556:	e1 e2       	ldi	r30, 0x21	; 33
    2558:	f0 e0       	ldi	r31, 0x00	; 0
    255a:	80 81       	ld	r24, Z
    255c:	8d 7f       	andi	r24, 0xFD	; 253
    255e:	8c 93       	st	X, r24
/*ENABLE*/
TWCR=(1<<TWEN);
    2560:	e6 e5       	ldi	r30, 0x56	; 86
    2562:	f0 e0       	ldi	r31, 0x00	; 0
    2564:	84 e0       	ldi	r24, 0x04	; 4
    2566:	80 83       	st	Z, r24
}
    2568:	cf 91       	pop	r28
    256a:	df 91       	pop	r29
    256c:	08 95       	ret

0000256e <TWI_voidStartCondition>:
void TWI_voidStartCondition(void)
{
    256e:	df 93       	push	r29
    2570:	cf 93       	push	r28
    2572:	cd b7       	in	r28, 0x3d	; 61
    2574:	de b7       	in	r29, 0x3e	; 62
TWCR=(1<<TWSTA)|(1<<TWEN)|(1<<TWINT);
    2576:	e6 e5       	ldi	r30, 0x56	; 86
    2578:	f0 e0       	ldi	r31, 0x00	; 0
    257a:	84 ea       	ldi	r24, 0xA4	; 164
    257c:	80 83       	st	Z, r24
while(GET_BIT(TWCR,TWINT)==0);
    257e:	e6 e5       	ldi	r30, 0x56	; 86
    2580:	f0 e0       	ldi	r31, 0x00	; 0
    2582:	80 81       	ld	r24, Z
    2584:	88 23       	and	r24, r24
    2586:	dc f7       	brge	.-10     	; 0x257e <TWI_voidStartCondition+0x10>
}
    2588:	cf 91       	pop	r28
    258a:	df 91       	pop	r29
    258c:	08 95       	ret

0000258e <TWI_voidStopCondition>:
void TWI_voidStopCondition(void)
{
    258e:	df 93       	push	r29
    2590:	cf 93       	push	r28
    2592:	cd b7       	in	r28, 0x3d	; 61
    2594:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWSTO)|(1<<TWEN)|(1<<TWINT);
    2596:	e6 e5       	ldi	r30, 0x56	; 86
    2598:	f0 e0       	ldi	r31, 0x00	; 0
    259a:	84 e9       	ldi	r24, 0x94	; 148
    259c:	80 83       	st	Z, r24
}
    259e:	cf 91       	pop	r28
    25a0:	df 91       	pop	r29
    25a2:	08 95       	ret

000025a4 <TWI_voidSendData>:
void TWI_voidSendData(u8 Copy_u8Data)
{
    25a4:	df 93       	push	r29
    25a6:	cf 93       	push	r28
    25a8:	0f 92       	push	r0
    25aa:	cd b7       	in	r28, 0x3d	; 61
    25ac:	de b7       	in	r29, 0x3e	; 62
    25ae:	89 83       	std	Y+1, r24	; 0x01
TWDR=Copy_u8Data;
    25b0:	e3 e2       	ldi	r30, 0x23	; 35
    25b2:	f0 e0       	ldi	r31, 0x00	; 0
    25b4:	89 81       	ldd	r24, Y+1	; 0x01
    25b6:	80 83       	st	Z, r24
TWCR=(1<<TWEN)|(1<<TWINT);
    25b8:	e6 e5       	ldi	r30, 0x56	; 86
    25ba:	f0 e0       	ldi	r31, 0x00	; 0
    25bc:	84 e8       	ldi	r24, 0x84	; 132
    25be:	80 83       	st	Z, r24
while(GET_BIT(TWCR,TWINT)==0);
    25c0:	e6 e5       	ldi	r30, 0x56	; 86
    25c2:	f0 e0       	ldi	r31, 0x00	; 0
    25c4:	80 81       	ld	r24, Z
    25c6:	88 23       	and	r24, r24
    25c8:	dc f7       	brge	.-10     	; 0x25c0 <TWI_voidSendData+0x1c>
}
    25ca:	0f 90       	pop	r0
    25cc:	cf 91       	pop	r28
    25ce:	df 91       	pop	r29
    25d0:	08 95       	ret

000025d2 <TWI_u8ReceiveData>:
u8 TWI_u8ReceiveData(void)
{
    25d2:	df 93       	push	r29
    25d4:	cf 93       	push	r28
    25d6:	cd b7       	in	r28, 0x3d	; 61
    25d8:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWEN)|(1<<TWINT);
    25da:	e6 e5       	ldi	r30, 0x56	; 86
    25dc:	f0 e0       	ldi	r31, 0x00	; 0
    25de:	84 e8       	ldi	r24, 0x84	; 132
    25e0:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,TWINT)==0);
    25e2:	e6 e5       	ldi	r30, 0x56	; 86
    25e4:	f0 e0       	ldi	r31, 0x00	; 0
    25e6:	80 81       	ld	r24, Z
    25e8:	88 23       	and	r24, r24
    25ea:	dc f7       	brge	.-10     	; 0x25e2 <TWI_u8ReceiveData+0x10>
return TWDR;
    25ec:	e3 e2       	ldi	r30, 0x23	; 35
    25ee:	f0 e0       	ldi	r31, 0x00	; 0
    25f0:	80 81       	ld	r24, Z
}
    25f2:	cf 91       	pop	r28
    25f4:	df 91       	pop	r29
    25f6:	08 95       	ret

000025f8 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    25f8:	df 93       	push	r29
    25fa:	cf 93       	push	r28
    25fc:	cd b7       	in	r28, 0x3d	; 61
    25fe:	de b7       	in	r29, 0x3e	; 62
    2600:	27 97       	sbiw	r28, 0x07	; 7
    2602:	0f b6       	in	r0, 0x3f	; 63
    2604:	f8 94       	cli
    2606:	de bf       	out	0x3e, r29	; 62
    2608:	0f be       	out	0x3f, r0	; 63
    260a:	cd bf       	out	0x3d, r28	; 61
    260c:	9d 83       	std	Y+5, r25	; 0x05
    260e:	8c 83       	std	Y+4, r24	; 0x04
    2610:	6e 83       	std	Y+6, r22	; 0x06
    2612:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    2614:	8a e1       	ldi	r24, 0x1A	; 26
    2616:	90 e0       	ldi	r25, 0x00	; 0
    2618:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <pvPortMalloc>
    261c:	9a 83       	std	Y+2, r25	; 0x02
    261e:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
    2620:	89 81       	ldd	r24, Y+1	; 0x01
    2622:	9a 81       	ldd	r25, Y+2	; 0x02
    2624:	00 97       	sbiw	r24, 0x00	; 0
    2626:	09 f4       	brne	.+2      	; 0x262a <xCoRoutineCreate+0x32>
    2628:	6f c0       	rjmp	.+222    	; 0x2708 <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    262a:	80 91 3e 01 	lds	r24, 0x013E
    262e:	90 91 3f 01 	lds	r25, 0x013F
    2632:	00 97       	sbiw	r24, 0x00	; 0
    2634:	41 f4       	brne	.+16     	; 0x2646 <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    2636:	89 81       	ldd	r24, Y+1	; 0x01
    2638:	9a 81       	ldd	r25, Y+2	; 0x02
    263a:	90 93 3f 01 	sts	0x013F, r25
    263e:	80 93 3e 01 	sts	0x013E, r24
			prvInitialiseCoRoutineLists();
    2642:	0e 94 63 15 	call	0x2ac6	; 0x2ac6 <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
    2646:	8e 81       	ldd	r24, Y+6	; 0x06
    2648:	82 30       	cpi	r24, 0x02	; 2
    264a:	10 f0       	brcs	.+4      	; 0x2650 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    2650:	e9 81       	ldd	r30, Y+1	; 0x01
    2652:	fa 81       	ldd	r31, Y+2	; 0x02
    2654:	11 8e       	std	Z+25, r1	; 0x19
    2656:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    2658:	e9 81       	ldd	r30, Y+1	; 0x01
    265a:	fa 81       	ldd	r31, Y+2	; 0x02
    265c:	8e 81       	ldd	r24, Y+6	; 0x06
    265e:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    2660:	e9 81       	ldd	r30, Y+1	; 0x01
    2662:	fa 81       	ldd	r31, Y+2	; 0x02
    2664:	8f 81       	ldd	r24, Y+7	; 0x07
    2666:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    2668:	e9 81       	ldd	r30, Y+1	; 0x01
    266a:	fa 81       	ldd	r31, Y+2	; 0x02
    266c:	8c 81       	ldd	r24, Y+4	; 0x04
    266e:	9d 81       	ldd	r25, Y+5	; 0x05
    2670:	91 83       	std	Z+1, r25	; 0x01
    2672:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    2674:	89 81       	ldd	r24, Y+1	; 0x01
    2676:	9a 81       	ldd	r25, Y+2	; 0x02
    2678:	02 96       	adiw	r24, 0x02	; 2
    267a:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    267e:	89 81       	ldd	r24, Y+1	; 0x01
    2680:	9a 81       	ldd	r25, Y+2	; 0x02
    2682:	0c 96       	adiw	r24, 0x0c	; 12
    2684:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    2688:	e9 81       	ldd	r30, Y+1	; 0x01
    268a:	fa 81       	ldd	r31, Y+2	; 0x02
    268c:	89 81       	ldd	r24, Y+1	; 0x01
    268e:	9a 81       	ldd	r25, Y+2	; 0x02
    2690:	91 87       	std	Z+9, r25	; 0x09
    2692:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    2694:	e9 81       	ldd	r30, Y+1	; 0x01
    2696:	fa 81       	ldd	r31, Y+2	; 0x02
    2698:	89 81       	ldd	r24, Y+1	; 0x01
    269a:	9a 81       	ldd	r25, Y+2	; 0x02
    269c:	93 8b       	std	Z+19, r25	; 0x13
    269e:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    26a0:	8e 81       	ldd	r24, Y+6	; 0x06
    26a2:	28 2f       	mov	r18, r24
    26a4:	30 e0       	ldi	r19, 0x00	; 0
    26a6:	85 e0       	ldi	r24, 0x05	; 5
    26a8:	90 e0       	ldi	r25, 0x00	; 0
    26aa:	82 1b       	sub	r24, r18
    26ac:	93 0b       	sbc	r25, r19
    26ae:	e9 81       	ldd	r30, Y+1	; 0x01
    26b0:	fa 81       	ldd	r31, Y+2	; 0x02
    26b2:	95 87       	std	Z+13, r25	; 0x0d
    26b4:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    26b6:	e9 81       	ldd	r30, Y+1	; 0x01
    26b8:	fa 81       	ldd	r31, Y+2	; 0x02
    26ba:	96 89       	ldd	r25, Z+22	; 0x16
    26bc:	80 91 40 01 	lds	r24, 0x0140
    26c0:	89 17       	cp	r24, r25
    26c2:	28 f4       	brcc	.+10     	; 0x26ce <xCoRoutineCreate+0xd6>
    26c4:	e9 81       	ldd	r30, Y+1	; 0x01
    26c6:	fa 81       	ldd	r31, Y+2	; 0x02
    26c8:	86 89       	ldd	r24, Z+22	; 0x16
    26ca:	80 93 40 01 	sts	0x0140, r24
    26ce:	e9 81       	ldd	r30, Y+1	; 0x01
    26d0:	fa 81       	ldd	r31, Y+2	; 0x02
    26d2:	86 89       	ldd	r24, Z+22	; 0x16
    26d4:	28 2f       	mov	r18, r24
    26d6:	30 e0       	ldi	r19, 0x00	; 0
    26d8:	c9 01       	movw	r24, r18
    26da:	88 0f       	add	r24, r24
    26dc:	99 1f       	adc	r25, r25
    26de:	88 0f       	add	r24, r24
    26e0:	99 1f       	adc	r25, r25
    26e2:	88 0f       	add	r24, r24
    26e4:	99 1f       	adc	r25, r25
    26e6:	82 0f       	add	r24, r18
    26e8:	93 1f       	adc	r25, r19
    26ea:	ac 01       	movw	r20, r24
    26ec:	49 5b       	subi	r20, 0xB9	; 185
    26ee:	5e 4f       	sbci	r21, 0xFE	; 254
    26f0:	89 81       	ldd	r24, Y+1	; 0x01
    26f2:	9a 81       	ldd	r25, Y+2	; 0x02
    26f4:	9c 01       	movw	r18, r24
    26f6:	2e 5f       	subi	r18, 0xFE	; 254
    26f8:	3f 4f       	sbci	r19, 0xFF	; 255
    26fa:	ca 01       	movw	r24, r20
    26fc:	b9 01       	movw	r22, r18
    26fe:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>

		xReturn = pdPASS;
    2702:	81 e0       	ldi	r24, 0x01	; 1
    2704:	8b 83       	std	Y+3, r24	; 0x03
    2706:	02 c0       	rjmp	.+4      	; 0x270c <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    2708:	8f ef       	ldi	r24, 0xFF	; 255
    270a:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
    270c:	8b 81       	ldd	r24, Y+3	; 0x03
}
    270e:	27 96       	adiw	r28, 0x07	; 7
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	de bf       	out	0x3e, r29	; 62
    2716:	0f be       	out	0x3f, r0	; 63
    2718:	cd bf       	out	0x3d, r28	; 61
    271a:	cf 91       	pop	r28
    271c:	df 91       	pop	r29
    271e:	08 95       	ret

00002720 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    2720:	df 93       	push	r29
    2722:	cf 93       	push	r28
    2724:	00 d0       	rcall	.+0      	; 0x2726 <vCoRoutineAddToDelayedList+0x6>
    2726:	00 d0       	rcall	.+0      	; 0x2728 <vCoRoutineAddToDelayedList+0x8>
    2728:	00 d0       	rcall	.+0      	; 0x272a <vCoRoutineAddToDelayedList+0xa>
    272a:	cd b7       	in	r28, 0x3d	; 61
    272c:	de b7       	in	r29, 0x3e	; 62
    272e:	9c 83       	std	Y+4, r25	; 0x04
    2730:	8b 83       	std	Y+3, r24	; 0x03
    2732:	7e 83       	std	Y+6, r23	; 0x06
    2734:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    2736:	20 91 41 01 	lds	r18, 0x0141
    273a:	30 91 42 01 	lds	r19, 0x0142
    273e:	8b 81       	ldd	r24, Y+3	; 0x03
    2740:	9c 81       	ldd	r25, Y+4	; 0x04
    2742:	82 0f       	add	r24, r18
    2744:	93 1f       	adc	r25, r19
    2746:	9a 83       	std	Y+2, r25	; 0x02
    2748:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    274a:	80 91 3e 01 	lds	r24, 0x013E
    274e:	90 91 3f 01 	lds	r25, 0x013F
    2752:	02 96       	adiw	r24, 0x02	; 2
    2754:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    2758:	e0 91 3e 01 	lds	r30, 0x013E
    275c:	f0 91 3f 01 	lds	r31, 0x013F
    2760:	89 81       	ldd	r24, Y+1	; 0x01
    2762:	9a 81       	ldd	r25, Y+2	; 0x02
    2764:	93 83       	std	Z+3, r25	; 0x03
    2766:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    2768:	20 91 41 01 	lds	r18, 0x0141
    276c:	30 91 42 01 	lds	r19, 0x0142
    2770:	89 81       	ldd	r24, Y+1	; 0x01
    2772:	9a 81       	ldd	r25, Y+2	; 0x02
    2774:	82 17       	cp	r24, r18
    2776:	93 07       	cpc	r25, r19
    2778:	70 f4       	brcc	.+28     	; 0x2796 <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    277a:	80 91 6d 01 	lds	r24, 0x016D
    277e:	90 91 6e 01 	lds	r25, 0x016E
    2782:	20 91 3e 01 	lds	r18, 0x013E
    2786:	30 91 3f 01 	lds	r19, 0x013F
    278a:	2e 5f       	subi	r18, 0xFE	; 254
    278c:	3f 4f       	sbci	r19, 0xFF	; 255
    278e:	b9 01       	movw	r22, r18
    2790:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>
    2794:	0d c0       	rjmp	.+26     	; 0x27b0 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    2796:	80 91 6b 01 	lds	r24, 0x016B
    279a:	90 91 6c 01 	lds	r25, 0x016C
    279e:	20 91 3e 01 	lds	r18, 0x013E
    27a2:	30 91 3f 01 	lds	r19, 0x013F
    27a6:	2e 5f       	subi	r18, 0xFE	; 254
    27a8:	3f 4f       	sbci	r19, 0xFF	; 255
    27aa:	b9 01       	movw	r22, r18
    27ac:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>
	}

	if( pxEventList )
    27b0:	8d 81       	ldd	r24, Y+5	; 0x05
    27b2:	9e 81       	ldd	r25, Y+6	; 0x06
    27b4:	00 97       	sbiw	r24, 0x00	; 0
    27b6:	61 f0       	breq	.+24     	; 0x27d0 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    27b8:	80 91 3e 01 	lds	r24, 0x013E
    27bc:	90 91 3f 01 	lds	r25, 0x013F
    27c0:	9c 01       	movw	r18, r24
    27c2:	24 5f       	subi	r18, 0xF4	; 244
    27c4:	3f 4f       	sbci	r19, 0xFF	; 255
    27c6:	8d 81       	ldd	r24, Y+5	; 0x05
    27c8:	9e 81       	ldd	r25, Y+6	; 0x06
    27ca:	b9 01       	movw	r22, r18
    27cc:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>
	}
}
    27d0:	26 96       	adiw	r28, 0x06	; 6
    27d2:	0f b6       	in	r0, 0x3f	; 63
    27d4:	f8 94       	cli
    27d6:	de bf       	out	0x3e, r29	; 62
    27d8:	0f be       	out	0x3f, r0	; 63
    27da:	cd bf       	out	0x3d, r28	; 61
    27dc:	cf 91       	pop	r28
    27de:	df 91       	pop	r29
    27e0:	08 95       	ret

000027e2 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    27e2:	df 93       	push	r29
    27e4:	cf 93       	push	r28
    27e6:	00 d0       	rcall	.+0      	; 0x27e8 <prvCheckPendingReadyList+0x6>
    27e8:	cd b7       	in	r28, 0x3d	; 61
    27ea:	de b7       	in	r29, 0x3e	; 62
    27ec:	3a c0       	rjmp	.+116    	; 0x2862 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    27ee:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    27f0:	e0 91 74 01 	lds	r30, 0x0174
    27f4:	f0 91 75 01 	lds	r31, 0x0175
    27f8:	86 81       	ldd	r24, Z+6	; 0x06
    27fa:	97 81       	ldd	r25, Z+7	; 0x07
    27fc:	9a 83       	std	Y+2, r25	; 0x02
    27fe:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2800:	89 81       	ldd	r24, Y+1	; 0x01
    2802:	9a 81       	ldd	r25, Y+2	; 0x02
    2804:	0c 96       	adiw	r24, 0x0c	; 12
    2806:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
		}
		portENABLE_INTERRUPTS();
    280a:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    280c:	89 81       	ldd	r24, Y+1	; 0x01
    280e:	9a 81       	ldd	r25, Y+2	; 0x02
    2810:	02 96       	adiw	r24, 0x02	; 2
    2812:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    2816:	e9 81       	ldd	r30, Y+1	; 0x01
    2818:	fa 81       	ldd	r31, Y+2	; 0x02
    281a:	96 89       	ldd	r25, Z+22	; 0x16
    281c:	80 91 40 01 	lds	r24, 0x0140
    2820:	89 17       	cp	r24, r25
    2822:	28 f4       	brcc	.+10     	; 0x282e <prvCheckPendingReadyList+0x4c>
    2824:	e9 81       	ldd	r30, Y+1	; 0x01
    2826:	fa 81       	ldd	r31, Y+2	; 0x02
    2828:	86 89       	ldd	r24, Z+22	; 0x16
    282a:	80 93 40 01 	sts	0x0140, r24
    282e:	e9 81       	ldd	r30, Y+1	; 0x01
    2830:	fa 81       	ldd	r31, Y+2	; 0x02
    2832:	86 89       	ldd	r24, Z+22	; 0x16
    2834:	28 2f       	mov	r18, r24
    2836:	30 e0       	ldi	r19, 0x00	; 0
    2838:	c9 01       	movw	r24, r18
    283a:	88 0f       	add	r24, r24
    283c:	99 1f       	adc	r25, r25
    283e:	88 0f       	add	r24, r24
    2840:	99 1f       	adc	r25, r25
    2842:	88 0f       	add	r24, r24
    2844:	99 1f       	adc	r25, r25
    2846:	82 0f       	add	r24, r18
    2848:	93 1f       	adc	r25, r19
    284a:	ac 01       	movw	r20, r24
    284c:	49 5b       	subi	r20, 0xB9	; 185
    284e:	5e 4f       	sbci	r21, 0xFE	; 254
    2850:	89 81       	ldd	r24, Y+1	; 0x01
    2852:	9a 81       	ldd	r25, Y+2	; 0x02
    2854:	9c 01       	movw	r18, r24
    2856:	2e 5f       	subi	r18, 0xFE	; 254
    2858:	3f 4f       	sbci	r19, 0xFF	; 255
    285a:	ca 01       	movw	r24, r20
    285c:	b9 01       	movw	r22, r18
    285e:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    2862:	80 91 6f 01 	lds	r24, 0x016F
    2866:	88 23       	and	r24, r24
    2868:	09 f0       	breq	.+2      	; 0x286c <prvCheckPendingReadyList+0x8a>
    286a:	c1 cf       	rjmp	.-126    	; 0x27ee <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    286c:	0f 90       	pop	r0
    286e:	0f 90       	pop	r0
    2870:	cf 91       	pop	r28
    2872:	df 91       	pop	r29
    2874:	08 95       	ret

00002876 <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    2876:	df 93       	push	r29
    2878:	cf 93       	push	r28
    287a:	00 d0       	rcall	.+0      	; 0x287c <prvCheckDelayedList+0x6>
    287c:	00 d0       	rcall	.+0      	; 0x287e <prvCheckDelayedList+0x8>
    287e:	cd b7       	in	r28, 0x3d	; 61
    2880:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    2882:	0e 94 93 25 	call	0x4b26	; 0x4b26 <xTaskGetTickCount>
    2886:	20 91 43 01 	lds	r18, 0x0143
    288a:	30 91 44 01 	lds	r19, 0x0144
    288e:	82 1b       	sub	r24, r18
    2890:	93 0b       	sbc	r25, r19
    2892:	90 93 46 01 	sts	0x0146, r25
    2896:	80 93 45 01 	sts	0x0145, r24
    289a:	85 c0       	rjmp	.+266    	; 0x29a6 <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    289c:	80 91 41 01 	lds	r24, 0x0141
    28a0:	90 91 42 01 	lds	r25, 0x0142
    28a4:	01 96       	adiw	r24, 0x01	; 1
    28a6:	90 93 42 01 	sts	0x0142, r25
    28aa:	80 93 41 01 	sts	0x0141, r24
		xPassedTicks--;
    28ae:	80 91 45 01 	lds	r24, 0x0145
    28b2:	90 91 46 01 	lds	r25, 0x0146
    28b6:	01 97       	sbiw	r24, 0x01	; 1
    28b8:	90 93 46 01 	sts	0x0146, r25
    28bc:	80 93 45 01 	sts	0x0145, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    28c0:	80 91 41 01 	lds	r24, 0x0141
    28c4:	90 91 42 01 	lds	r25, 0x0142
    28c8:	00 97       	sbiw	r24, 0x00	; 0
    28ca:	09 f0       	breq	.+2      	; 0x28ce <prvCheckDelayedList+0x58>
    28cc:	64 c0       	rjmp	.+200    	; 0x2996 <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    28ce:	80 91 6b 01 	lds	r24, 0x016B
    28d2:	90 91 6c 01 	lds	r25, 0x016C
    28d6:	9a 83       	std	Y+2, r25	; 0x02
    28d8:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    28da:	80 91 6d 01 	lds	r24, 0x016D
    28de:	90 91 6e 01 	lds	r25, 0x016E
    28e2:	90 93 6c 01 	sts	0x016C, r25
    28e6:	80 93 6b 01 	sts	0x016B, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    28ea:	89 81       	ldd	r24, Y+1	; 0x01
    28ec:	9a 81       	ldd	r25, Y+2	; 0x02
    28ee:	90 93 6e 01 	sts	0x016E, r25
    28f2:	80 93 6d 01 	sts	0x016D, r24
    28f6:	4f c0       	rjmp	.+158    	; 0x2996 <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    28f8:	e0 91 6b 01 	lds	r30, 0x016B
    28fc:	f0 91 6c 01 	lds	r31, 0x016C
    2900:	05 80       	ldd	r0, Z+5	; 0x05
    2902:	f6 81       	ldd	r31, Z+6	; 0x06
    2904:	e0 2d       	mov	r30, r0
    2906:	86 81       	ldd	r24, Z+6	; 0x06
    2908:	97 81       	ldd	r25, Z+7	; 0x07
    290a:	9c 83       	std	Y+4, r25	; 0x04
    290c:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    290e:	eb 81       	ldd	r30, Y+3	; 0x03
    2910:	fc 81       	ldd	r31, Y+4	; 0x04
    2912:	22 81       	ldd	r18, Z+2	; 0x02
    2914:	33 81       	ldd	r19, Z+3	; 0x03
    2916:	80 91 41 01 	lds	r24, 0x0141
    291a:	90 91 42 01 	lds	r25, 0x0142
    291e:	82 17       	cp	r24, r18
    2920:	93 07       	cpc	r25, r19
    2922:	08 f4       	brcc	.+2      	; 0x2926 <prvCheckDelayedList+0xb0>
    2924:	40 c0       	rjmp	.+128    	; 0x29a6 <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    2926:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    2928:	8b 81       	ldd	r24, Y+3	; 0x03
    292a:	9c 81       	ldd	r25, Y+4	; 0x04
    292c:	02 96       	adiw	r24, 0x02	; 2
    292e:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    2932:	eb 81       	ldd	r30, Y+3	; 0x03
    2934:	fc 81       	ldd	r31, Y+4	; 0x04
    2936:	84 89       	ldd	r24, Z+20	; 0x14
    2938:	95 89       	ldd	r25, Z+21	; 0x15
    293a:	00 97       	sbiw	r24, 0x00	; 0
    293c:	29 f0       	breq	.+10     	; 0x2948 <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    293e:	8b 81       	ldd	r24, Y+3	; 0x03
    2940:	9c 81       	ldd	r25, Y+4	; 0x04
    2942:	0c 96       	adiw	r24, 0x0c	; 12
    2944:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    2948:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    294a:	eb 81       	ldd	r30, Y+3	; 0x03
    294c:	fc 81       	ldd	r31, Y+4	; 0x04
    294e:	96 89       	ldd	r25, Z+22	; 0x16
    2950:	80 91 40 01 	lds	r24, 0x0140
    2954:	89 17       	cp	r24, r25
    2956:	28 f4       	brcc	.+10     	; 0x2962 <prvCheckDelayedList+0xec>
    2958:	eb 81       	ldd	r30, Y+3	; 0x03
    295a:	fc 81       	ldd	r31, Y+4	; 0x04
    295c:	86 89       	ldd	r24, Z+22	; 0x16
    295e:	80 93 40 01 	sts	0x0140, r24
    2962:	eb 81       	ldd	r30, Y+3	; 0x03
    2964:	fc 81       	ldd	r31, Y+4	; 0x04
    2966:	86 89       	ldd	r24, Z+22	; 0x16
    2968:	28 2f       	mov	r18, r24
    296a:	30 e0       	ldi	r19, 0x00	; 0
    296c:	c9 01       	movw	r24, r18
    296e:	88 0f       	add	r24, r24
    2970:	99 1f       	adc	r25, r25
    2972:	88 0f       	add	r24, r24
    2974:	99 1f       	adc	r25, r25
    2976:	88 0f       	add	r24, r24
    2978:	99 1f       	adc	r25, r25
    297a:	82 0f       	add	r24, r18
    297c:	93 1f       	adc	r25, r19
    297e:	ac 01       	movw	r20, r24
    2980:	49 5b       	subi	r20, 0xB9	; 185
    2982:	5e 4f       	sbci	r21, 0xFE	; 254
    2984:	8b 81       	ldd	r24, Y+3	; 0x03
    2986:	9c 81       	ldd	r25, Y+4	; 0x04
    2988:	9c 01       	movw	r18, r24
    298a:	2e 5f       	subi	r18, 0xFE	; 254
    298c:	3f 4f       	sbci	r19, 0xFF	; 255
    298e:	ca 01       	movw	r24, r20
    2990:	b9 01       	movw	r22, r18
    2992:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    2996:	e0 91 6b 01 	lds	r30, 0x016B
    299a:	f0 91 6c 01 	lds	r31, 0x016C
    299e:	80 81       	ld	r24, Z
    29a0:	88 23       	and	r24, r24
    29a2:	09 f0       	breq	.+2      	; 0x29a6 <prvCheckDelayedList+0x130>
    29a4:	a9 cf       	rjmp	.-174    	; 0x28f8 <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    29a6:	80 91 45 01 	lds	r24, 0x0145
    29aa:	90 91 46 01 	lds	r25, 0x0146
    29ae:	00 97       	sbiw	r24, 0x00	; 0
    29b0:	09 f0       	breq	.+2      	; 0x29b4 <prvCheckDelayedList+0x13e>
    29b2:	74 cf       	rjmp	.-280    	; 0x289c <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    29b4:	80 91 41 01 	lds	r24, 0x0141
    29b8:	90 91 42 01 	lds	r25, 0x0142
    29bc:	90 93 44 01 	sts	0x0144, r25
    29c0:	80 93 43 01 	sts	0x0143, r24
}
    29c4:	0f 90       	pop	r0
    29c6:	0f 90       	pop	r0
    29c8:	0f 90       	pop	r0
    29ca:	0f 90       	pop	r0
    29cc:	cf 91       	pop	r28
    29ce:	df 91       	pop	r29
    29d0:	08 95       	ret

000029d2 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    29d2:	df 93       	push	r29
    29d4:	cf 93       	push	r28
    29d6:	00 d0       	rcall	.+0      	; 0x29d8 <vCoRoutineSchedule+0x6>
    29d8:	cd b7       	in	r28, 0x3d	; 61
    29da:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    29dc:	0e 94 f1 13 	call	0x27e2	; 0x27e2 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    29e0:	0e 94 3b 14 	call	0x2876	; 0x2876 <prvCheckDelayedList>
    29e4:	0a c0       	rjmp	.+20     	; 0x29fa <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    29e6:	80 91 40 01 	lds	r24, 0x0140
    29ea:	88 23       	and	r24, r24
    29ec:	09 f4       	brne	.+2      	; 0x29f0 <vCoRoutineSchedule+0x1e>
    29ee:	66 c0       	rjmp	.+204    	; 0x2abc <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    29f0:	80 91 40 01 	lds	r24, 0x0140
    29f4:	81 50       	subi	r24, 0x01	; 1
    29f6:	80 93 40 01 	sts	0x0140, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    29fa:	80 91 40 01 	lds	r24, 0x0140
    29fe:	28 2f       	mov	r18, r24
    2a00:	30 e0       	ldi	r19, 0x00	; 0
    2a02:	c9 01       	movw	r24, r18
    2a04:	88 0f       	add	r24, r24
    2a06:	99 1f       	adc	r25, r25
    2a08:	88 0f       	add	r24, r24
    2a0a:	99 1f       	adc	r25, r25
    2a0c:	88 0f       	add	r24, r24
    2a0e:	99 1f       	adc	r25, r25
    2a10:	82 0f       	add	r24, r18
    2a12:	93 1f       	adc	r25, r19
    2a14:	fc 01       	movw	r30, r24
    2a16:	e9 5b       	subi	r30, 0xB9	; 185
    2a18:	fe 4f       	sbci	r31, 0xFE	; 254
    2a1a:	80 81       	ld	r24, Z
    2a1c:	88 23       	and	r24, r24
    2a1e:	19 f3       	breq	.-58     	; 0x29e6 <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    2a20:	80 91 40 01 	lds	r24, 0x0140
    2a24:	28 2f       	mov	r18, r24
    2a26:	30 e0       	ldi	r19, 0x00	; 0
    2a28:	c9 01       	movw	r24, r18
    2a2a:	88 0f       	add	r24, r24
    2a2c:	99 1f       	adc	r25, r25
    2a2e:	88 0f       	add	r24, r24
    2a30:	99 1f       	adc	r25, r25
    2a32:	88 0f       	add	r24, r24
    2a34:	99 1f       	adc	r25, r25
    2a36:	82 0f       	add	r24, r18
    2a38:	93 1f       	adc	r25, r19
    2a3a:	89 5b       	subi	r24, 0xB9	; 185
    2a3c:	9e 4f       	sbci	r25, 0xFE	; 254
    2a3e:	9a 83       	std	Y+2, r25	; 0x02
    2a40:	89 83       	std	Y+1, r24	; 0x01
    2a42:	e9 81       	ldd	r30, Y+1	; 0x01
    2a44:	fa 81       	ldd	r31, Y+2	; 0x02
    2a46:	01 80       	ldd	r0, Z+1	; 0x01
    2a48:	f2 81       	ldd	r31, Z+2	; 0x02
    2a4a:	e0 2d       	mov	r30, r0
    2a4c:	82 81       	ldd	r24, Z+2	; 0x02
    2a4e:	93 81       	ldd	r25, Z+3	; 0x03
    2a50:	e9 81       	ldd	r30, Y+1	; 0x01
    2a52:	fa 81       	ldd	r31, Y+2	; 0x02
    2a54:	92 83       	std	Z+2, r25	; 0x02
    2a56:	81 83       	std	Z+1, r24	; 0x01
    2a58:	e9 81       	ldd	r30, Y+1	; 0x01
    2a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    2a5c:	21 81       	ldd	r18, Z+1	; 0x01
    2a5e:	32 81       	ldd	r19, Z+2	; 0x02
    2a60:	89 81       	ldd	r24, Y+1	; 0x01
    2a62:	9a 81       	ldd	r25, Y+2	; 0x02
    2a64:	03 96       	adiw	r24, 0x03	; 3
    2a66:	28 17       	cp	r18, r24
    2a68:	39 07       	cpc	r19, r25
    2a6a:	59 f4       	brne	.+22     	; 0x2a82 <vCoRoutineSchedule+0xb0>
    2a6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2a6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2a70:	01 80       	ldd	r0, Z+1	; 0x01
    2a72:	f2 81       	ldd	r31, Z+2	; 0x02
    2a74:	e0 2d       	mov	r30, r0
    2a76:	82 81       	ldd	r24, Z+2	; 0x02
    2a78:	93 81       	ldd	r25, Z+3	; 0x03
    2a7a:	e9 81       	ldd	r30, Y+1	; 0x01
    2a7c:	fa 81       	ldd	r31, Y+2	; 0x02
    2a7e:	92 83       	std	Z+2, r25	; 0x02
    2a80:	81 83       	std	Z+1, r24	; 0x01
    2a82:	e9 81       	ldd	r30, Y+1	; 0x01
    2a84:	fa 81       	ldd	r31, Y+2	; 0x02
    2a86:	01 80       	ldd	r0, Z+1	; 0x01
    2a88:	f2 81       	ldd	r31, Z+2	; 0x02
    2a8a:	e0 2d       	mov	r30, r0
    2a8c:	86 81       	ldd	r24, Z+6	; 0x06
    2a8e:	97 81       	ldd	r25, Z+7	; 0x07
    2a90:	90 93 3f 01 	sts	0x013F, r25
    2a94:	80 93 3e 01 	sts	0x013E, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    2a98:	e0 91 3e 01 	lds	r30, 0x013E
    2a9c:	f0 91 3f 01 	lds	r31, 0x013F
    2aa0:	40 81       	ld	r20, Z
    2aa2:	51 81       	ldd	r21, Z+1	; 0x01
    2aa4:	80 91 3e 01 	lds	r24, 0x013E
    2aa8:	90 91 3f 01 	lds	r25, 0x013F
    2aac:	e0 91 3e 01 	lds	r30, 0x013E
    2ab0:	f0 91 3f 01 	lds	r31, 0x013F
    2ab4:	27 89       	ldd	r18, Z+23	; 0x17
    2ab6:	62 2f       	mov	r22, r18
    2ab8:	fa 01       	movw	r30, r20
    2aba:	09 95       	icall

	return;
}
    2abc:	0f 90       	pop	r0
    2abe:	0f 90       	pop	r0
    2ac0:	cf 91       	pop	r28
    2ac2:	df 91       	pop	r29
    2ac4:	08 95       	ret

00002ac6 <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    2ac6:	df 93       	push	r29
    2ac8:	cf 93       	push	r28
    2aca:	0f 92       	push	r0
    2acc:	cd b7       	in	r28, 0x3d	; 61
    2ace:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2ad0:	19 82       	std	Y+1, r1	; 0x01
    2ad2:	13 c0       	rjmp	.+38     	; 0x2afa <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    2ad4:	89 81       	ldd	r24, Y+1	; 0x01
    2ad6:	28 2f       	mov	r18, r24
    2ad8:	30 e0       	ldi	r19, 0x00	; 0
    2ada:	c9 01       	movw	r24, r18
    2adc:	88 0f       	add	r24, r24
    2ade:	99 1f       	adc	r25, r25
    2ae0:	88 0f       	add	r24, r24
    2ae2:	99 1f       	adc	r25, r25
    2ae4:	88 0f       	add	r24, r24
    2ae6:	99 1f       	adc	r25, r25
    2ae8:	82 0f       	add	r24, r18
    2aea:	93 1f       	adc	r25, r19
    2aec:	89 5b       	subi	r24, 0xB9	; 185
    2aee:	9e 4f       	sbci	r25, 0xFE	; 254
    2af0:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    2af4:	89 81       	ldd	r24, Y+1	; 0x01
    2af6:	8f 5f       	subi	r24, 0xFF	; 255
    2af8:	89 83       	std	Y+1, r24	; 0x01
    2afa:	89 81       	ldd	r24, Y+1	; 0x01
    2afc:	82 30       	cpi	r24, 0x02	; 2
    2afe:	50 f3       	brcs	.-44     	; 0x2ad4 <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    2b00:	89 e5       	ldi	r24, 0x59	; 89
    2b02:	91 e0       	ldi	r25, 0x01	; 1
    2b04:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    2b08:	82 e6       	ldi	r24, 0x62	; 98
    2b0a:	91 e0       	ldi	r25, 0x01	; 1
    2b0c:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    2b10:	8f e6       	ldi	r24, 0x6F	; 111
    2b12:	91 e0       	ldi	r25, 0x01	; 1
    2b14:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    2b18:	89 e5       	ldi	r24, 0x59	; 89
    2b1a:	91 e0       	ldi	r25, 0x01	; 1
    2b1c:	90 93 6c 01 	sts	0x016C, r25
    2b20:	80 93 6b 01 	sts	0x016B, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    2b24:	82 e6       	ldi	r24, 0x62	; 98
    2b26:	91 e0       	ldi	r25, 0x01	; 1
    2b28:	90 93 6e 01 	sts	0x016E, r25
    2b2c:	80 93 6d 01 	sts	0x016D, r24
}
    2b30:	0f 90       	pop	r0
    2b32:	cf 91       	pop	r28
    2b34:	df 91       	pop	r29
    2b36:	08 95       	ret

00002b38 <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    2b38:	df 93       	push	r29
    2b3a:	cf 93       	push	r28
    2b3c:	00 d0       	rcall	.+0      	; 0x2b3e <xCoRoutineRemoveFromEventList+0x6>
    2b3e:	00 d0       	rcall	.+0      	; 0x2b40 <xCoRoutineRemoveFromEventList+0x8>
    2b40:	0f 92       	push	r0
    2b42:	cd b7       	in	r28, 0x3d	; 61
    2b44:	de b7       	in	r29, 0x3e	; 62
    2b46:	9d 83       	std	Y+5, r25	; 0x05
    2b48:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    2b4a:	ec 81       	ldd	r30, Y+4	; 0x04
    2b4c:	fd 81       	ldd	r31, Y+5	; 0x05
    2b4e:	05 80       	ldd	r0, Z+5	; 0x05
    2b50:	f6 81       	ldd	r31, Z+6	; 0x06
    2b52:	e0 2d       	mov	r30, r0
    2b54:	86 81       	ldd	r24, Z+6	; 0x06
    2b56:	97 81       	ldd	r25, Z+7	; 0x07
    2b58:	9b 83       	std	Y+3, r25	; 0x03
    2b5a:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    2b5c:	8a 81       	ldd	r24, Y+2	; 0x02
    2b5e:	9b 81       	ldd	r25, Y+3	; 0x03
    2b60:	0c 96       	adiw	r24, 0x0c	; 12
    2b62:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    2b66:	8a 81       	ldd	r24, Y+2	; 0x02
    2b68:	9b 81       	ldd	r25, Y+3	; 0x03
    2b6a:	9c 01       	movw	r18, r24
    2b6c:	24 5f       	subi	r18, 0xF4	; 244
    2b6e:	3f 4f       	sbci	r19, 0xFF	; 255
    2b70:	8f e6       	ldi	r24, 0x6F	; 111
    2b72:	91 e0       	ldi	r25, 0x01	; 1
    2b74:	b9 01       	movw	r22, r18
    2b76:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    2b7a:	ea 81       	ldd	r30, Y+2	; 0x02
    2b7c:	fb 81       	ldd	r31, Y+3	; 0x03
    2b7e:	96 89       	ldd	r25, Z+22	; 0x16
    2b80:	e0 91 3e 01 	lds	r30, 0x013E
    2b84:	f0 91 3f 01 	lds	r31, 0x013F
    2b88:	86 89       	ldd	r24, Z+22	; 0x16
    2b8a:	98 17       	cp	r25, r24
    2b8c:	18 f0       	brcs	.+6      	; 0x2b94 <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    2b8e:	81 e0       	ldi	r24, 0x01	; 1
    2b90:	89 83       	std	Y+1, r24	; 0x01
    2b92:	01 c0       	rjmp	.+2      	; 0x2b96 <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    2b94:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    2b96:	89 81       	ldd	r24, Y+1	; 0x01
}
    2b98:	0f 90       	pop	r0
    2b9a:	0f 90       	pop	r0
    2b9c:	0f 90       	pop	r0
    2b9e:	0f 90       	pop	r0
    2ba0:	0f 90       	pop	r0
    2ba2:	cf 91       	pop	r28
    2ba4:	df 91       	pop	r29
    2ba6:	08 95       	ret

00002ba8 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    2ba8:	df 93       	push	r29
    2baa:	cf 93       	push	r28
    2bac:	00 d0       	rcall	.+0      	; 0x2bae <pvPortMalloc+0x6>
    2bae:	00 d0       	rcall	.+0      	; 0x2bb0 <pvPortMalloc+0x8>
    2bb0:	cd b7       	in	r28, 0x3d	; 61
    2bb2:	de b7       	in	r29, 0x3e	; 62
    2bb4:	9c 83       	std	Y+4, r25	; 0x04
    2bb6:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    2bb8:	1a 82       	std	Y+2, r1	; 0x02
    2bba:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    2bbc:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    2bc0:	80 91 78 01 	lds	r24, 0x0178
    2bc4:	90 91 79 01 	lds	r25, 0x0179
    2bc8:	2b 81       	ldd	r18, Y+3	; 0x03
    2bca:	3c 81       	ldd	r19, Y+4	; 0x04
    2bcc:	82 0f       	add	r24, r18
    2bce:	93 1f       	adc	r25, r19
    2bd0:	25 e0       	ldi	r18, 0x05	; 5
    2bd2:	8c 3d       	cpi	r24, 0xDC	; 220
    2bd4:	92 07       	cpc	r25, r18
    2bd6:	18 f5       	brcc	.+70     	; 0x2c1e <pvPortMalloc+0x76>
    2bd8:	20 91 78 01 	lds	r18, 0x0178
    2bdc:	30 91 79 01 	lds	r19, 0x0179
    2be0:	8b 81       	ldd	r24, Y+3	; 0x03
    2be2:	9c 81       	ldd	r25, Y+4	; 0x04
    2be4:	28 0f       	add	r18, r24
    2be6:	39 1f       	adc	r19, r25
    2be8:	80 91 78 01 	lds	r24, 0x0178
    2bec:	90 91 79 01 	lds	r25, 0x0179
    2bf0:	82 17       	cp	r24, r18
    2bf2:	93 07       	cpc	r25, r19
    2bf4:	a0 f4       	brcc	.+40     	; 0x2c1e <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    2bf6:	80 91 78 01 	lds	r24, 0x0178
    2bfa:	90 91 79 01 	lds	r25, 0x0179
    2bfe:	86 58       	subi	r24, 0x86	; 134
    2c00:	9e 4f       	sbci	r25, 0xFE	; 254
    2c02:	9a 83       	std	Y+2, r25	; 0x02
    2c04:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    2c06:	20 91 78 01 	lds	r18, 0x0178
    2c0a:	30 91 79 01 	lds	r19, 0x0179
    2c0e:	8b 81       	ldd	r24, Y+3	; 0x03
    2c10:	9c 81       	ldd	r25, Y+4	; 0x04
    2c12:	82 0f       	add	r24, r18
    2c14:	93 1f       	adc	r25, r19
    2c16:	90 93 79 01 	sts	0x0179, r25
    2c1a:	80 93 78 01 	sts	0x0178, r24
		}	
	}
	xTaskResumeAll();
    2c1e:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    2c22:	89 81       	ldd	r24, Y+1	; 0x01
    2c24:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2c26:	0f 90       	pop	r0
    2c28:	0f 90       	pop	r0
    2c2a:	0f 90       	pop	r0
    2c2c:	0f 90       	pop	r0
    2c2e:	cf 91       	pop	r28
    2c30:	df 91       	pop	r29
    2c32:	08 95       	ret

00002c34 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2c34:	df 93       	push	r29
    2c36:	cf 93       	push	r28
    2c38:	00 d0       	rcall	.+0      	; 0x2c3a <vPortFree+0x6>
    2c3a:	cd b7       	in	r28, 0x3d	; 61
    2c3c:	de b7       	in	r29, 0x3e	; 62
    2c3e:	9a 83       	std	Y+2, r25	; 0x02
    2c40:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    2c42:	0f 90       	pop	r0
    2c44:	0f 90       	pop	r0
    2c46:	cf 91       	pop	r28
    2c48:	df 91       	pop	r29
    2c4a:	08 95       	ret

00002c4c <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    2c4c:	df 93       	push	r29
    2c4e:	cf 93       	push	r28
    2c50:	cd b7       	in	r28, 0x3d	; 61
    2c52:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    2c54:	10 92 79 01 	sts	0x0179, r1
    2c58:	10 92 78 01 	sts	0x0178, r1
}
    2c5c:	cf 91       	pop	r28
    2c5e:	df 91       	pop	r29
    2c60:	08 95       	ret

00002c62 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    2c62:	df 93       	push	r29
    2c64:	cf 93       	push	r28
    2c66:	cd b7       	in	r28, 0x3d	; 61
    2c68:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    2c6a:	20 91 78 01 	lds	r18, 0x0178
    2c6e:	30 91 79 01 	lds	r19, 0x0179
    2c72:	8c ed       	ldi	r24, 0xDC	; 220
    2c74:	95 e0       	ldi	r25, 0x05	; 5
    2c76:	82 1b       	sub	r24, r18
    2c78:	93 0b       	sbc	r25, r19
}
    2c7a:	cf 91       	pop	r28
    2c7c:	df 91       	pop	r29
    2c7e:	08 95       	ret

00002c80 <TWI_MasterInit>:
#include "BIT_MATH.h"
#include "i2c.h"
#include <avr/io.h>

void TWI_MasterInit()
{
    2c80:	df 93       	push	r29
    2c82:	cf 93       	push	r28
    2c84:	cd b7       	in	r28, 0x3d	; 61
    2c86:	de b7       	in	r29, 0x3e	; 62
	TWBR=255;
    2c88:	e0 e2       	ldi	r30, 0x20	; 32
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	8f ef       	ldi	r24, 0xFF	; 255
    2c8e:	80 83       	st	Z, r24
	CLR_BIT(TWSR,TWPS0);
    2c90:	a1 e2       	ldi	r26, 0x21	; 33
    2c92:	b0 e0       	ldi	r27, 0x00	; 0
    2c94:	e1 e2       	ldi	r30, 0x21	; 33
    2c96:	f0 e0       	ldi	r31, 0x00	; 0
    2c98:	80 81       	ld	r24, Z
    2c9a:	8e 7f       	andi	r24, 0xFE	; 254
    2c9c:	8c 93       	st	X, r24
	CLR_BIT(TWSR,TWPS1);
    2c9e:	a1 e2       	ldi	r26, 0x21	; 33
    2ca0:	b0 e0       	ldi	r27, 0x00	; 0
    2ca2:	e1 e2       	ldi	r30, 0x21	; 33
    2ca4:	f0 e0       	ldi	r31, 0x00	; 0
    2ca6:	80 81       	ld	r24, Z
    2ca8:	8d 7f       	andi	r24, 0xFD	; 253
    2caa:	8c 93       	st	X, r24
	TWCR=(1<<TWEN);
    2cac:	e6 e5       	ldi	r30, 0x56	; 86
    2cae:	f0 e0       	ldi	r31, 0x00	; 0
    2cb0:	84 e0       	ldi	r24, 0x04	; 4
    2cb2:	80 83       	st	Z, r24
}
    2cb4:	cf 91       	pop	r28
    2cb6:	df 91       	pop	r29
    2cb8:	08 95       	ret

00002cba <TWI_Start>:
void TWI_Start()
{
    2cba:	df 93       	push	r29
    2cbc:	cf 93       	push	r28
    2cbe:	cd b7       	in	r28, 0x3d	; 61
    2cc0:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWSTA);
    2cc2:	e6 e5       	ldi	r30, 0x56	; 86
    2cc4:	f0 e0       	ldi	r31, 0x00	; 0
    2cc6:	84 ea       	ldi	r24, 0xA4	; 164
    2cc8:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,TWINT)==0){}
    2cca:	e6 e5       	ldi	r30, 0x56	; 86
    2ccc:	f0 e0       	ldi	r31, 0x00	; 0
    2cce:	80 81       	ld	r24, Z
    2cd0:	88 23       	and	r24, r24
    2cd2:	dc f7       	brge	.-10     	; 0x2cca <TWI_Start+0x10>

}
    2cd4:	cf 91       	pop	r28
    2cd6:	df 91       	pop	r29
    2cd8:	08 95       	ret

00002cda <TWI_Stop>:
void TWI_Stop()
{
    2cda:	df 93       	push	r29
    2cdc:	cf 93       	push	r28
    2cde:	cd b7       	in	r28, 0x3d	; 61
    2ce0:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWINT)|(1<<TWEN)|(1<<TWSTO);
    2ce2:	e6 e5       	ldi	r30, 0x56	; 86
    2ce4:	f0 e0       	ldi	r31, 0x00	; 0
    2ce6:	84 e9       	ldi	r24, 0x94	; 148
    2ce8:	80 83       	st	Z, r24
}
    2cea:	cf 91       	pop	r28
    2cec:	df 91       	pop	r29
    2cee:	08 95       	ret

00002cf0 <TWI_Send>:
void TWI_Send(u8 val)
{
    2cf0:	df 93       	push	r29
    2cf2:	cf 93       	push	r28
    2cf4:	0f 92       	push	r0
    2cf6:	cd b7       	in	r28, 0x3d	; 61
    2cf8:	de b7       	in	r29, 0x3e	; 62
    2cfa:	89 83       	std	Y+1, r24	; 0x01
	TWDR=val;
    2cfc:	e3 e2       	ldi	r30, 0x23	; 35
    2cfe:	f0 e0       	ldi	r31, 0x00	; 0
    2d00:	89 81       	ldd	r24, Y+1	; 0x01
    2d02:	80 83       	st	Z, r24
	TWCR=(1<<TWINT)|(1<<TWEN);
    2d04:	e6 e5       	ldi	r30, 0x56	; 86
    2d06:	f0 e0       	ldi	r31, 0x00	; 0
    2d08:	84 e8       	ldi	r24, 0x84	; 132
    2d0a:	80 83       	st	Z, r24
		while(GET_BIT(TWCR,TWINT)==0){}
    2d0c:	e6 e5       	ldi	r30, 0x56	; 86
    2d0e:	f0 e0       	ldi	r31, 0x00	; 0
    2d10:	80 81       	ld	r24, Z
    2d12:	88 23       	and	r24, r24
    2d14:	dc f7       	brge	.-10     	; 0x2d0c <TWI_Send+0x1c>
}
    2d16:	0f 90       	pop	r0
    2d18:	cf 91       	pop	r28
    2d1a:	df 91       	pop	r29
    2d1c:	08 95       	ret

00002d1e <TWI_Receive>:
u8 TWI_Receive()
{
    2d1e:	df 93       	push	r29
    2d20:	cf 93       	push	r28
    2d22:	cd b7       	in	r28, 0x3d	; 61
    2d24:	de b7       	in	r29, 0x3e	; 62
	TWCR=(1<<TWINT)|(1<<TWEN);
    2d26:	e6 e5       	ldi	r30, 0x56	; 86
    2d28:	f0 e0       	ldi	r31, 0x00	; 0
    2d2a:	84 e8       	ldi	r24, 0x84	; 132
    2d2c:	80 83       	st	Z, r24
	while(GET_BIT(TWCR,TWINT)==0){}
    2d2e:	e6 e5       	ldi	r30, 0x56	; 86
    2d30:	f0 e0       	ldi	r31, 0x00	; 0
    2d32:	80 81       	ld	r24, Z
    2d34:	88 23       	and	r24, r24
    2d36:	dc f7       	brge	.-10     	; 0x2d2e <TWI_Receive+0x10>
	return TWDR;
    2d38:	e3 e2       	ldi	r30, 0x23	; 35
    2d3a:	f0 e0       	ldi	r31, 0x00	; 0
    2d3c:	80 81       	ld	r24, Z
}
    2d3e:	cf 91       	pop	r28
    2d40:	df 91       	pop	r29
    2d42:	08 95       	ret

00002d44 <KPD_INIT>:
#include "DIO_INTERFACE.h"
#include <avr/io.h>
//#include <util/delay.h>
#include "keypad.h"
void KPD_INIT()
{
    2d44:	df 93       	push	r29
    2d46:	cf 93       	push	r28
    2d48:	cd b7       	in	r28, 0x3d	; 61
    2d4a:	de b7       	in	r29, 0x3e	; 62
	/* Initialize first 3 bits in keypad as output pins */
	DIO_u8SetPinDir(keypad_port,keypad_col0_pin,1);
    2d4c:	80 e0       	ldi	r24, 0x00	; 0
    2d4e:	65 e0       	ldi	r22, 0x05	; 5
    2d50:	41 e0       	ldi	r20, 0x01	; 1
    2d52:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	DIO_u8SetPinDir(keypad_port,keypad_col1_pin,1);
    2d56:	80 e0       	ldi	r24, 0x00	; 0
    2d58:	66 e0       	ldi	r22, 0x06	; 6
    2d5a:	41 e0       	ldi	r20, 0x01	; 1
    2d5c:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	DIO_u8SetPinDir(keypad_port,keypad_col2_pin,1);
    2d60:	80 e0       	ldi	r24, 0x00	; 0
    2d62:	67 e0       	ldi	r22, 0x07	; 7
    2d64:	41 e0       	ldi	r20, 0x01	; 1
    2d66:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	/* initalize second four bits in keypad as input pins */
	DIO_u8SetPinDir(keypad_port,keypad_row0_pin,0);
    2d6a:	80 e0       	ldi	r24, 0x00	; 0
    2d6c:	61 e0       	ldi	r22, 0x01	; 1
    2d6e:	40 e0       	ldi	r20, 0x00	; 0
    2d70:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	DIO_u8SetPinDir(keypad_port,keypad_row1_pin,0);
    2d74:	80 e0       	ldi	r24, 0x00	; 0
    2d76:	62 e0       	ldi	r22, 0x02	; 2
    2d78:	40 e0       	ldi	r20, 0x00	; 0
    2d7a:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	DIO_u8SetPinDir(keypad_port,keypad_row2_pin,0);
    2d7e:	80 e0       	ldi	r24, 0x00	; 0
    2d80:	63 e0       	ldi	r22, 0x03	; 3
    2d82:	40 e0       	ldi	r20, 0x00	; 0
    2d84:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	DIO_u8SetPinDir(keypad_port,keypad_row3_pin,0);
    2d88:	80 e0       	ldi	r24, 0x00	; 0
    2d8a:	64 e0       	ldi	r22, 0x04	; 4
    2d8c:	40 e0       	ldi	r20, 0x00	; 0
    2d8e:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
	/*connect pull up resistance to the input pins*/
	DIO_u8SetPortValue(keypad_port,0xff);
    2d92:	80 e0       	ldi	r24, 0x00	; 0
    2d94:	6f ef       	ldi	r22, 0xFF	; 255
    2d96:	0e 94 ce 08 	call	0x119c	; 0x119c <DIO_u8SetPortValue>
}
    2d9a:	cf 91       	pop	r28
    2d9c:	df 91       	pop	r29
    2d9e:	08 95       	ret

00002da0 <KPD_u8GetPressedKey>:
u8 KPD_u8GetPressedKey()
{
    2da0:	df 93       	push	r29
    2da2:	cf 93       	push	r28
    2da4:	00 d0       	rcall	.+0      	; 0x2da6 <KPD_u8GetPressedKey+0x6>
    2da6:	00 d0       	rcall	.+0      	; 0x2da8 <KPD_u8GetPressedKey+0x8>
    2da8:	0f 92       	push	r0
    2daa:	cd b7       	in	r28, 0x3d	; 61
    2dac:	de b7       	in	r29, 0x3e	; 62
	u8 nopress=0xff;
    2dae:	8f ef       	ldi	r24, 0xFF	; 255
    2db0:	8b 83       	std	Y+3, r24	; 0x03
	u8 Local_u8state;
	static u8 Local_u8KPDArr[rownum][colnum]={{'1','2','3'},{'4','5','6'},{'7','8','9'},{'*','0','#'}};
	static u8 Local_u8colarray[colnum]={keypad_col0_pin,keypad_col1_pin,keypad_col2_pin};
	static u8 Local_u8rowarray[rownum]={keypad_row0_pin,keypad_row1_pin,keypad_row2_pin,keypad_row3_pin};
	for(u8 Local_u8CoulmnIndex=0;Local_u8CoulmnIndex<colnum;Local_u8CoulmnIndex++)
    2db2:	1a 82       	std	Y+2, r1	; 0x02
    2db4:	5e c0       	rjmp	.+188    	; 0x2e72 <KPD_u8GetPressedKey+0xd2>
	{DIO_u8SetPinValue(keypad_port,Local_u8colarray[Local_u8CoulmnIndex],DIO_LOW);
    2db6:	8a 81       	ldd	r24, Y+2	; 0x02
    2db8:	88 2f       	mov	r24, r24
    2dba:	90 e0       	ldi	r25, 0x00	; 0
    2dbc:	fc 01       	movw	r30, r24
    2dbe:	ec 5e       	subi	r30, 0xEC	; 236
    2dc0:	fe 4f       	sbci	r31, 0xFE	; 254
    2dc2:	90 81       	ld	r25, Z
    2dc4:	80 e0       	ldi	r24, 0x00	; 0
    2dc6:	69 2f       	mov	r22, r25
    2dc8:	40 e0       	ldi	r20, 0x00	; 0
    2dca:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
		for(u8 Local_u8RowIndex=0;Local_u8RowIndex<rownum;Local_u8RowIndex++)
    2dce:	19 82       	std	Y+1, r1	; 0x01
    2dd0:	3d c0       	rjmp	.+122    	; 0x2e4c <KPD_u8GetPressedKey+0xac>
		{
			DIO_u8GetPinValue(keypad_port,Local_u8rowarray[Local_u8RowIndex],&Local_u8state);
    2dd2:	89 81       	ldd	r24, Y+1	; 0x01
    2dd4:	88 2f       	mov	r24, r24
    2dd6:	90 e0       	ldi	r25, 0x00	; 0
    2dd8:	fc 01       	movw	r30, r24
    2dda:	e0 5f       	subi	r30, 0xF0	; 240
    2ddc:	fe 4f       	sbci	r31, 0xFE	; 254
    2dde:	90 81       	ld	r25, Z
    2de0:	9e 01       	movw	r18, r28
    2de2:	2c 5f       	subi	r18, 0xFC	; 252
    2de4:	3f 4f       	sbci	r19, 0xFF	; 255
    2de6:	80 e0       	ldi	r24, 0x00	; 0
    2de8:	69 2f       	mov	r22, r25
    2dea:	a9 01       	movw	r20, r18
    2dec:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <DIO_u8GetPinValue>
			if(Local_u8state==DIO_LOW)
    2df0:	8c 81       	ldd	r24, Y+4	; 0x04
    2df2:	88 23       	and	r24, r24
    2df4:	41 f5       	brne	.+80     	; 0x2e46 <KPD_u8GetPressedKey+0xa6>
			{
				nopress=Local_u8KPDArr[Local_u8RowIndex][Local_u8CoulmnIndex];//put the selected pressed key to the retrurnval
    2df6:	89 81       	ldd	r24, Y+1	; 0x01
    2df8:	28 2f       	mov	r18, r24
    2dfa:	30 e0       	ldi	r19, 0x00	; 0
    2dfc:	8a 81       	ldd	r24, Y+2	; 0x02
    2dfe:	48 2f       	mov	r20, r24
    2e00:	50 e0       	ldi	r21, 0x00	; 0
    2e02:	c9 01       	movw	r24, r18
    2e04:	88 0f       	add	r24, r24
    2e06:	99 1f       	adc	r25, r25
    2e08:	82 0f       	add	r24, r18
    2e0a:	93 1f       	adc	r25, r19
    2e0c:	84 0f       	add	r24, r20
    2e0e:	95 1f       	adc	r25, r21
    2e10:	fc 01       	movw	r30, r24
    2e12:	e9 5e       	subi	r30, 0xE9	; 233
    2e14:	fe 4f       	sbci	r31, 0xFE	; 254
    2e16:	80 81       	ld	r24, Z
    2e18:	8b 83       	std	Y+3, r24	; 0x03
    2e1a:	0f c0       	rjmp	.+30     	; 0x2e3a <KPD_u8GetPressedKey+0x9a>
				while(Local_u8state==DIO_LOW)
				{
					DIO_u8GetPinValue(keypad_port,Local_u8rowarray[Local_u8RowIndex],&Local_u8state);
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	88 2f       	mov	r24, r24
    2e20:	90 e0       	ldi	r25, 0x00	; 0
    2e22:	fc 01       	movw	r30, r24
    2e24:	e0 5f       	subi	r30, 0xF0	; 240
    2e26:	fe 4f       	sbci	r31, 0xFE	; 254
    2e28:	90 81       	ld	r25, Z
    2e2a:	9e 01       	movw	r18, r28
    2e2c:	2c 5f       	subi	r18, 0xFC	; 252
    2e2e:	3f 4f       	sbci	r19, 0xFF	; 255
    2e30:	80 e0       	ldi	r24, 0x00	; 0
    2e32:	69 2f       	mov	r22, r25
    2e34:	a9 01       	movw	r20, r18
    2e36:	0e 94 f2 0b 	call	0x17e4	; 0x17e4 <DIO_u8GetPinValue>
		{
			DIO_u8GetPinValue(keypad_port,Local_u8rowarray[Local_u8RowIndex],&Local_u8state);
			if(Local_u8state==DIO_LOW)
			{
				nopress=Local_u8KPDArr[Local_u8RowIndex][Local_u8CoulmnIndex];//put the selected pressed key to the retrurnval
				while(Local_u8state==DIO_LOW)
    2e3a:	8c 81       	ldd	r24, Y+4	; 0x04
    2e3c:	88 23       	and	r24, r24
    2e3e:	71 f3       	breq	.-36     	; 0x2e1c <KPD_u8GetPressedKey+0x7c>
				{
					DIO_u8GetPinValue(keypad_port,Local_u8rowarray[Local_u8RowIndex],&Local_u8state);
				}
				return nopress;
    2e40:	8b 81       	ldd	r24, Y+3	; 0x03
    2e42:	8d 83       	std	Y+5, r24	; 0x05
    2e44:	1c c0       	rjmp	.+56     	; 0x2e7e <KPD_u8GetPressedKey+0xde>
	static u8 Local_u8KPDArr[rownum][colnum]={{'1','2','3'},{'4','5','6'},{'7','8','9'},{'*','0','#'}};
	static u8 Local_u8colarray[colnum]={keypad_col0_pin,keypad_col1_pin,keypad_col2_pin};
	static u8 Local_u8rowarray[rownum]={keypad_row0_pin,keypad_row1_pin,keypad_row2_pin,keypad_row3_pin};
	for(u8 Local_u8CoulmnIndex=0;Local_u8CoulmnIndex<colnum;Local_u8CoulmnIndex++)
	{DIO_u8SetPinValue(keypad_port,Local_u8colarray[Local_u8CoulmnIndex],DIO_LOW);
		for(u8 Local_u8RowIndex=0;Local_u8RowIndex<rownum;Local_u8RowIndex++)
    2e46:	89 81       	ldd	r24, Y+1	; 0x01
    2e48:	8f 5f       	subi	r24, 0xFF	; 255
    2e4a:	89 83       	std	Y+1, r24	; 0x01
    2e4c:	89 81       	ldd	r24, Y+1	; 0x01
    2e4e:	84 30       	cpi	r24, 0x04	; 4
    2e50:	08 f4       	brcc	.+2      	; 0x2e54 <KPD_u8GetPressedKey+0xb4>
    2e52:	bf cf       	rjmp	.-130    	; 0x2dd2 <KPD_u8GetPressedKey+0x32>
					DIO_u8GetPinValue(keypad_port,Local_u8rowarray[Local_u8RowIndex],&Local_u8state);
				}
				return nopress;
			}
		}
		DIO_u8SetPinValue(keypad_port,Local_u8colarray[Local_u8CoulmnIndex],DIO_HIGH);
    2e54:	8a 81       	ldd	r24, Y+2	; 0x02
    2e56:	88 2f       	mov	r24, r24
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	fc 01       	movw	r30, r24
    2e5c:	ec 5e       	subi	r30, 0xEC	; 236
    2e5e:	fe 4f       	sbci	r31, 0xFE	; 254
    2e60:	90 81       	ld	r25, Z
    2e62:	80 e0       	ldi	r24, 0x00	; 0
    2e64:	69 2f       	mov	r22, r25
    2e66:	41 e0       	ldi	r20, 0x01	; 1
    2e68:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
	u8 nopress=0xff;
	u8 Local_u8state;
	static u8 Local_u8KPDArr[rownum][colnum]={{'1','2','3'},{'4','5','6'},{'7','8','9'},{'*','0','#'}};
	static u8 Local_u8colarray[colnum]={keypad_col0_pin,keypad_col1_pin,keypad_col2_pin};
	static u8 Local_u8rowarray[rownum]={keypad_row0_pin,keypad_row1_pin,keypad_row2_pin,keypad_row3_pin};
	for(u8 Local_u8CoulmnIndex=0;Local_u8CoulmnIndex<colnum;Local_u8CoulmnIndex++)
    2e6c:	8a 81       	ldd	r24, Y+2	; 0x02
    2e6e:	8f 5f       	subi	r24, 0xFF	; 255
    2e70:	8a 83       	std	Y+2, r24	; 0x02
    2e72:	8a 81       	ldd	r24, Y+2	; 0x02
    2e74:	83 30       	cpi	r24, 0x03	; 3
    2e76:	08 f4       	brcc	.+2      	; 0x2e7a <KPD_u8GetPressedKey+0xda>
    2e78:	9e cf       	rjmp	.-196    	; 0x2db6 <KPD_u8GetPressedKey+0x16>
				return nopress;
			}
		}
		DIO_u8SetPinValue(keypad_port,Local_u8colarray[Local_u8CoulmnIndex],DIO_HIGH);
	}
	return nopress;//return the pressed key in case of key pressed or return 0xff in case of no key pressed
    2e7a:	8b 81       	ldd	r24, Y+3	; 0x03
    2e7c:	8d 83       	std	Y+5, r24	; 0x05
    2e7e:	8d 81       	ldd	r24, Y+5	; 0x05

}
    2e80:	0f 90       	pop	r0
    2e82:	0f 90       	pop	r0
    2e84:	0f 90       	pop	r0
    2e86:	0f 90       	pop	r0
    2e88:	0f 90       	pop	r0
    2e8a:	cf 91       	pop	r28
    2e8c:	df 91       	pop	r29
    2e8e:	08 95       	ret

00002e90 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    2e90:	df 93       	push	r29
    2e92:	cf 93       	push	r28
    2e94:	00 d0       	rcall	.+0      	; 0x2e96 <vListInitialise+0x6>
    2e96:	cd b7       	in	r28, 0x3d	; 61
    2e98:	de b7       	in	r29, 0x3e	; 62
    2e9a:	9a 83       	std	Y+2, r25	; 0x02
    2e9c:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    2e9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ea0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea2:	03 96       	adiw	r24, 0x03	; 3
    2ea4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ea6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ea8:	92 83       	std	Z+2, r25	; 0x02
    2eaa:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    2eac:	e9 81       	ldd	r30, Y+1	; 0x01
    2eae:	fa 81       	ldd	r31, Y+2	; 0x02
    2eb0:	8f ef       	ldi	r24, 0xFF	; 255
    2eb2:	9f ef       	ldi	r25, 0xFF	; 255
    2eb4:	94 83       	std	Z+4, r25	; 0x04
    2eb6:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    2eb8:	89 81       	ldd	r24, Y+1	; 0x01
    2eba:	9a 81       	ldd	r25, Y+2	; 0x02
    2ebc:	03 96       	adiw	r24, 0x03	; 3
    2ebe:	e9 81       	ldd	r30, Y+1	; 0x01
    2ec0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ec2:	96 83       	std	Z+6, r25	; 0x06
    2ec4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    2ec6:	89 81       	ldd	r24, Y+1	; 0x01
    2ec8:	9a 81       	ldd	r25, Y+2	; 0x02
    2eca:	03 96       	adiw	r24, 0x03	; 3
    2ecc:	e9 81       	ldd	r30, Y+1	; 0x01
    2ece:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed0:	90 87       	std	Z+8, r25	; 0x08
    2ed2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    2ed4:	e9 81       	ldd	r30, Y+1	; 0x01
    2ed6:	fa 81       	ldd	r31, Y+2	; 0x02
    2ed8:	10 82       	st	Z, r1
}
    2eda:	0f 90       	pop	r0
    2edc:	0f 90       	pop	r0
    2ede:	cf 91       	pop	r28
    2ee0:	df 91       	pop	r29
    2ee2:	08 95       	ret

00002ee4 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    2ee4:	df 93       	push	r29
    2ee6:	cf 93       	push	r28
    2ee8:	00 d0       	rcall	.+0      	; 0x2eea <vListInitialiseItem+0x6>
    2eea:	cd b7       	in	r28, 0x3d	; 61
    2eec:	de b7       	in	r29, 0x3e	; 62
    2eee:	9a 83       	std	Y+2, r25	; 0x02
    2ef0:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    2ef2:	e9 81       	ldd	r30, Y+1	; 0x01
    2ef4:	fa 81       	ldd	r31, Y+2	; 0x02
    2ef6:	11 86       	std	Z+9, r1	; 0x09
    2ef8:	10 86       	std	Z+8, r1	; 0x08
}
    2efa:	0f 90       	pop	r0
    2efc:	0f 90       	pop	r0
    2efe:	cf 91       	pop	r28
    2f00:	df 91       	pop	r29
    2f02:	08 95       	ret

00002f04 <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    2f04:	df 93       	push	r29
    2f06:	cf 93       	push	r28
    2f08:	00 d0       	rcall	.+0      	; 0x2f0a <vListInsertEnd+0x6>
    2f0a:	00 d0       	rcall	.+0      	; 0x2f0c <vListInsertEnd+0x8>
    2f0c:	00 d0       	rcall	.+0      	; 0x2f0e <vListInsertEnd+0xa>
    2f0e:	cd b7       	in	r28, 0x3d	; 61
    2f10:	de b7       	in	r29, 0x3e	; 62
    2f12:	9c 83       	std	Y+4, r25	; 0x04
    2f14:	8b 83       	std	Y+3, r24	; 0x03
    2f16:	7e 83       	std	Y+6, r23	; 0x06
    2f18:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    2f1a:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1c:	fc 81       	ldd	r31, Y+4	; 0x04
    2f1e:	81 81       	ldd	r24, Z+1	; 0x01
    2f20:	92 81       	ldd	r25, Z+2	; 0x02
    2f22:	9a 83       	std	Y+2, r25	; 0x02
    2f24:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    2f26:	e9 81       	ldd	r30, Y+1	; 0x01
    2f28:	fa 81       	ldd	r31, Y+2	; 0x02
    2f2a:	82 81       	ldd	r24, Z+2	; 0x02
    2f2c:	93 81       	ldd	r25, Z+3	; 0x03
    2f2e:	ed 81       	ldd	r30, Y+5	; 0x05
    2f30:	fe 81       	ldd	r31, Y+6	; 0x06
    2f32:	93 83       	std	Z+3, r25	; 0x03
    2f34:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    2f36:	eb 81       	ldd	r30, Y+3	; 0x03
    2f38:	fc 81       	ldd	r31, Y+4	; 0x04
    2f3a:	81 81       	ldd	r24, Z+1	; 0x01
    2f3c:	92 81       	ldd	r25, Z+2	; 0x02
    2f3e:	ed 81       	ldd	r30, Y+5	; 0x05
    2f40:	fe 81       	ldd	r31, Y+6	; 0x06
    2f42:	95 83       	std	Z+5, r25	; 0x05
    2f44:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    2f46:	e9 81       	ldd	r30, Y+1	; 0x01
    2f48:	fa 81       	ldd	r31, Y+2	; 0x02
    2f4a:	02 80       	ldd	r0, Z+2	; 0x02
    2f4c:	f3 81       	ldd	r31, Z+3	; 0x03
    2f4e:	e0 2d       	mov	r30, r0
    2f50:	8d 81       	ldd	r24, Y+5	; 0x05
    2f52:	9e 81       	ldd	r25, Y+6	; 0x06
    2f54:	95 83       	std	Z+5, r25	; 0x05
    2f56:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    2f58:	8d 81       	ldd	r24, Y+5	; 0x05
    2f5a:	9e 81       	ldd	r25, Y+6	; 0x06
    2f5c:	e9 81       	ldd	r30, Y+1	; 0x01
    2f5e:	fa 81       	ldd	r31, Y+2	; 0x02
    2f60:	93 83       	std	Z+3, r25	; 0x03
    2f62:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    2f64:	8d 81       	ldd	r24, Y+5	; 0x05
    2f66:	9e 81       	ldd	r25, Y+6	; 0x06
    2f68:	eb 81       	ldd	r30, Y+3	; 0x03
    2f6a:	fc 81       	ldd	r31, Y+4	; 0x04
    2f6c:	92 83       	std	Z+2, r25	; 0x02
    2f6e:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    2f70:	ed 81       	ldd	r30, Y+5	; 0x05
    2f72:	fe 81       	ldd	r31, Y+6	; 0x06
    2f74:	8b 81       	ldd	r24, Y+3	; 0x03
    2f76:	9c 81       	ldd	r25, Y+4	; 0x04
    2f78:	91 87       	std	Z+9, r25	; 0x09
    2f7a:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    2f7c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f7e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f80:	80 81       	ld	r24, Z
    2f82:	8f 5f       	subi	r24, 0xFF	; 255
    2f84:	eb 81       	ldd	r30, Y+3	; 0x03
    2f86:	fc 81       	ldd	r31, Y+4	; 0x04
    2f88:	80 83       	st	Z, r24
}
    2f8a:	26 96       	adiw	r28, 0x06	; 6
    2f8c:	0f b6       	in	r0, 0x3f	; 63
    2f8e:	f8 94       	cli
    2f90:	de bf       	out	0x3e, r29	; 62
    2f92:	0f be       	out	0x3f, r0	; 63
    2f94:	cd bf       	out	0x3d, r28	; 61
    2f96:	cf 91       	pop	r28
    2f98:	df 91       	pop	r29
    2f9a:	08 95       	ret

00002f9c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    2f9c:	df 93       	push	r29
    2f9e:	cf 93       	push	r28
    2fa0:	cd b7       	in	r28, 0x3d	; 61
    2fa2:	de b7       	in	r29, 0x3e	; 62
    2fa4:	28 97       	sbiw	r28, 0x08	; 8
    2fa6:	0f b6       	in	r0, 0x3f	; 63
    2fa8:	f8 94       	cli
    2faa:	de bf       	out	0x3e, r29	; 62
    2fac:	0f be       	out	0x3f, r0	; 63
    2fae:	cd bf       	out	0x3d, r28	; 61
    2fb0:	9e 83       	std	Y+6, r25	; 0x06
    2fb2:	8d 83       	std	Y+5, r24	; 0x05
    2fb4:	78 87       	std	Y+8, r23	; 0x08
    2fb6:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    2fb8:	ef 81       	ldd	r30, Y+7	; 0x07
    2fba:	f8 85       	ldd	r31, Y+8	; 0x08
    2fbc:	80 81       	ld	r24, Z
    2fbe:	91 81       	ldd	r25, Z+1	; 0x01
    2fc0:	9a 83       	std	Y+2, r25	; 0x02
    2fc2:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    2fc4:	89 81       	ldd	r24, Y+1	; 0x01
    2fc6:	9a 81       	ldd	r25, Y+2	; 0x02
    2fc8:	2f ef       	ldi	r18, 0xFF	; 255
    2fca:	8f 3f       	cpi	r24, 0xFF	; 255
    2fcc:	92 07       	cpc	r25, r18
    2fce:	39 f4       	brne	.+14     	; 0x2fde <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    2fd0:	ed 81       	ldd	r30, Y+5	; 0x05
    2fd2:	fe 81       	ldd	r31, Y+6	; 0x06
    2fd4:	87 81       	ldd	r24, Z+7	; 0x07
    2fd6:	90 85       	ldd	r25, Z+8	; 0x08
    2fd8:	9c 83       	std	Y+4, r25	; 0x04
    2fda:	8b 83       	std	Y+3, r24	; 0x03
    2fdc:	18 c0       	rjmp	.+48     	; 0x300e <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    2fde:	8d 81       	ldd	r24, Y+5	; 0x05
    2fe0:	9e 81       	ldd	r25, Y+6	; 0x06
    2fe2:	03 96       	adiw	r24, 0x03	; 3
    2fe4:	9c 83       	std	Y+4, r25	; 0x04
    2fe6:	8b 83       	std	Y+3, r24	; 0x03
    2fe8:	06 c0       	rjmp	.+12     	; 0x2ff6 <vListInsert+0x5a>
    2fea:	eb 81       	ldd	r30, Y+3	; 0x03
    2fec:	fc 81       	ldd	r31, Y+4	; 0x04
    2fee:	82 81       	ldd	r24, Z+2	; 0x02
    2ff0:	93 81       	ldd	r25, Z+3	; 0x03
    2ff2:	9c 83       	std	Y+4, r25	; 0x04
    2ff4:	8b 83       	std	Y+3, r24	; 0x03
    2ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    2ffa:	02 80       	ldd	r0, Z+2	; 0x02
    2ffc:	f3 81       	ldd	r31, Z+3	; 0x03
    2ffe:	e0 2d       	mov	r30, r0
    3000:	20 81       	ld	r18, Z
    3002:	31 81       	ldd	r19, Z+1	; 0x01
    3004:	89 81       	ldd	r24, Y+1	; 0x01
    3006:	9a 81       	ldd	r25, Y+2	; 0x02
    3008:	82 17       	cp	r24, r18
    300a:	93 07       	cpc	r25, r19
    300c:	70 f7       	brcc	.-36     	; 0x2fea <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    300e:	eb 81       	ldd	r30, Y+3	; 0x03
    3010:	fc 81       	ldd	r31, Y+4	; 0x04
    3012:	82 81       	ldd	r24, Z+2	; 0x02
    3014:	93 81       	ldd	r25, Z+3	; 0x03
    3016:	ef 81       	ldd	r30, Y+7	; 0x07
    3018:	f8 85       	ldd	r31, Y+8	; 0x08
    301a:	93 83       	std	Z+3, r25	; 0x03
    301c:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    301e:	ef 81       	ldd	r30, Y+7	; 0x07
    3020:	f8 85       	ldd	r31, Y+8	; 0x08
    3022:	02 80       	ldd	r0, Z+2	; 0x02
    3024:	f3 81       	ldd	r31, Z+3	; 0x03
    3026:	e0 2d       	mov	r30, r0
    3028:	8f 81       	ldd	r24, Y+7	; 0x07
    302a:	98 85       	ldd	r25, Y+8	; 0x08
    302c:	95 83       	std	Z+5, r25	; 0x05
    302e:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    3030:	ef 81       	ldd	r30, Y+7	; 0x07
    3032:	f8 85       	ldd	r31, Y+8	; 0x08
    3034:	8b 81       	ldd	r24, Y+3	; 0x03
    3036:	9c 81       	ldd	r25, Y+4	; 0x04
    3038:	95 83       	std	Z+5, r25	; 0x05
    303a:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    303c:	8f 81       	ldd	r24, Y+7	; 0x07
    303e:	98 85       	ldd	r25, Y+8	; 0x08
    3040:	eb 81       	ldd	r30, Y+3	; 0x03
    3042:	fc 81       	ldd	r31, Y+4	; 0x04
    3044:	93 83       	std	Z+3, r25	; 0x03
    3046:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    3048:	ef 81       	ldd	r30, Y+7	; 0x07
    304a:	f8 85       	ldd	r31, Y+8	; 0x08
    304c:	8d 81       	ldd	r24, Y+5	; 0x05
    304e:	9e 81       	ldd	r25, Y+6	; 0x06
    3050:	91 87       	std	Z+9, r25	; 0x09
    3052:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    3054:	ed 81       	ldd	r30, Y+5	; 0x05
    3056:	fe 81       	ldd	r31, Y+6	; 0x06
    3058:	80 81       	ld	r24, Z
    305a:	8f 5f       	subi	r24, 0xFF	; 255
    305c:	ed 81       	ldd	r30, Y+5	; 0x05
    305e:	fe 81       	ldd	r31, Y+6	; 0x06
    3060:	80 83       	st	Z, r24
}
    3062:	28 96       	adiw	r28, 0x08	; 8
    3064:	0f b6       	in	r0, 0x3f	; 63
    3066:	f8 94       	cli
    3068:	de bf       	out	0x3e, r29	; 62
    306a:	0f be       	out	0x3f, r0	; 63
    306c:	cd bf       	out	0x3d, r28	; 61
    306e:	cf 91       	pop	r28
    3070:	df 91       	pop	r29
    3072:	08 95       	ret

00003074 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    3074:	df 93       	push	r29
    3076:	cf 93       	push	r28
    3078:	00 d0       	rcall	.+0      	; 0x307a <vListRemove+0x6>
    307a:	00 d0       	rcall	.+0      	; 0x307c <vListRemove+0x8>
    307c:	cd b7       	in	r28, 0x3d	; 61
    307e:	de b7       	in	r29, 0x3e	; 62
    3080:	9c 83       	std	Y+4, r25	; 0x04
    3082:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    3084:	eb 81       	ldd	r30, Y+3	; 0x03
    3086:	fc 81       	ldd	r31, Y+4	; 0x04
    3088:	a2 81       	ldd	r26, Z+2	; 0x02
    308a:	b3 81       	ldd	r27, Z+3	; 0x03
    308c:	eb 81       	ldd	r30, Y+3	; 0x03
    308e:	fc 81       	ldd	r31, Y+4	; 0x04
    3090:	84 81       	ldd	r24, Z+4	; 0x04
    3092:	95 81       	ldd	r25, Z+5	; 0x05
    3094:	15 96       	adiw	r26, 0x05	; 5
    3096:	9c 93       	st	X, r25
    3098:	8e 93       	st	-X, r24
    309a:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    309c:	eb 81       	ldd	r30, Y+3	; 0x03
    309e:	fc 81       	ldd	r31, Y+4	; 0x04
    30a0:	a4 81       	ldd	r26, Z+4	; 0x04
    30a2:	b5 81       	ldd	r27, Z+5	; 0x05
    30a4:	eb 81       	ldd	r30, Y+3	; 0x03
    30a6:	fc 81       	ldd	r31, Y+4	; 0x04
    30a8:	82 81       	ldd	r24, Z+2	; 0x02
    30aa:	93 81       	ldd	r25, Z+3	; 0x03
    30ac:	13 96       	adiw	r26, 0x03	; 3
    30ae:	9c 93       	st	X, r25
    30b0:	8e 93       	st	-X, r24
    30b2:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    30b4:	eb 81       	ldd	r30, Y+3	; 0x03
    30b6:	fc 81       	ldd	r31, Y+4	; 0x04
    30b8:	80 85       	ldd	r24, Z+8	; 0x08
    30ba:	91 85       	ldd	r25, Z+9	; 0x09
    30bc:	9a 83       	std	Y+2, r25	; 0x02
    30be:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    30c0:	e9 81       	ldd	r30, Y+1	; 0x01
    30c2:	fa 81       	ldd	r31, Y+2	; 0x02
    30c4:	21 81       	ldd	r18, Z+1	; 0x01
    30c6:	32 81       	ldd	r19, Z+2	; 0x02
    30c8:	8b 81       	ldd	r24, Y+3	; 0x03
    30ca:	9c 81       	ldd	r25, Y+4	; 0x04
    30cc:	28 17       	cp	r18, r24
    30ce:	39 07       	cpc	r19, r25
    30d0:	41 f4       	brne	.+16     	; 0x30e2 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    30d2:	eb 81       	ldd	r30, Y+3	; 0x03
    30d4:	fc 81       	ldd	r31, Y+4	; 0x04
    30d6:	84 81       	ldd	r24, Z+4	; 0x04
    30d8:	95 81       	ldd	r25, Z+5	; 0x05
    30da:	e9 81       	ldd	r30, Y+1	; 0x01
    30dc:	fa 81       	ldd	r31, Y+2	; 0x02
    30de:	92 83       	std	Z+2, r25	; 0x02
    30e0:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    30e2:	eb 81       	ldd	r30, Y+3	; 0x03
    30e4:	fc 81       	ldd	r31, Y+4	; 0x04
    30e6:	11 86       	std	Z+9, r1	; 0x09
    30e8:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    30ea:	e9 81       	ldd	r30, Y+1	; 0x01
    30ec:	fa 81       	ldd	r31, Y+2	; 0x02
    30ee:	80 81       	ld	r24, Z
    30f0:	81 50       	subi	r24, 0x01	; 1
    30f2:	e9 81       	ldd	r30, Y+1	; 0x01
    30f4:	fa 81       	ldd	r31, Y+2	; 0x02
    30f6:	80 83       	st	Z, r24
}
    30f8:	0f 90       	pop	r0
    30fa:	0f 90       	pop	r0
    30fc:	0f 90       	pop	r0
    30fe:	0f 90       	pop	r0
    3100:	cf 91       	pop	r28
    3102:	df 91       	pop	r29
    3104:	08 95       	ret

00003106 <main>:
#include "main_confgration.h"
#include <avr/interrupt.h>
#include <util/delay.h>
u8 pass[4]={'#','7','2','*'};

int main(){
    3106:	df 93       	push	r29
    3108:	cf 93       	push	r28
    310a:	cd b7       	in	r28, 0x3d	; 61
    310c:	de b7       	in	r29, 0x3e	; 62
    310e:	ae 97       	sbiw	r28, 0x2e	; 46
    3110:	0f b6       	in	r0, 0x3f	; 63
    3112:	f8 94       	cli
    3114:	de bf       	out	0x3e, r29	; 62
    3116:	0f be       	out	0x3f, r0	; 63
    3118:	cd bf       	out	0x3d, r28	; 61
	/*        INIT      */
	LCD_voidInit();
    311a:	0e 94 6d 0f 	call	0x1eda	; 0x1eda <LCD_voidInit>
	KPD_INIT();
    311e:	0e 94 a2 16 	call	0x2d44	; 0x2d44 <KPD_INIT>
	SPI_voidINITMaster();
    3122:	0e 94 5d 11 	call	0x22ba	; 0x22ba <SPI_voidINITMaster>
	/*    LCD             */
	LCD_voidSendString("HOLA,");
    3126:	80 e6       	ldi	r24, 0x60	; 96
    3128:	90 e0       	ldi	r25, 0x00	; 0
    312a:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	LCD_voidGoToXY(1,0);
    312e:	81 e0       	ldi	r24, 0x01	; 1
    3130:	60 e0       	ldi	r22, 0x00	; 0
    3132:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
	LCD_voidSendString("IN MY SMART HOME");
    3136:	86 e6       	ldi	r24, 0x66	; 102
    3138:	90 e0       	ldi	r25, 0x00	; 0
    313a:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
    313e:	80 e0       	ldi	r24, 0x00	; 0
    3140:	90 e5       	ldi	r25, 0x50	; 80
    3142:	a3 e4       	ldi	r26, 0x43	; 67
    3144:	b7 e4       	ldi	r27, 0x47	; 71
    3146:	8f a3       	std	Y+39, r24	; 0x27
    3148:	98 a7       	std	Y+40, r25	; 0x28
    314a:	a9 a7       	std	Y+41, r26	; 0x29
    314c:	ba a7       	std	Y+42, r27	; 0x2a
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    314e:	6f a1       	ldd	r22, Y+39	; 0x27
    3150:	78 a5       	ldd	r23, Y+40	; 0x28
    3152:	89 a5       	ldd	r24, Y+41	; 0x29
    3154:	9a a5       	ldd	r25, Y+42	; 0x2a
    3156:	20 e0       	ldi	r18, 0x00	; 0
    3158:	30 e0       	ldi	r19, 0x00	; 0
    315a:	4a e7       	ldi	r20, 0x7A	; 122
    315c:	53 e4       	ldi	r21, 0x43	; 67
    315e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3162:	dc 01       	movw	r26, r24
    3164:	cb 01       	movw	r24, r22
    3166:	8b a3       	std	Y+35, r24	; 0x23
    3168:	9c a3       	std	Y+36, r25	; 0x24
    316a:	ad a3       	std	Y+37, r26	; 0x25
    316c:	be a3       	std	Y+38, r27	; 0x26
	if (__tmp < 1.0)
    316e:	6b a1       	ldd	r22, Y+35	; 0x23
    3170:	7c a1       	ldd	r23, Y+36	; 0x24
    3172:	8d a1       	ldd	r24, Y+37	; 0x25
    3174:	9e a1       	ldd	r25, Y+38	; 0x26
    3176:	20 e0       	ldi	r18, 0x00	; 0
    3178:	30 e0       	ldi	r19, 0x00	; 0
    317a:	40 e8       	ldi	r20, 0x80	; 128
    317c:	5f e3       	ldi	r21, 0x3F	; 63
    317e:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    3182:	88 23       	and	r24, r24
    3184:	2c f4       	brge	.+10     	; 0x3190 <main+0x8a>
		__ticks = 1;
    3186:	81 e0       	ldi	r24, 0x01	; 1
    3188:	90 e0       	ldi	r25, 0x00	; 0
    318a:	9a a3       	std	Y+34, r25	; 0x22
    318c:	89 a3       	std	Y+33, r24	; 0x21
    318e:	3f c0       	rjmp	.+126    	; 0x320e <main+0x108>
	else if (__tmp > 65535)
    3190:	6b a1       	ldd	r22, Y+35	; 0x23
    3192:	7c a1       	ldd	r23, Y+36	; 0x24
    3194:	8d a1       	ldd	r24, Y+37	; 0x25
    3196:	9e a1       	ldd	r25, Y+38	; 0x26
    3198:	20 e0       	ldi	r18, 0x00	; 0
    319a:	3f ef       	ldi	r19, 0xFF	; 255
    319c:	4f e7       	ldi	r20, 0x7F	; 127
    319e:	57 e4       	ldi	r21, 0x47	; 71
    31a0:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    31a4:	18 16       	cp	r1, r24
    31a6:	4c f5       	brge	.+82     	; 0x31fa <main+0xf4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    31a8:	6f a1       	ldd	r22, Y+39	; 0x27
    31aa:	78 a5       	ldd	r23, Y+40	; 0x28
    31ac:	89 a5       	ldd	r24, Y+41	; 0x29
    31ae:	9a a5       	ldd	r25, Y+42	; 0x2a
    31b0:	20 e0       	ldi	r18, 0x00	; 0
    31b2:	30 e0       	ldi	r19, 0x00	; 0
    31b4:	40 e2       	ldi	r20, 0x20	; 32
    31b6:	51 e4       	ldi	r21, 0x41	; 65
    31b8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    31bc:	dc 01       	movw	r26, r24
    31be:	cb 01       	movw	r24, r22
    31c0:	bc 01       	movw	r22, r24
    31c2:	cd 01       	movw	r24, r26
    31c4:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    31c8:	dc 01       	movw	r26, r24
    31ca:	cb 01       	movw	r24, r22
    31cc:	9a a3       	std	Y+34, r25	; 0x22
    31ce:	89 a3       	std	Y+33, r24	; 0x21
    31d0:	0f c0       	rjmp	.+30     	; 0x31f0 <main+0xea>
    31d2:	89 e1       	ldi	r24, 0x19	; 25
    31d4:	90 e0       	ldi	r25, 0x00	; 0
    31d6:	98 a3       	std	Y+32, r25	; 0x20
    31d8:	8f 8f       	std	Y+31, r24	; 0x1f
    31da:	8f 8d       	ldd	r24, Y+31	; 0x1f
    31dc:	98 a1       	ldd	r25, Y+32	; 0x20
    31de:	01 97       	sbiw	r24, 0x01	; 1
    31e0:	f1 f7       	brne	.-4      	; 0x31de <main+0xd8>
    31e2:	98 a3       	std	Y+32, r25	; 0x20
    31e4:	8f 8f       	std	Y+31, r24	; 0x1f
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    31e6:	89 a1       	ldd	r24, Y+33	; 0x21
    31e8:	9a a1       	ldd	r25, Y+34	; 0x22
    31ea:	01 97       	sbiw	r24, 0x01	; 1
    31ec:	9a a3       	std	Y+34, r25	; 0x22
    31ee:	89 a3       	std	Y+33, r24	; 0x21
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    31f0:	89 a1       	ldd	r24, Y+33	; 0x21
    31f2:	9a a1       	ldd	r25, Y+34	; 0x22
    31f4:	00 97       	sbiw	r24, 0x00	; 0
    31f6:	69 f7       	brne	.-38     	; 0x31d2 <main+0xcc>
    31f8:	14 c0       	rjmp	.+40     	; 0x3222 <main+0x11c>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    31fa:	6b a1       	ldd	r22, Y+35	; 0x23
    31fc:	7c a1       	ldd	r23, Y+36	; 0x24
    31fe:	8d a1       	ldd	r24, Y+37	; 0x25
    3200:	9e a1       	ldd	r25, Y+38	; 0x26
    3202:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3206:	dc 01       	movw	r26, r24
    3208:	cb 01       	movw	r24, r22
    320a:	9a a3       	std	Y+34, r25	; 0x22
    320c:	89 a3       	std	Y+33, r24	; 0x21
    320e:	89 a1       	ldd	r24, Y+33	; 0x21
    3210:	9a a1       	ldd	r25, Y+34	; 0x22
    3212:	9e 8f       	std	Y+30, r25	; 0x1e
    3214:	8d 8f       	std	Y+29, r24	; 0x1d
    3216:	8d 8d       	ldd	r24, Y+29	; 0x1d
    3218:	9e 8d       	ldd	r25, Y+30	; 0x1e
    321a:	01 97       	sbiw	r24, 0x01	; 1
    321c:	f1 f7       	brne	.-4      	; 0x321a <main+0x114>
    321e:	9e 8f       	std	Y+30, r25	; 0x1e
    3220:	8d 8f       	std	Y+29, r24	; 0x1d
	_delay_ms(50000);
	LCD_voidClearScreen();
    3222:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>


	u8 Local_Counter=0,Local_Counter1=3,Local_flag=0;
    3226:	1e a6       	std	Y+46, r1	; 0x2e
    3228:	83 e0       	ldi	r24, 0x03	; 3
    322a:	8d a7       	std	Y+45, r24	; 0x2d
    322c:	1c a6       	std	Y+44, r1	; 0x2c
	while(1){

		u8 Local_u8pass;
		for(Local_Counter1=3;Local_Counter1>0;Local_Counter1--){
    322e:	83 e0       	ldi	r24, 0x03	; 3
    3230:	8d a7       	std	Y+45, r24	; 0x2d
    3232:	27 c1       	rjmp	.+590    	; 0x3482 <main+0x37c>
			LCD_voidSendString("Enter Your Pass");
    3234:	87 e7       	ldi	r24, 0x77	; 119
    3236:	90 e0       	ldi	r25, 0x00	; 0
    3238:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
			LCD_voidGoToXY(1,0);
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	60 e0       	ldi	r22, 0x00	; 0
    3240:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
			for(Local_Counter=0;Local_Counter<4;Local_Counter++){
    3244:	1e a6       	std	Y+46, r1	; 0x2e
    3246:	18 c0       	rjmp	.+48     	; 0x3278 <main+0x172>

				do{
					Local_u8pass=KPD_u8GetPressedKey();
    3248:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    324c:	8b a7       	std	Y+43, r24	; 0x2b

				}
				while(Local_u8pass==0xff );
    324e:	8b a5       	ldd	r24, Y+43	; 0x2b
    3250:	8f 3f       	cpi	r24, 0xFF	; 255
    3252:	d1 f3       	breq	.-12     	; 0x3248 <main+0x142>
				if(pass[Local_Counter]!=Local_u8pass){
    3254:	8e a5       	ldd	r24, Y+46	; 0x2e
    3256:	88 2f       	mov	r24, r24
    3258:	90 e0       	ldi	r25, 0x00	; 0
    325a:	fc 01       	movw	r30, r24
    325c:	ed 5d       	subi	r30, 0xDD	; 221
    325e:	fe 4f       	sbci	r31, 0xFE	; 254
    3260:	90 81       	ld	r25, Z
    3262:	8b a5       	ldd	r24, Y+43	; 0x2b
    3264:	98 17       	cp	r25, r24
    3266:	11 f0       	breq	.+4      	; 0x326c <main+0x166>
					Local_flag=1;
    3268:	81 e0       	ldi	r24, 0x01	; 1
    326a:	8c a7       	std	Y+44, r24	; 0x2c

				}

				LCD_voidSendData('*');
    326c:	8a e2       	ldi	r24, 0x2A	; 42
    326e:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <LCD_voidSendData>

		u8 Local_u8pass;
		for(Local_Counter1=3;Local_Counter1>0;Local_Counter1--){
			LCD_voidSendString("Enter Your Pass");
			LCD_voidGoToXY(1,0);
			for(Local_Counter=0;Local_Counter<4;Local_Counter++){
    3272:	8e a5       	ldd	r24, Y+46	; 0x2e
    3274:	8f 5f       	subi	r24, 0xFF	; 255
    3276:	8e a7       	std	Y+46, r24	; 0x2e
    3278:	8e a5       	ldd	r24, Y+46	; 0x2e
    327a:	84 30       	cpi	r24, 0x04	; 4
    327c:	28 f3       	brcs	.-54     	; 0x3248 <main+0x142>

				}

				LCD_voidSendData('*');
			}
			if(Local_flag==1){
    327e:	8c a5       	ldd	r24, Y+44	; 0x2c
    3280:	81 30       	cpi	r24, 0x01	; 1
    3282:	09 f0       	breq	.+2      	; 0x3286 <main+0x180>
    3284:	7e c0       	rjmp	.+252    	; 0x3382 <main+0x27c>
				LCD_voidGoToXY(1,0);
    3286:	81 e0       	ldi	r24, 0x01	; 1
    3288:	60 e0       	ldi	r22, 0x00	; 0
    328a:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
				LCD_voidSendString("Wrong Pass");
    328e:	87 e8       	ldi	r24, 0x87	; 135
    3290:	90 e0       	ldi	r25, 0x00	; 0
    3292:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
    3296:	80 e0       	ldi	r24, 0x00	; 0
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	aa ef       	ldi	r26, 0xFA	; 250
    329c:	b4 e4       	ldi	r27, 0x44	; 68
    329e:	89 8f       	std	Y+25, r24	; 0x19
    32a0:	9a 8f       	std	Y+26, r25	; 0x1a
    32a2:	ab 8f       	std	Y+27, r26	; 0x1b
    32a4:	bc 8f       	std	Y+28, r27	; 0x1c
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    32a6:	69 8d       	ldd	r22, Y+25	; 0x19
    32a8:	7a 8d       	ldd	r23, Y+26	; 0x1a
    32aa:	8b 8d       	ldd	r24, Y+27	; 0x1b
    32ac:	9c 8d       	ldd	r25, Y+28	; 0x1c
    32ae:	20 e0       	ldi	r18, 0x00	; 0
    32b0:	30 e0       	ldi	r19, 0x00	; 0
    32b2:	4a e7       	ldi	r20, 0x7A	; 122
    32b4:	53 e4       	ldi	r21, 0x43	; 67
    32b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    32ba:	dc 01       	movw	r26, r24
    32bc:	cb 01       	movw	r24, r22
    32be:	8d 8b       	std	Y+21, r24	; 0x15
    32c0:	9e 8b       	std	Y+22, r25	; 0x16
    32c2:	af 8b       	std	Y+23, r26	; 0x17
    32c4:	b8 8f       	std	Y+24, r27	; 0x18
	if (__tmp < 1.0)
    32c6:	6d 89       	ldd	r22, Y+21	; 0x15
    32c8:	7e 89       	ldd	r23, Y+22	; 0x16
    32ca:	8f 89       	ldd	r24, Y+23	; 0x17
    32cc:	98 8d       	ldd	r25, Y+24	; 0x18
    32ce:	20 e0       	ldi	r18, 0x00	; 0
    32d0:	30 e0       	ldi	r19, 0x00	; 0
    32d2:	40 e8       	ldi	r20, 0x80	; 128
    32d4:	5f e3       	ldi	r21, 0x3F	; 63
    32d6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    32da:	88 23       	and	r24, r24
    32dc:	2c f4       	brge	.+10     	; 0x32e8 <main+0x1e2>
		__ticks = 1;
    32de:	81 e0       	ldi	r24, 0x01	; 1
    32e0:	90 e0       	ldi	r25, 0x00	; 0
    32e2:	9c 8b       	std	Y+20, r25	; 0x14
    32e4:	8b 8b       	std	Y+19, r24	; 0x13
    32e6:	3f c0       	rjmp	.+126    	; 0x3366 <main+0x260>
	else if (__tmp > 65535)
    32e8:	6d 89       	ldd	r22, Y+21	; 0x15
    32ea:	7e 89       	ldd	r23, Y+22	; 0x16
    32ec:	8f 89       	ldd	r24, Y+23	; 0x17
    32ee:	98 8d       	ldd	r25, Y+24	; 0x18
    32f0:	20 e0       	ldi	r18, 0x00	; 0
    32f2:	3f ef       	ldi	r19, 0xFF	; 255
    32f4:	4f e7       	ldi	r20, 0x7F	; 127
    32f6:	57 e4       	ldi	r21, 0x47	; 71
    32f8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    32fc:	18 16       	cp	r1, r24
    32fe:	4c f5       	brge	.+82     	; 0x3352 <main+0x24c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3300:	69 8d       	ldd	r22, Y+25	; 0x19
    3302:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3304:	8b 8d       	ldd	r24, Y+27	; 0x1b
    3306:	9c 8d       	ldd	r25, Y+28	; 0x1c
    3308:	20 e0       	ldi	r18, 0x00	; 0
    330a:	30 e0       	ldi	r19, 0x00	; 0
    330c:	40 e2       	ldi	r20, 0x20	; 32
    330e:	51 e4       	ldi	r21, 0x41	; 65
    3310:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3314:	dc 01       	movw	r26, r24
    3316:	cb 01       	movw	r24, r22
    3318:	bc 01       	movw	r22, r24
    331a:	cd 01       	movw	r24, r26
    331c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3320:	dc 01       	movw	r26, r24
    3322:	cb 01       	movw	r24, r22
    3324:	9c 8b       	std	Y+20, r25	; 0x14
    3326:	8b 8b       	std	Y+19, r24	; 0x13
    3328:	0f c0       	rjmp	.+30     	; 0x3348 <main+0x242>
    332a:	89 e1       	ldi	r24, 0x19	; 25
    332c:	90 e0       	ldi	r25, 0x00	; 0
    332e:	9a 8b       	std	Y+18, r25	; 0x12
    3330:	89 8b       	std	Y+17, r24	; 0x11
    3332:	89 89       	ldd	r24, Y+17	; 0x11
    3334:	9a 89       	ldd	r25, Y+18	; 0x12
    3336:	01 97       	sbiw	r24, 0x01	; 1
    3338:	f1 f7       	brne	.-4      	; 0x3336 <main+0x230>
    333a:	9a 8b       	std	Y+18, r25	; 0x12
    333c:	89 8b       	std	Y+17, r24	; 0x11
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    333e:	8b 89       	ldd	r24, Y+19	; 0x13
    3340:	9c 89       	ldd	r25, Y+20	; 0x14
    3342:	01 97       	sbiw	r24, 0x01	; 1
    3344:	9c 8b       	std	Y+20, r25	; 0x14
    3346:	8b 8b       	std	Y+19, r24	; 0x13
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3348:	8b 89       	ldd	r24, Y+19	; 0x13
    334a:	9c 89       	ldd	r25, Y+20	; 0x14
    334c:	00 97       	sbiw	r24, 0x00	; 0
    334e:	69 f7       	brne	.-38     	; 0x332a <main+0x224>
    3350:	14 c0       	rjmp	.+40     	; 0x337a <main+0x274>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3352:	6d 89       	ldd	r22, Y+21	; 0x15
    3354:	7e 89       	ldd	r23, Y+22	; 0x16
    3356:	8f 89       	ldd	r24, Y+23	; 0x17
    3358:	98 8d       	ldd	r25, Y+24	; 0x18
    335a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    335e:	dc 01       	movw	r26, r24
    3360:	cb 01       	movw	r24, r22
    3362:	9c 8b       	std	Y+20, r25	; 0x14
    3364:	8b 8b       	std	Y+19, r24	; 0x13
    3366:	8b 89       	ldd	r24, Y+19	; 0x13
    3368:	9c 89       	ldd	r25, Y+20	; 0x14
    336a:	98 8b       	std	Y+16, r25	; 0x10
    336c:	8f 87       	std	Y+15, r24	; 0x0f
    336e:	8f 85       	ldd	r24, Y+15	; 0x0f
    3370:	98 89       	ldd	r25, Y+16	; 0x10
    3372:	01 97       	sbiw	r24, 0x01	; 1
    3374:	f1 f7       	brne	.-4      	; 0x3372 <main+0x26c>
    3376:	98 8b       	std	Y+16, r25	; 0x10
    3378:	8f 87       	std	Y+15, r24	; 0x0f
				_delay_ms(2000);
				LCD_voidClearScreen();
    337a:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
				Local_flag=0;
    337e:	1c a6       	std	Y+44, r1	; 0x2c
    3380:	7d c0       	rjmp	.+250    	; 0x347c <main+0x376>
			}
			else if(Local_flag==0) {
    3382:	8c a5       	ldd	r24, Y+44	; 0x2c
    3384:	88 23       	and	r24, r24
    3386:	09 f0       	breq	.+2      	; 0x338a <main+0x284>
    3388:	79 c0       	rjmp	.+242    	; 0x347c <main+0x376>
				LCD_voidClearScreen();
    338a:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
				LCD_voidSendString("OH YOUR GOOD Man");
    338e:	82 e9       	ldi	r24, 0x92	; 146
    3390:	90 e0       	ldi	r25, 0x00	; 0
    3392:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
    3396:	80 e0       	ldi	r24, 0x00	; 0
    3398:	90 e0       	ldi	r25, 0x00	; 0
    339a:	aa ef       	ldi	r26, 0xFA	; 250
    339c:	b4 e4       	ldi	r27, 0x44	; 68
    339e:	8b 87       	std	Y+11, r24	; 0x0b
    33a0:	9c 87       	std	Y+12, r25	; 0x0c
    33a2:	ad 87       	std	Y+13, r26	; 0x0d
    33a4:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    33a6:	6b 85       	ldd	r22, Y+11	; 0x0b
    33a8:	7c 85       	ldd	r23, Y+12	; 0x0c
    33aa:	8d 85       	ldd	r24, Y+13	; 0x0d
    33ac:	9e 85       	ldd	r25, Y+14	; 0x0e
    33ae:	20 e0       	ldi	r18, 0x00	; 0
    33b0:	30 e0       	ldi	r19, 0x00	; 0
    33b2:	4a e7       	ldi	r20, 0x7A	; 122
    33b4:	53 e4       	ldi	r21, 0x43	; 67
    33b6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    33ba:	dc 01       	movw	r26, r24
    33bc:	cb 01       	movw	r24, r22
    33be:	8f 83       	std	Y+7, r24	; 0x07
    33c0:	98 87       	std	Y+8, r25	; 0x08
    33c2:	a9 87       	std	Y+9, r26	; 0x09
    33c4:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    33c6:	6f 81       	ldd	r22, Y+7	; 0x07
    33c8:	78 85       	ldd	r23, Y+8	; 0x08
    33ca:	89 85       	ldd	r24, Y+9	; 0x09
    33cc:	9a 85       	ldd	r25, Y+10	; 0x0a
    33ce:	20 e0       	ldi	r18, 0x00	; 0
    33d0:	30 e0       	ldi	r19, 0x00	; 0
    33d2:	40 e8       	ldi	r20, 0x80	; 128
    33d4:	5f e3       	ldi	r21, 0x3F	; 63
    33d6:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    33da:	88 23       	and	r24, r24
    33dc:	2c f4       	brge	.+10     	; 0x33e8 <main+0x2e2>
		__ticks = 1;
    33de:	81 e0       	ldi	r24, 0x01	; 1
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	9e 83       	std	Y+6, r25	; 0x06
    33e4:	8d 83       	std	Y+5, r24	; 0x05
    33e6:	3f c0       	rjmp	.+126    	; 0x3466 <main+0x360>
	else if (__tmp > 65535)
    33e8:	6f 81       	ldd	r22, Y+7	; 0x07
    33ea:	78 85       	ldd	r23, Y+8	; 0x08
    33ec:	89 85       	ldd	r24, Y+9	; 0x09
    33ee:	9a 85       	ldd	r25, Y+10	; 0x0a
    33f0:	20 e0       	ldi	r18, 0x00	; 0
    33f2:	3f ef       	ldi	r19, 0xFF	; 255
    33f4:	4f e7       	ldi	r20, 0x7F	; 127
    33f6:	57 e4       	ldi	r21, 0x47	; 71
    33f8:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    33fc:	18 16       	cp	r1, r24
    33fe:	4c f5       	brge	.+82     	; 0x3452 <main+0x34c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    3400:	6b 85       	ldd	r22, Y+11	; 0x0b
    3402:	7c 85       	ldd	r23, Y+12	; 0x0c
    3404:	8d 85       	ldd	r24, Y+13	; 0x0d
    3406:	9e 85       	ldd	r25, Y+14	; 0x0e
    3408:	20 e0       	ldi	r18, 0x00	; 0
    340a:	30 e0       	ldi	r19, 0x00	; 0
    340c:	40 e2       	ldi	r20, 0x20	; 32
    340e:	51 e4       	ldi	r21, 0x41	; 65
    3410:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    3414:	dc 01       	movw	r26, r24
    3416:	cb 01       	movw	r24, r22
    3418:	bc 01       	movw	r22, r24
    341a:	cd 01       	movw	r24, r26
    341c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    3420:	dc 01       	movw	r26, r24
    3422:	cb 01       	movw	r24, r22
    3424:	9e 83       	std	Y+6, r25	; 0x06
    3426:	8d 83       	std	Y+5, r24	; 0x05
    3428:	0f c0       	rjmp	.+30     	; 0x3448 <main+0x342>
    342a:	89 e1       	ldi	r24, 0x19	; 25
    342c:	90 e0       	ldi	r25, 0x00	; 0
    342e:	9c 83       	std	Y+4, r25	; 0x04
    3430:	8b 83       	std	Y+3, r24	; 0x03
    3432:	8b 81       	ldd	r24, Y+3	; 0x03
    3434:	9c 81       	ldd	r25, Y+4	; 0x04
    3436:	01 97       	sbiw	r24, 0x01	; 1
    3438:	f1 f7       	brne	.-4      	; 0x3436 <main+0x330>
    343a:	9c 83       	std	Y+4, r25	; 0x04
    343c:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    343e:	8d 81       	ldd	r24, Y+5	; 0x05
    3440:	9e 81       	ldd	r25, Y+6	; 0x06
    3442:	01 97       	sbiw	r24, 0x01	; 1
    3444:	9e 83       	std	Y+6, r25	; 0x06
    3446:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    3448:	8d 81       	ldd	r24, Y+5	; 0x05
    344a:	9e 81       	ldd	r25, Y+6	; 0x06
    344c:	00 97       	sbiw	r24, 0x00	; 0
    344e:	69 f7       	brne	.-38     	; 0x342a <main+0x324>
    3450:	1c c0       	rjmp	.+56     	; 0x348a <main+0x384>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    3452:	6f 81       	ldd	r22, Y+7	; 0x07
    3454:	78 85       	ldd	r23, Y+8	; 0x08
    3456:	89 85       	ldd	r24, Y+9	; 0x09
    3458:	9a 85       	ldd	r25, Y+10	; 0x0a
    345a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    345e:	dc 01       	movw	r26, r24
    3460:	cb 01       	movw	r24, r22
    3462:	9e 83       	std	Y+6, r25	; 0x06
    3464:	8d 83       	std	Y+5, r24	; 0x05
    3466:	8d 81       	ldd	r24, Y+5	; 0x05
    3468:	9e 81       	ldd	r25, Y+6	; 0x06
    346a:	9a 83       	std	Y+2, r25	; 0x02
    346c:	89 83       	std	Y+1, r24	; 0x01
    346e:	89 81       	ldd	r24, Y+1	; 0x01
    3470:	9a 81       	ldd	r25, Y+2	; 0x02
    3472:	01 97       	sbiw	r24, 0x01	; 1
    3474:	f1 f7       	brne	.-4      	; 0x3472 <main+0x36c>
    3476:	9a 83       	std	Y+2, r25	; 0x02
    3478:	89 83       	std	Y+1, r24	; 0x01
    347a:	07 c0       	rjmp	.+14     	; 0x348a <main+0x384>

	u8 Local_Counter=0,Local_Counter1=3,Local_flag=0;
	while(1){

		u8 Local_u8pass;
		for(Local_Counter1=3;Local_Counter1>0;Local_Counter1--){
    347c:	8d a5       	ldd	r24, Y+45	; 0x2d
    347e:	81 50       	subi	r24, 0x01	; 1
    3480:	8d a7       	std	Y+45, r24	; 0x2d
    3482:	8d a5       	ldd	r24, Y+45	; 0x2d
    3484:	88 23       	and	r24, r24
    3486:	09 f0       	breq	.+2      	; 0x348a <main+0x384>
    3488:	d5 ce       	rjmp	.-598    	; 0x3234 <main+0x12e>
				break;
			}
		}


		if(Local_Counter1==0){
    348a:	8d a5       	ldd	r24, Y+45	; 0x2d
    348c:	88 23       	and	r24, r24
    348e:	49 f4       	brne	.+18     	; 0x34a2 <main+0x39c>
			LCD_voidGoToXY(0,0);
    3490:	80 e0       	ldi	r24, 0x00	; 0
    3492:	60 e0       	ldi	r22, 0x00	; 0
    3494:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
			LCD_voidSendString("Sorry Try 3 Times");
    3498:	83 ea       	ldi	r24, 0xA3	; 163
    349a:	90 e0       	ldi	r25, 0x00	; 0
    349c:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
    34a0:	02 c0       	rjmp	.+4      	; 0x34a6 <main+0x3a0>
			break;
		}
		Options();
    34a2:	0e 94 05 1b 	call	0x360a	; 0x360a <Options>
    34a6:	80 e0       	ldi	r24, 0x00	; 0
    34a8:	90 e0       	ldi	r25, 0x00	; 0

		break;
	}


}
    34aa:	ae 96       	adiw	r28, 0x2e	; 46
    34ac:	0f b6       	in	r0, 0x3f	; 63
    34ae:	f8 94       	cli
    34b0:	de bf       	out	0x3e, r29	; 62
    34b2:	0f be       	out	0x3f, r0	; 63
    34b4:	cd bf       	out	0x3d, r28	; 61
    34b6:	cf 91       	pop	r28
    34b8:	df 91       	pop	r29
    34ba:	08 95       	ret

000034bc <ROOM_OPTIONS>:
#include "LCD_INTERFACE.h"
#include "keypad.h"
#include "main_confgration.h"
#include "SPI_INTERFACE.h"
#include <util/delay.h>
void ROOM_OPTIONS(u8 roomnum){
    34bc:	df 93       	push	r29
    34be:	cf 93       	push	r28
    34c0:	00 d0       	rcall	.+0      	; 0x34c2 <ROOM_OPTIONS+0x6>
    34c2:	0f 92       	push	r0
    34c4:	cd b7       	in	r28, 0x3d	; 61
    34c6:	de b7       	in	r29, 0x3e	; 62
    34c8:	8b 83       	std	Y+3, r24	; 0x03
	u8 Local_press=0,Local_flag=0;
    34ca:	1a 82       	std	Y+2, r1	; 0x02
    34cc:	19 82       	std	Y+1, r1	; 0x01
	}
	else if(roomnum=='2'){

			spi_transmit(roomnum);
		}*/
	if(roomnum=='1'){
    34ce:	8b 81       	ldd	r24, Y+3	; 0x03
    34d0:	81 33       	cpi	r24, 0x31	; 49
    34d2:	59 f4       	brne	.+22     	; 0x34ea <ROOM_OPTIONS+0x2e>
		DIO_u8SetPinDir(DIO_PORTD,DIO_PIN3,DIO_PIN_OUT);
    34d4:	83 e0       	ldi	r24, 0x03	; 3
    34d6:	63 e0       	ldi	r22, 0x03	; 3
    34d8:	41 e0       	ldi	r20, 0x01	; 1
    34da:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
		DIO_u8SetPinValue(DIO_PORTD,DIO_PIN3,DIO_HIGH);}
    34de:	83 e0       	ldi	r24, 0x03	; 3
    34e0:	63 e0       	ldi	r22, 0x03	; 3
    34e2:	41 e0       	ldi	r20, 0x01	; 1
    34e4:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
    34e8:	0d c0       	rjmp	.+26     	; 0x3504 <ROOM_OPTIONS+0x48>
	else if(roomnum=='2'){
    34ea:	8b 81       	ldd	r24, Y+3	; 0x03
    34ec:	82 33       	cpi	r24, 0x32	; 50
    34ee:	51 f4       	brne	.+20     	; 0x3504 <ROOM_OPTIONS+0x48>
		DIO_u8SetPinDir(DIO_PORTD,DIO_PIN4,DIO_PIN_OUT);
    34f0:	83 e0       	ldi	r24, 0x03	; 3
    34f2:	64 e0       	ldi	r22, 0x04	; 4
    34f4:	41 e0       	ldi	r20, 0x01	; 1
    34f6:	0e 94 82 0a 	call	0x1504	; 0x1504 <DIO_u8SetPinDir>
		DIO_u8SetPinValue(DIO_PORTD,DIO_PIN4,DIO_HIGH);
    34fa:	83 e0       	ldi	r24, 0x03	; 3
    34fc:	64 e0       	ldi	r22, 0x04	; 4
    34fe:	41 e0       	ldi	r20, 0x01	; 1
    3500:	0e 94 1e 09 	call	0x123c	; 0x123c <DIO_u8SetPinValue>
	}

	LCD_voidClearScreen();
    3504:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
	LCD_voidSendString("1-LIGHT ");
    3508:	85 eb       	ldi	r24, 0xB5	; 181
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	LCD_voidGoToXY(0,7);
    3510:	80 e0       	ldi	r24, 0x00	; 0
    3512:	67 e0       	ldi	r22, 0x07	; 7
    3514:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
	LCD_voidSendString("2-AC ");
    3518:	8e eb       	ldi	r24, 0xBE	; 190
    351a:	90 e0       	ldi	r25, 0x00	; 0
    351c:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	LCD_voidGoToXY(1,0);
    3520:	81 e0       	ldi	r24, 0x01	; 1
    3522:	60 e0       	ldi	r22, 0x00	; 0
    3524:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
	LCD_voidSendString("3-TV ");
    3528:	84 ec       	ldi	r24, 0xC4	; 196
    352a:	90 e0       	ldi	r25, 0x00	; 0
    352c:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	LCD_voidGoToXY(1,7);
    3530:	81 e0       	ldi	r24, 0x01	; 1
    3532:	67 e0       	ldi	r22, 0x07	; 7
    3534:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
	LCD_voidSendString("4-TEMP");
    3538:	8a ec       	ldi	r24, 0xCA	; 202
    353a:	90 e0       	ldi	r25, 0x00	; 0
    353c:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	do{
		Local_press=KPD_u8GetPressedKey();
    3540:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    3544:	8a 83       	std	Y+2, r24	; 0x02

	}
	while(Local_press==0xff );
    3546:	8a 81       	ldd	r24, Y+2	; 0x02
    3548:	8f 3f       	cpi	r24, 0xFF	; 255
    354a:	d1 f3       	breq	.-12     	; 0x3540 <ROOM_OPTIONS+0x84>

	spi_transmit(Local_press);
    354c:	8a 81       	ldd	r24, Y+2	; 0x02
    354e:	0e 94 9f 22 	call	0x453e	; 0x453e <spi_transmit>
     /*CONTROLL LED*/
	if(Local_press=='1'){
    3552:	8a 81       	ldd	r24, Y+2	; 0x02
    3554:	81 33       	cpi	r24, 0x31	; 49
    3556:	c1 f4       	brne	.+48     	; 0x3588 <ROOM_OPTIONS+0xcc>
		LCD_voidClearScreen();
    3558:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
		LCD_voidSendString("1-ON ");
    355c:	81 ed       	ldi	r24, 0xD1	; 209
    355e:	90 e0       	ldi	r25, 0x00	; 0
    3560:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		LCD_voidGoToXY(0,7);
    3564:	80 e0       	ldi	r24, 0x00	; 0
    3566:	67 e0       	ldi	r22, 0x07	; 7
    3568:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
		LCD_voidSendString("2-OFF");
    356c:	87 ed       	ldi	r24, 0xD7	; 215
    356e:	90 e0       	ldi	r25, 0x00	; 0
    3570:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		do{
			Local_press=KPD_u8GetPressedKey();
    3574:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    3578:	8a 83       	std	Y+2, r24	; 0x02

		}
		while(Local_press==0xff );
    357a:	8a 81       	ldd	r24, Y+2	; 0x02
    357c:	8f 3f       	cpi	r24, 0xFF	; 255
    357e:	d1 f3       	breq	.-12     	; 0x3574 <ROOM_OPTIONS+0xb8>
		spi_transmit(Local_press);
    3580:	8a 81       	ldd	r24, Y+2	; 0x02
    3582:	0e 94 9f 22 	call	0x453e	; 0x453e <spi_transmit>
    3586:	3b c0       	rjmp	.+118    	; 0x35fe <ROOM_OPTIONS+0x142>

	}
	/*CONTROLL AC*/
	else if(Local_press=='2')
    3588:	8a 81       	ldd	r24, Y+2	; 0x02
    358a:	82 33       	cpi	r24, 0x32	; 50
    358c:	c1 f4       	brne	.+48     	; 0x35be <ROOM_OPTIONS+0x102>
	{
		LCD_voidClearScreen();
    358e:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
		LCD_voidSendString("1-ON ");
    3592:	81 ed       	ldi	r24, 0xD1	; 209
    3594:	90 e0       	ldi	r25, 0x00	; 0
    3596:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		LCD_voidGoToXY(0,7);
    359a:	80 e0       	ldi	r24, 0x00	; 0
    359c:	67 e0       	ldi	r22, 0x07	; 7
    359e:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
		LCD_voidSendString("2-OFF");
    35a2:	87 ed       	ldi	r24, 0xD7	; 215
    35a4:	90 e0       	ldi	r25, 0x00	; 0
    35a6:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		do{
			Local_press=KPD_u8GetPressedKey();
    35aa:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    35ae:	8a 83       	std	Y+2, r24	; 0x02

		}
		while(Local_press==0xff );
    35b0:	8a 81       	ldd	r24, Y+2	; 0x02
    35b2:	8f 3f       	cpi	r24, 0xFF	; 255
    35b4:	d1 f3       	breq	.-12     	; 0x35aa <ROOM_OPTIONS+0xee>
		spi_transmit(Local_press);
    35b6:	8a 81       	ldd	r24, Y+2	; 0x02
    35b8:	0e 94 9f 22 	call	0x453e	; 0x453e <spi_transmit>
    35bc:	20 c0       	rjmp	.+64     	; 0x35fe <ROOM_OPTIONS+0x142>


	}
	/*CONTROLL TV*/
	else if(Local_press=='3')
    35be:	8a 81       	ldd	r24, Y+2	; 0x02
    35c0:	83 33       	cpi	r24, 0x33	; 51
    35c2:	c1 f4       	brne	.+48     	; 0x35f4 <ROOM_OPTIONS+0x138>
	{
		LCD_voidClearScreen();
    35c4:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
		LCD_voidSendString("1-ON ");
    35c8:	81 ed       	ldi	r24, 0xD1	; 209
    35ca:	90 e0       	ldi	r25, 0x00	; 0
    35cc:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		LCD_voidGoToXY(0,7);
    35d0:	80 e0       	ldi	r24, 0x00	; 0
    35d2:	67 e0       	ldi	r22, 0x07	; 7
    35d4:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
		LCD_voidSendString("2-OFF");
    35d8:	87 ed       	ldi	r24, 0xD7	; 215
    35da:	90 e0       	ldi	r25, 0x00	; 0
    35dc:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
		do{
			Local_press=KPD_u8GetPressedKey();
    35e0:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    35e4:	8a 83       	std	Y+2, r24	; 0x02

		}
		while(Local_press==0xff );
    35e6:	8a 81       	ldd	r24, Y+2	; 0x02
    35e8:	8f 3f       	cpi	r24, 0xFF	; 255
    35ea:	d1 f3       	breq	.-12     	; 0x35e0 <ROOM_OPTIONS+0x124>
		spi_transmit(Local_press);
    35ec:	8a 81       	ldd	r24, Y+2	; 0x02
    35ee:	0e 94 9f 22 	call	0x453e	; 0x453e <spi_transmit>
    35f2:	05 c0       	rjmp	.+10     	; 0x35fe <ROOM_OPTIONS+0x142>

	}
	/*CONTROLL TEMP*/
	else if(Local_press=='4'){
    35f4:	8a 81       	ldd	r24, Y+2	; 0x02
    35f6:	84 33       	cpi	r24, 0x34	; 52
    35f8:	11 f4       	brne	.+4      	; 0x35fe <ROOM_OPTIONS+0x142>
		LCD_voidClearScreen();
    35fa:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>

	}



}
    35fe:	0f 90       	pop	r0
    3600:	0f 90       	pop	r0
    3602:	0f 90       	pop	r0
    3604:	cf 91       	pop	r28
    3606:	df 91       	pop	r29
    3608:	08 95       	ret

0000360a <Options>:



void Options(void){
    360a:	df 93       	push	r29
    360c:	cf 93       	push	r28
    360e:	00 d0       	rcall	.+0      	; 0x3610 <Options+0x6>
    3610:	cd b7       	in	r28, 0x3d	; 61
    3612:	de b7       	in	r29, 0x3e	; 62
	u8 Local_press=0,Local_flag=0;
    3614:	1a 82       	std	Y+2, r1	; 0x02
    3616:	19 82       	std	Y+1, r1	; 0x01
	LCD_voidClearScreen();
    3618:	0e 94 53 11 	call	0x22a6	; 0x22a6 <LCD_voidClearScreen>
	LCD_voidSendString("1-ROOM1:");
    361c:	8d ed       	ldi	r24, 0xDD	; 221
    361e:	90 e0       	ldi	r25, 0x00	; 0
    3620:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>
	LCD_voidGoToXY(1,0);
    3624:	81 e0       	ldi	r24, 0x01	; 1
    3626:	60 e0       	ldi	r22, 0x00	; 0
    3628:	0e 94 c2 10 	call	0x2184	; 0x2184 <LCD_voidGoToXY>
	LCD_voidSendString("2-ROOM2:");
    362c:	86 ee       	ldi	r24, 0xE6	; 230
    362e:	90 e0       	ldi	r25, 0x00	; 0
    3630:	0e 94 99 10 	call	0x2132	; 0x2132 <LCD_voidSendString>

	do{
		Local_press=KPD_u8GetPressedKey();
    3634:	0e 94 d0 16 	call	0x2da0	; 0x2da0 <KPD_u8GetPressedKey>
    3638:	8a 83       	std	Y+2, r24	; 0x02

	}
	while(Local_press==0xff );
    363a:	8a 81       	ldd	r24, Y+2	; 0x02
    363c:	8f 3f       	cpi	r24, 0xFF	; 255
    363e:	d1 f3       	breq	.-12     	; 0x3634 <Options+0x2a>


	if(Local_press!=0){
    3640:	8a 81       	ldd	r24, Y+2	; 0x02
    3642:	88 23       	and	r24, r24
    3644:	11 f0       	breq	.+4      	; 0x364a <Options+0x40>
		Local_flag=1;
    3646:	81 e0       	ldi	r24, 0x01	; 1
    3648:	89 83       	std	Y+1, r24	; 0x01

	}
	if(Local_flag==1){
    364a:	89 81       	ldd	r24, Y+1	; 0x01
    364c:	81 30       	cpi	r24, 0x01	; 1
    364e:	49 f4       	brne	.+18     	; 0x3662 <Options+0x58>
		spi_transmit(Local_press);
    3650:	8a 81       	ldd	r24, Y+2	; 0x02
    3652:	0e 94 9f 22 	call	0x453e	; 0x453e <spi_transmit>
		LCD_voidSendData(Local_press);
    3656:	8a 81       	ldd	r24, Y+2	; 0x02
    3658:	0e 94 fb 0f 	call	0x1ff6	; 0x1ff6 <LCD_voidSendData>
		ROOM_OPTIONS(Local_press);
    365c:	8a 81       	ldd	r24, Y+2	; 0x02
    365e:	0e 94 5e 1a 	call	0x34bc	; 0x34bc <ROOM_OPTIONS>


	}

}
    3662:	0f 90       	pop	r0
    3664:	0f 90       	pop	r0
    3666:	cf 91       	pop	r28
    3668:	df 91       	pop	r29
    366a:	08 95       	ret

0000366c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    366c:	df 93       	push	r29
    366e:	cf 93       	push	r28
    3670:	cd b7       	in	r28, 0x3d	; 61
    3672:	de b7       	in	r29, 0x3e	; 62
    3674:	28 97       	sbiw	r28, 0x08	; 8
    3676:	0f b6       	in	r0, 0x3f	; 63
    3678:	f8 94       	cli
    367a:	de bf       	out	0x3e, r29	; 62
    367c:	0f be       	out	0x3f, r0	; 63
    367e:	cd bf       	out	0x3d, r28	; 61
    3680:	9c 83       	std	Y+4, r25	; 0x04
    3682:	8b 83       	std	Y+3, r24	; 0x03
    3684:	7e 83       	std	Y+6, r23	; 0x06
    3686:	6d 83       	std	Y+5, r22	; 0x05
    3688:	58 87       	std	Y+8, r21	; 0x08
    368a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    368c:	eb 81       	ldd	r30, Y+3	; 0x03
    368e:	fc 81       	ldd	r31, Y+4	; 0x04
    3690:	81 e1       	ldi	r24, 0x11	; 17
    3692:	80 83       	st	Z, r24
	pxTopOfStack--;
    3694:	8b 81       	ldd	r24, Y+3	; 0x03
    3696:	9c 81       	ldd	r25, Y+4	; 0x04
    3698:	01 97       	sbiw	r24, 0x01	; 1
    369a:	9c 83       	std	Y+4, r25	; 0x04
    369c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    369e:	eb 81       	ldd	r30, Y+3	; 0x03
    36a0:	fc 81       	ldd	r31, Y+4	; 0x04
    36a2:	82 e2       	ldi	r24, 0x22	; 34
    36a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    36a6:	8b 81       	ldd	r24, Y+3	; 0x03
    36a8:	9c 81       	ldd	r25, Y+4	; 0x04
    36aa:	01 97       	sbiw	r24, 0x01	; 1
    36ac:	9c 83       	std	Y+4, r25	; 0x04
    36ae:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    36b0:	eb 81       	ldd	r30, Y+3	; 0x03
    36b2:	fc 81       	ldd	r31, Y+4	; 0x04
    36b4:	83 e3       	ldi	r24, 0x33	; 51
    36b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    36b8:	8b 81       	ldd	r24, Y+3	; 0x03
    36ba:	9c 81       	ldd	r25, Y+4	; 0x04
    36bc:	01 97       	sbiw	r24, 0x01	; 1
    36be:	9c 83       	std	Y+4, r25	; 0x04
    36c0:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    36c2:	8d 81       	ldd	r24, Y+5	; 0x05
    36c4:	9e 81       	ldd	r25, Y+6	; 0x06
    36c6:	9a 83       	std	Y+2, r25	; 0x02
    36c8:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    36ca:	89 81       	ldd	r24, Y+1	; 0x01
    36cc:	eb 81       	ldd	r30, Y+3	; 0x03
    36ce:	fc 81       	ldd	r31, Y+4	; 0x04
    36d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    36d2:	8b 81       	ldd	r24, Y+3	; 0x03
    36d4:	9c 81       	ldd	r25, Y+4	; 0x04
    36d6:	01 97       	sbiw	r24, 0x01	; 1
    36d8:	9c 83       	std	Y+4, r25	; 0x04
    36da:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    36dc:	89 81       	ldd	r24, Y+1	; 0x01
    36de:	9a 81       	ldd	r25, Y+2	; 0x02
    36e0:	89 2f       	mov	r24, r25
    36e2:	99 27       	eor	r25, r25
    36e4:	9a 83       	std	Y+2, r25	; 0x02
    36e6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    36e8:	89 81       	ldd	r24, Y+1	; 0x01
    36ea:	eb 81       	ldd	r30, Y+3	; 0x03
    36ec:	fc 81       	ldd	r31, Y+4	; 0x04
    36ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    36f0:	8b 81       	ldd	r24, Y+3	; 0x03
    36f2:	9c 81       	ldd	r25, Y+4	; 0x04
    36f4:	01 97       	sbiw	r24, 0x01	; 1
    36f6:	9c 83       	std	Y+4, r25	; 0x04
    36f8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    36fa:	eb 81       	ldd	r30, Y+3	; 0x03
    36fc:	fc 81       	ldd	r31, Y+4	; 0x04
    36fe:	10 82       	st	Z, r1
	pxTopOfStack--;
    3700:	8b 81       	ldd	r24, Y+3	; 0x03
    3702:	9c 81       	ldd	r25, Y+4	; 0x04
    3704:	01 97       	sbiw	r24, 0x01	; 1
    3706:	9c 83       	std	Y+4, r25	; 0x04
    3708:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    370a:	eb 81       	ldd	r30, Y+3	; 0x03
    370c:	fc 81       	ldd	r31, Y+4	; 0x04
    370e:	80 e8       	ldi	r24, 0x80	; 128
    3710:	80 83       	st	Z, r24
	pxTopOfStack--;
    3712:	8b 81       	ldd	r24, Y+3	; 0x03
    3714:	9c 81       	ldd	r25, Y+4	; 0x04
    3716:	01 97       	sbiw	r24, 0x01	; 1
    3718:	9c 83       	std	Y+4, r25	; 0x04
    371a:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    371c:	eb 81       	ldd	r30, Y+3	; 0x03
    371e:	fc 81       	ldd	r31, Y+4	; 0x04
    3720:	10 82       	st	Z, r1
	pxTopOfStack--;
    3722:	8b 81       	ldd	r24, Y+3	; 0x03
    3724:	9c 81       	ldd	r25, Y+4	; 0x04
    3726:	01 97       	sbiw	r24, 0x01	; 1
    3728:	9c 83       	std	Y+4, r25	; 0x04
    372a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    372c:	eb 81       	ldd	r30, Y+3	; 0x03
    372e:	fc 81       	ldd	r31, Y+4	; 0x04
    3730:	82 e0       	ldi	r24, 0x02	; 2
    3732:	80 83       	st	Z, r24
	pxTopOfStack--;
    3734:	8b 81       	ldd	r24, Y+3	; 0x03
    3736:	9c 81       	ldd	r25, Y+4	; 0x04
    3738:	01 97       	sbiw	r24, 0x01	; 1
    373a:	9c 83       	std	Y+4, r25	; 0x04
    373c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    373e:	eb 81       	ldd	r30, Y+3	; 0x03
    3740:	fc 81       	ldd	r31, Y+4	; 0x04
    3742:	83 e0       	ldi	r24, 0x03	; 3
    3744:	80 83       	st	Z, r24
	pxTopOfStack--;
    3746:	8b 81       	ldd	r24, Y+3	; 0x03
    3748:	9c 81       	ldd	r25, Y+4	; 0x04
    374a:	01 97       	sbiw	r24, 0x01	; 1
    374c:	9c 83       	std	Y+4, r25	; 0x04
    374e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    3750:	eb 81       	ldd	r30, Y+3	; 0x03
    3752:	fc 81       	ldd	r31, Y+4	; 0x04
    3754:	84 e0       	ldi	r24, 0x04	; 4
    3756:	80 83       	st	Z, r24
	pxTopOfStack--;
    3758:	8b 81       	ldd	r24, Y+3	; 0x03
    375a:	9c 81       	ldd	r25, Y+4	; 0x04
    375c:	01 97       	sbiw	r24, 0x01	; 1
    375e:	9c 83       	std	Y+4, r25	; 0x04
    3760:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    3762:	eb 81       	ldd	r30, Y+3	; 0x03
    3764:	fc 81       	ldd	r31, Y+4	; 0x04
    3766:	85 e0       	ldi	r24, 0x05	; 5
    3768:	80 83       	st	Z, r24
	pxTopOfStack--;
    376a:	8b 81       	ldd	r24, Y+3	; 0x03
    376c:	9c 81       	ldd	r25, Y+4	; 0x04
    376e:	01 97       	sbiw	r24, 0x01	; 1
    3770:	9c 83       	std	Y+4, r25	; 0x04
    3772:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    3774:	eb 81       	ldd	r30, Y+3	; 0x03
    3776:	fc 81       	ldd	r31, Y+4	; 0x04
    3778:	86 e0       	ldi	r24, 0x06	; 6
    377a:	80 83       	st	Z, r24
	pxTopOfStack--;
    377c:	8b 81       	ldd	r24, Y+3	; 0x03
    377e:	9c 81       	ldd	r25, Y+4	; 0x04
    3780:	01 97       	sbiw	r24, 0x01	; 1
    3782:	9c 83       	std	Y+4, r25	; 0x04
    3784:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    3786:	eb 81       	ldd	r30, Y+3	; 0x03
    3788:	fc 81       	ldd	r31, Y+4	; 0x04
    378a:	87 e0       	ldi	r24, 0x07	; 7
    378c:	80 83       	st	Z, r24
	pxTopOfStack--;
    378e:	8b 81       	ldd	r24, Y+3	; 0x03
    3790:	9c 81       	ldd	r25, Y+4	; 0x04
    3792:	01 97       	sbiw	r24, 0x01	; 1
    3794:	9c 83       	std	Y+4, r25	; 0x04
    3796:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    3798:	eb 81       	ldd	r30, Y+3	; 0x03
    379a:	fc 81       	ldd	r31, Y+4	; 0x04
    379c:	88 e0       	ldi	r24, 0x08	; 8
    379e:	80 83       	st	Z, r24
	pxTopOfStack--;
    37a0:	8b 81       	ldd	r24, Y+3	; 0x03
    37a2:	9c 81       	ldd	r25, Y+4	; 0x04
    37a4:	01 97       	sbiw	r24, 0x01	; 1
    37a6:	9c 83       	std	Y+4, r25	; 0x04
    37a8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    37aa:	eb 81       	ldd	r30, Y+3	; 0x03
    37ac:	fc 81       	ldd	r31, Y+4	; 0x04
    37ae:	89 e0       	ldi	r24, 0x09	; 9
    37b0:	80 83       	st	Z, r24
	pxTopOfStack--;
    37b2:	8b 81       	ldd	r24, Y+3	; 0x03
    37b4:	9c 81       	ldd	r25, Y+4	; 0x04
    37b6:	01 97       	sbiw	r24, 0x01	; 1
    37b8:	9c 83       	std	Y+4, r25	; 0x04
    37ba:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    37bc:	eb 81       	ldd	r30, Y+3	; 0x03
    37be:	fc 81       	ldd	r31, Y+4	; 0x04
    37c0:	80 e1       	ldi	r24, 0x10	; 16
    37c2:	80 83       	st	Z, r24
	pxTopOfStack--;
    37c4:	8b 81       	ldd	r24, Y+3	; 0x03
    37c6:	9c 81       	ldd	r25, Y+4	; 0x04
    37c8:	01 97       	sbiw	r24, 0x01	; 1
    37ca:	9c 83       	std	Y+4, r25	; 0x04
    37cc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    37ce:	eb 81       	ldd	r30, Y+3	; 0x03
    37d0:	fc 81       	ldd	r31, Y+4	; 0x04
    37d2:	81 e1       	ldi	r24, 0x11	; 17
    37d4:	80 83       	st	Z, r24
	pxTopOfStack--;
    37d6:	8b 81       	ldd	r24, Y+3	; 0x03
    37d8:	9c 81       	ldd	r25, Y+4	; 0x04
    37da:	01 97       	sbiw	r24, 0x01	; 1
    37dc:	9c 83       	std	Y+4, r25	; 0x04
    37de:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    37e0:	eb 81       	ldd	r30, Y+3	; 0x03
    37e2:	fc 81       	ldd	r31, Y+4	; 0x04
    37e4:	82 e1       	ldi	r24, 0x12	; 18
    37e6:	80 83       	st	Z, r24
	pxTopOfStack--;
    37e8:	8b 81       	ldd	r24, Y+3	; 0x03
    37ea:	9c 81       	ldd	r25, Y+4	; 0x04
    37ec:	01 97       	sbiw	r24, 0x01	; 1
    37ee:	9c 83       	std	Y+4, r25	; 0x04
    37f0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    37f2:	eb 81       	ldd	r30, Y+3	; 0x03
    37f4:	fc 81       	ldd	r31, Y+4	; 0x04
    37f6:	83 e1       	ldi	r24, 0x13	; 19
    37f8:	80 83       	st	Z, r24
	pxTopOfStack--;
    37fa:	8b 81       	ldd	r24, Y+3	; 0x03
    37fc:	9c 81       	ldd	r25, Y+4	; 0x04
    37fe:	01 97       	sbiw	r24, 0x01	; 1
    3800:	9c 83       	std	Y+4, r25	; 0x04
    3802:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    3804:	eb 81       	ldd	r30, Y+3	; 0x03
    3806:	fc 81       	ldd	r31, Y+4	; 0x04
    3808:	84 e1       	ldi	r24, 0x14	; 20
    380a:	80 83       	st	Z, r24
	pxTopOfStack--;
    380c:	8b 81       	ldd	r24, Y+3	; 0x03
    380e:	9c 81       	ldd	r25, Y+4	; 0x04
    3810:	01 97       	sbiw	r24, 0x01	; 1
    3812:	9c 83       	std	Y+4, r25	; 0x04
    3814:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    3816:	eb 81       	ldd	r30, Y+3	; 0x03
    3818:	fc 81       	ldd	r31, Y+4	; 0x04
    381a:	85 e1       	ldi	r24, 0x15	; 21
    381c:	80 83       	st	Z, r24
	pxTopOfStack--;
    381e:	8b 81       	ldd	r24, Y+3	; 0x03
    3820:	9c 81       	ldd	r25, Y+4	; 0x04
    3822:	01 97       	sbiw	r24, 0x01	; 1
    3824:	9c 83       	std	Y+4, r25	; 0x04
    3826:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    3828:	eb 81       	ldd	r30, Y+3	; 0x03
    382a:	fc 81       	ldd	r31, Y+4	; 0x04
    382c:	86 e1       	ldi	r24, 0x16	; 22
    382e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3830:	8b 81       	ldd	r24, Y+3	; 0x03
    3832:	9c 81       	ldd	r25, Y+4	; 0x04
    3834:	01 97       	sbiw	r24, 0x01	; 1
    3836:	9c 83       	std	Y+4, r25	; 0x04
    3838:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    383a:	eb 81       	ldd	r30, Y+3	; 0x03
    383c:	fc 81       	ldd	r31, Y+4	; 0x04
    383e:	87 e1       	ldi	r24, 0x17	; 23
    3840:	80 83       	st	Z, r24
	pxTopOfStack--;
    3842:	8b 81       	ldd	r24, Y+3	; 0x03
    3844:	9c 81       	ldd	r25, Y+4	; 0x04
    3846:	01 97       	sbiw	r24, 0x01	; 1
    3848:	9c 83       	std	Y+4, r25	; 0x04
    384a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    384c:	eb 81       	ldd	r30, Y+3	; 0x03
    384e:	fc 81       	ldd	r31, Y+4	; 0x04
    3850:	88 e1       	ldi	r24, 0x18	; 24
    3852:	80 83       	st	Z, r24
	pxTopOfStack--;
    3854:	8b 81       	ldd	r24, Y+3	; 0x03
    3856:	9c 81       	ldd	r25, Y+4	; 0x04
    3858:	01 97       	sbiw	r24, 0x01	; 1
    385a:	9c 83       	std	Y+4, r25	; 0x04
    385c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    385e:	eb 81       	ldd	r30, Y+3	; 0x03
    3860:	fc 81       	ldd	r31, Y+4	; 0x04
    3862:	89 e1       	ldi	r24, 0x19	; 25
    3864:	80 83       	st	Z, r24
	pxTopOfStack--;
    3866:	8b 81       	ldd	r24, Y+3	; 0x03
    3868:	9c 81       	ldd	r25, Y+4	; 0x04
    386a:	01 97       	sbiw	r24, 0x01	; 1
    386c:	9c 83       	std	Y+4, r25	; 0x04
    386e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    3870:	eb 81       	ldd	r30, Y+3	; 0x03
    3872:	fc 81       	ldd	r31, Y+4	; 0x04
    3874:	80 e2       	ldi	r24, 0x20	; 32
    3876:	80 83       	st	Z, r24
	pxTopOfStack--;
    3878:	8b 81       	ldd	r24, Y+3	; 0x03
    387a:	9c 81       	ldd	r25, Y+4	; 0x04
    387c:	01 97       	sbiw	r24, 0x01	; 1
    387e:	9c 83       	std	Y+4, r25	; 0x04
    3880:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    3882:	eb 81       	ldd	r30, Y+3	; 0x03
    3884:	fc 81       	ldd	r31, Y+4	; 0x04
    3886:	81 e2       	ldi	r24, 0x21	; 33
    3888:	80 83       	st	Z, r24
	pxTopOfStack--;
    388a:	8b 81       	ldd	r24, Y+3	; 0x03
    388c:	9c 81       	ldd	r25, Y+4	; 0x04
    388e:	01 97       	sbiw	r24, 0x01	; 1
    3890:	9c 83       	std	Y+4, r25	; 0x04
    3892:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    3894:	eb 81       	ldd	r30, Y+3	; 0x03
    3896:	fc 81       	ldd	r31, Y+4	; 0x04
    3898:	82 e2       	ldi	r24, 0x22	; 34
    389a:	80 83       	st	Z, r24
	pxTopOfStack--;
    389c:	8b 81       	ldd	r24, Y+3	; 0x03
    389e:	9c 81       	ldd	r25, Y+4	; 0x04
    38a0:	01 97       	sbiw	r24, 0x01	; 1
    38a2:	9c 83       	std	Y+4, r25	; 0x04
    38a4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    38a6:	eb 81       	ldd	r30, Y+3	; 0x03
    38a8:	fc 81       	ldd	r31, Y+4	; 0x04
    38aa:	83 e2       	ldi	r24, 0x23	; 35
    38ac:	80 83       	st	Z, r24
	pxTopOfStack--;
    38ae:	8b 81       	ldd	r24, Y+3	; 0x03
    38b0:	9c 81       	ldd	r25, Y+4	; 0x04
    38b2:	01 97       	sbiw	r24, 0x01	; 1
    38b4:	9c 83       	std	Y+4, r25	; 0x04
    38b6:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    38b8:	8f 81       	ldd	r24, Y+7	; 0x07
    38ba:	98 85       	ldd	r25, Y+8	; 0x08
    38bc:	9a 83       	std	Y+2, r25	; 0x02
    38be:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    38c0:	89 81       	ldd	r24, Y+1	; 0x01
    38c2:	eb 81       	ldd	r30, Y+3	; 0x03
    38c4:	fc 81       	ldd	r31, Y+4	; 0x04
    38c6:	80 83       	st	Z, r24
	pxTopOfStack--;
    38c8:	8b 81       	ldd	r24, Y+3	; 0x03
    38ca:	9c 81       	ldd	r25, Y+4	; 0x04
    38cc:	01 97       	sbiw	r24, 0x01	; 1
    38ce:	9c 83       	std	Y+4, r25	; 0x04
    38d0:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    38d2:	89 81       	ldd	r24, Y+1	; 0x01
    38d4:	9a 81       	ldd	r25, Y+2	; 0x02
    38d6:	89 2f       	mov	r24, r25
    38d8:	99 27       	eor	r25, r25
    38da:	9a 83       	std	Y+2, r25	; 0x02
    38dc:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    38de:	89 81       	ldd	r24, Y+1	; 0x01
    38e0:	eb 81       	ldd	r30, Y+3	; 0x03
    38e2:	fc 81       	ldd	r31, Y+4	; 0x04
    38e4:	80 83       	st	Z, r24
	pxTopOfStack--;
    38e6:	8b 81       	ldd	r24, Y+3	; 0x03
    38e8:	9c 81       	ldd	r25, Y+4	; 0x04
    38ea:	01 97       	sbiw	r24, 0x01	; 1
    38ec:	9c 83       	std	Y+4, r25	; 0x04
    38ee:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    38f0:	eb 81       	ldd	r30, Y+3	; 0x03
    38f2:	fc 81       	ldd	r31, Y+4	; 0x04
    38f4:	86 e2       	ldi	r24, 0x26	; 38
    38f6:	80 83       	st	Z, r24
	pxTopOfStack--;
    38f8:	8b 81       	ldd	r24, Y+3	; 0x03
    38fa:	9c 81       	ldd	r25, Y+4	; 0x04
    38fc:	01 97       	sbiw	r24, 0x01	; 1
    38fe:	9c 83       	std	Y+4, r25	; 0x04
    3900:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    3902:	eb 81       	ldd	r30, Y+3	; 0x03
    3904:	fc 81       	ldd	r31, Y+4	; 0x04
    3906:	87 e2       	ldi	r24, 0x27	; 39
    3908:	80 83       	st	Z, r24
	pxTopOfStack--;
    390a:	8b 81       	ldd	r24, Y+3	; 0x03
    390c:	9c 81       	ldd	r25, Y+4	; 0x04
    390e:	01 97       	sbiw	r24, 0x01	; 1
    3910:	9c 83       	std	Y+4, r25	; 0x04
    3912:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    3914:	eb 81       	ldd	r30, Y+3	; 0x03
    3916:	fc 81       	ldd	r31, Y+4	; 0x04
    3918:	88 e2       	ldi	r24, 0x28	; 40
    391a:	80 83       	st	Z, r24
	pxTopOfStack--;
    391c:	8b 81       	ldd	r24, Y+3	; 0x03
    391e:	9c 81       	ldd	r25, Y+4	; 0x04
    3920:	01 97       	sbiw	r24, 0x01	; 1
    3922:	9c 83       	std	Y+4, r25	; 0x04
    3924:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    3926:	eb 81       	ldd	r30, Y+3	; 0x03
    3928:	fc 81       	ldd	r31, Y+4	; 0x04
    392a:	89 e2       	ldi	r24, 0x29	; 41
    392c:	80 83       	st	Z, r24
	pxTopOfStack--;
    392e:	8b 81       	ldd	r24, Y+3	; 0x03
    3930:	9c 81       	ldd	r25, Y+4	; 0x04
    3932:	01 97       	sbiw	r24, 0x01	; 1
    3934:	9c 83       	std	Y+4, r25	; 0x04
    3936:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    3938:	eb 81       	ldd	r30, Y+3	; 0x03
    393a:	fc 81       	ldd	r31, Y+4	; 0x04
    393c:	80 e3       	ldi	r24, 0x30	; 48
    393e:	80 83       	st	Z, r24
	pxTopOfStack--;
    3940:	8b 81       	ldd	r24, Y+3	; 0x03
    3942:	9c 81       	ldd	r25, Y+4	; 0x04
    3944:	01 97       	sbiw	r24, 0x01	; 1
    3946:	9c 83       	std	Y+4, r25	; 0x04
    3948:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    394a:	eb 81       	ldd	r30, Y+3	; 0x03
    394c:	fc 81       	ldd	r31, Y+4	; 0x04
    394e:	81 e3       	ldi	r24, 0x31	; 49
    3950:	80 83       	st	Z, r24
	pxTopOfStack--;
    3952:	8b 81       	ldd	r24, Y+3	; 0x03
    3954:	9c 81       	ldd	r25, Y+4	; 0x04
    3956:	01 97       	sbiw	r24, 0x01	; 1
    3958:	9c 83       	std	Y+4, r25	; 0x04
    395a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    395c:	8b 81       	ldd	r24, Y+3	; 0x03
    395e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    3960:	28 96       	adiw	r28, 0x08	; 8
    3962:	0f b6       	in	r0, 0x3f	; 63
    3964:	f8 94       	cli
    3966:	de bf       	out	0x3e, r29	; 62
    3968:	0f be       	out	0x3f, r0	; 63
    396a:	cd bf       	out	0x3d, r28	; 61
    396c:	cf 91       	pop	r28
    396e:	df 91       	pop	r29
    3970:	08 95       	ret

00003972 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    3972:	df 93       	push	r29
    3974:	cf 93       	push	r28
    3976:	cd b7       	in	r28, 0x3d	; 61
    3978:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    397a:	0e 94 a9 1d 	call	0x3b52	; 0x3b52 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    397e:	a0 91 56 07 	lds	r26, 0x0756
    3982:	b0 91 57 07 	lds	r27, 0x0757
    3986:	cd 91       	ld	r28, X+
    3988:	cd bf       	out	0x3d, r28	; 61
    398a:	dd 91       	ld	r29, X+
    398c:	de bf       	out	0x3e, r29	; 62
    398e:	ff 91       	pop	r31
    3990:	ef 91       	pop	r30
    3992:	df 91       	pop	r29
    3994:	cf 91       	pop	r28
    3996:	bf 91       	pop	r27
    3998:	af 91       	pop	r26
    399a:	9f 91       	pop	r25
    399c:	8f 91       	pop	r24
    399e:	7f 91       	pop	r23
    39a0:	6f 91       	pop	r22
    39a2:	5f 91       	pop	r21
    39a4:	4f 91       	pop	r20
    39a6:	3f 91       	pop	r19
    39a8:	2f 91       	pop	r18
    39aa:	1f 91       	pop	r17
    39ac:	0f 91       	pop	r16
    39ae:	ff 90       	pop	r15
    39b0:	ef 90       	pop	r14
    39b2:	df 90       	pop	r13
    39b4:	cf 90       	pop	r12
    39b6:	bf 90       	pop	r11
    39b8:	af 90       	pop	r10
    39ba:	9f 90       	pop	r9
    39bc:	8f 90       	pop	r8
    39be:	7f 90       	pop	r7
    39c0:	6f 90       	pop	r6
    39c2:	5f 90       	pop	r5
    39c4:	4f 90       	pop	r4
    39c6:	3f 90       	pop	r3
    39c8:	2f 90       	pop	r2
    39ca:	1f 90       	pop	r1
    39cc:	0f 90       	pop	r0
    39ce:	0f be       	out	0x3f, r0	; 63
    39d0:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    39d2:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    39d4:	81 e0       	ldi	r24, 0x01	; 1
}
    39d6:	cf 91       	pop	r28
    39d8:	df 91       	pop	r29
    39da:	08 95       	ret

000039dc <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    39dc:	df 93       	push	r29
    39de:	cf 93       	push	r28
    39e0:	cd b7       	in	r28, 0x3d	; 61
    39e2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    39e4:	cf 91       	pop	r28
    39e6:	df 91       	pop	r29
    39e8:	08 95       	ret

000039ea <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    39ea:	0f 92       	push	r0
    39ec:	0f b6       	in	r0, 0x3f	; 63
    39ee:	f8 94       	cli
    39f0:	0f 92       	push	r0
    39f2:	1f 92       	push	r1
    39f4:	11 24       	eor	r1, r1
    39f6:	2f 92       	push	r2
    39f8:	3f 92       	push	r3
    39fa:	4f 92       	push	r4
    39fc:	5f 92       	push	r5
    39fe:	6f 92       	push	r6
    3a00:	7f 92       	push	r7
    3a02:	8f 92       	push	r8
    3a04:	9f 92       	push	r9
    3a06:	af 92       	push	r10
    3a08:	bf 92       	push	r11
    3a0a:	cf 92       	push	r12
    3a0c:	df 92       	push	r13
    3a0e:	ef 92       	push	r14
    3a10:	ff 92       	push	r15
    3a12:	0f 93       	push	r16
    3a14:	1f 93       	push	r17
    3a16:	2f 93       	push	r18
    3a18:	3f 93       	push	r19
    3a1a:	4f 93       	push	r20
    3a1c:	5f 93       	push	r21
    3a1e:	6f 93       	push	r22
    3a20:	7f 93       	push	r23
    3a22:	8f 93       	push	r24
    3a24:	9f 93       	push	r25
    3a26:	af 93       	push	r26
    3a28:	bf 93       	push	r27
    3a2a:	cf 93       	push	r28
    3a2c:	df 93       	push	r29
    3a2e:	ef 93       	push	r30
    3a30:	ff 93       	push	r31
    3a32:	a0 91 56 07 	lds	r26, 0x0756
    3a36:	b0 91 57 07 	lds	r27, 0x0757
    3a3a:	0d b6       	in	r0, 0x3d	; 61
    3a3c:	0d 92       	st	X+, r0
    3a3e:	0e b6       	in	r0, 0x3e	; 62
    3a40:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3a42:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3a46:	a0 91 56 07 	lds	r26, 0x0756
    3a4a:	b0 91 57 07 	lds	r27, 0x0757
    3a4e:	cd 91       	ld	r28, X+
    3a50:	cd bf       	out	0x3d, r28	; 61
    3a52:	dd 91       	ld	r29, X+
    3a54:	de bf       	out	0x3e, r29	; 62
    3a56:	ff 91       	pop	r31
    3a58:	ef 91       	pop	r30
    3a5a:	df 91       	pop	r29
    3a5c:	cf 91       	pop	r28
    3a5e:	bf 91       	pop	r27
    3a60:	af 91       	pop	r26
    3a62:	9f 91       	pop	r25
    3a64:	8f 91       	pop	r24
    3a66:	7f 91       	pop	r23
    3a68:	6f 91       	pop	r22
    3a6a:	5f 91       	pop	r21
    3a6c:	4f 91       	pop	r20
    3a6e:	3f 91       	pop	r19
    3a70:	2f 91       	pop	r18
    3a72:	1f 91       	pop	r17
    3a74:	0f 91       	pop	r16
    3a76:	ff 90       	pop	r15
    3a78:	ef 90       	pop	r14
    3a7a:	df 90       	pop	r13
    3a7c:	cf 90       	pop	r12
    3a7e:	bf 90       	pop	r11
    3a80:	af 90       	pop	r10
    3a82:	9f 90       	pop	r9
    3a84:	8f 90       	pop	r8
    3a86:	7f 90       	pop	r7
    3a88:	6f 90       	pop	r6
    3a8a:	5f 90       	pop	r5
    3a8c:	4f 90       	pop	r4
    3a8e:	3f 90       	pop	r3
    3a90:	2f 90       	pop	r2
    3a92:	1f 90       	pop	r1
    3a94:	0f 90       	pop	r0
    3a96:	0f be       	out	0x3f, r0	; 63
    3a98:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3a9a:	08 95       	ret

00003a9c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3a9c:	0f 92       	push	r0
    3a9e:	0f b6       	in	r0, 0x3f	; 63
    3aa0:	f8 94       	cli
    3aa2:	0f 92       	push	r0
    3aa4:	1f 92       	push	r1
    3aa6:	11 24       	eor	r1, r1
    3aa8:	2f 92       	push	r2
    3aaa:	3f 92       	push	r3
    3aac:	4f 92       	push	r4
    3aae:	5f 92       	push	r5
    3ab0:	6f 92       	push	r6
    3ab2:	7f 92       	push	r7
    3ab4:	8f 92       	push	r8
    3ab6:	9f 92       	push	r9
    3ab8:	af 92       	push	r10
    3aba:	bf 92       	push	r11
    3abc:	cf 92       	push	r12
    3abe:	df 92       	push	r13
    3ac0:	ef 92       	push	r14
    3ac2:	ff 92       	push	r15
    3ac4:	0f 93       	push	r16
    3ac6:	1f 93       	push	r17
    3ac8:	2f 93       	push	r18
    3aca:	3f 93       	push	r19
    3acc:	4f 93       	push	r20
    3ace:	5f 93       	push	r21
    3ad0:	6f 93       	push	r22
    3ad2:	7f 93       	push	r23
    3ad4:	8f 93       	push	r24
    3ad6:	9f 93       	push	r25
    3ad8:	af 93       	push	r26
    3ada:	bf 93       	push	r27
    3adc:	cf 93       	push	r28
    3ade:	df 93       	push	r29
    3ae0:	ef 93       	push	r30
    3ae2:	ff 93       	push	r31
    3ae4:	a0 91 56 07 	lds	r26, 0x0756
    3ae8:	b0 91 57 07 	lds	r27, 0x0757
    3aec:	0d b6       	in	r0, 0x3d	; 61
    3aee:	0d 92       	st	X+, r0
    3af0:	0e b6       	in	r0, 0x3e	; 62
    3af2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    3af4:	0e 94 c8 25 	call	0x4b90	; 0x4b90 <vTaskIncrementTick>
	vTaskSwitchContext();
    3af8:	0e 94 9d 26 	call	0x4d3a	; 0x4d3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3afc:	a0 91 56 07 	lds	r26, 0x0756
    3b00:	b0 91 57 07 	lds	r27, 0x0757
    3b04:	cd 91       	ld	r28, X+
    3b06:	cd bf       	out	0x3d, r28	; 61
    3b08:	dd 91       	ld	r29, X+
    3b0a:	de bf       	out	0x3e, r29	; 62
    3b0c:	ff 91       	pop	r31
    3b0e:	ef 91       	pop	r30
    3b10:	df 91       	pop	r29
    3b12:	cf 91       	pop	r28
    3b14:	bf 91       	pop	r27
    3b16:	af 91       	pop	r26
    3b18:	9f 91       	pop	r25
    3b1a:	8f 91       	pop	r24
    3b1c:	7f 91       	pop	r23
    3b1e:	6f 91       	pop	r22
    3b20:	5f 91       	pop	r21
    3b22:	4f 91       	pop	r20
    3b24:	3f 91       	pop	r19
    3b26:	2f 91       	pop	r18
    3b28:	1f 91       	pop	r17
    3b2a:	0f 91       	pop	r16
    3b2c:	ff 90       	pop	r15
    3b2e:	ef 90       	pop	r14
    3b30:	df 90       	pop	r13
    3b32:	cf 90       	pop	r12
    3b34:	bf 90       	pop	r11
    3b36:	af 90       	pop	r10
    3b38:	9f 90       	pop	r9
    3b3a:	8f 90       	pop	r8
    3b3c:	7f 90       	pop	r7
    3b3e:	6f 90       	pop	r6
    3b40:	5f 90       	pop	r5
    3b42:	4f 90       	pop	r4
    3b44:	3f 90       	pop	r3
    3b46:	2f 90       	pop	r2
    3b48:	1f 90       	pop	r1
    3b4a:	0f 90       	pop	r0
    3b4c:	0f be       	out	0x3f, r0	; 63
    3b4e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    3b50:	08 95       	ret

00003b52 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    3b52:	df 93       	push	r29
    3b54:	cf 93       	push	r28
    3b56:	00 d0       	rcall	.+0      	; 0x3b58 <prvSetupTimerInterrupt+0x6>
    3b58:	00 d0       	rcall	.+0      	; 0x3b5a <prvSetupTimerInterrupt+0x8>
    3b5a:	00 d0       	rcall	.+0      	; 0x3b5c <prvSetupTimerInterrupt+0xa>
    3b5c:	cd b7       	in	r28, 0x3d	; 61
    3b5e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    3b60:	80 e4       	ldi	r24, 0x40	; 64
    3b62:	9f e1       	ldi	r25, 0x1F	; 31
    3b64:	a0 e0       	ldi	r26, 0x00	; 0
    3b66:	b0 e0       	ldi	r27, 0x00	; 0
    3b68:	8b 83       	std	Y+3, r24	; 0x03
    3b6a:	9c 83       	std	Y+4, r25	; 0x04
    3b6c:	ad 83       	std	Y+5, r26	; 0x05
    3b6e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    3b70:	8b 81       	ldd	r24, Y+3	; 0x03
    3b72:	9c 81       	ldd	r25, Y+4	; 0x04
    3b74:	ad 81       	ldd	r26, Y+5	; 0x05
    3b76:	be 81       	ldd	r27, Y+6	; 0x06
    3b78:	68 94       	set
    3b7a:	15 f8       	bld	r1, 5
    3b7c:	b6 95       	lsr	r27
    3b7e:	a7 95       	ror	r26
    3b80:	97 95       	ror	r25
    3b82:	87 95       	ror	r24
    3b84:	16 94       	lsr	r1
    3b86:	d1 f7       	brne	.-12     	; 0x3b7c <prvSetupTimerInterrupt+0x2a>
    3b88:	8b 83       	std	Y+3, r24	; 0x03
    3b8a:	9c 83       	std	Y+4, r25	; 0x04
    3b8c:	ad 83       	std	Y+5, r26	; 0x05
    3b8e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    3b90:	8b 81       	ldd	r24, Y+3	; 0x03
    3b92:	9c 81       	ldd	r25, Y+4	; 0x04
    3b94:	ad 81       	ldd	r26, Y+5	; 0x05
    3b96:	be 81       	ldd	r27, Y+6	; 0x06
    3b98:	01 97       	sbiw	r24, 0x01	; 1
    3b9a:	a1 09       	sbc	r26, r1
    3b9c:	b1 09       	sbc	r27, r1
    3b9e:	8b 83       	std	Y+3, r24	; 0x03
    3ba0:	9c 83       	std	Y+4, r25	; 0x04
    3ba2:	ad 83       	std	Y+5, r26	; 0x05
    3ba4:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3ba6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ba8:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    3baa:	8b 81       	ldd	r24, Y+3	; 0x03
    3bac:	9c 81       	ldd	r25, Y+4	; 0x04
    3bae:	ad 81       	ldd	r26, Y+5	; 0x05
    3bb0:	be 81       	ldd	r27, Y+6	; 0x06
    3bb2:	89 2f       	mov	r24, r25
    3bb4:	9a 2f       	mov	r25, r26
    3bb6:	ab 2f       	mov	r26, r27
    3bb8:	bb 27       	eor	r27, r27
    3bba:	8b 83       	std	Y+3, r24	; 0x03
    3bbc:	9c 83       	std	Y+4, r25	; 0x04
    3bbe:	ad 83       	std	Y+5, r26	; 0x05
    3bc0:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    3bc2:	8b 81       	ldd	r24, Y+3	; 0x03
    3bc4:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    3bc6:	eb e4       	ldi	r30, 0x4B	; 75
    3bc8:	f0 e0       	ldi	r31, 0x00	; 0
    3bca:	8a 81       	ldd	r24, Y+2	; 0x02
    3bcc:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    3bce:	ea e4       	ldi	r30, 0x4A	; 74
    3bd0:	f0 e0       	ldi	r31, 0x00	; 0
    3bd2:	89 81       	ldd	r24, Y+1	; 0x01
    3bd4:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    3bd6:	8b e0       	ldi	r24, 0x0B	; 11
    3bd8:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    3bda:	ee e4       	ldi	r30, 0x4E	; 78
    3bdc:	f0 e0       	ldi	r31, 0x00	; 0
    3bde:	89 81       	ldd	r24, Y+1	; 0x01
    3be0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    3be2:	e9 e5       	ldi	r30, 0x59	; 89
    3be4:	f0 e0       	ldi	r31, 0x00	; 0
    3be6:	80 81       	ld	r24, Z
    3be8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    3bea:	89 81       	ldd	r24, Y+1	; 0x01
    3bec:	80 61       	ori	r24, 0x10	; 16
    3bee:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    3bf0:	e9 e5       	ldi	r30, 0x59	; 89
    3bf2:	f0 e0       	ldi	r31, 0x00	; 0
    3bf4:	89 81       	ldd	r24, Y+1	; 0x01
    3bf6:	80 83       	st	Z, r24
}
    3bf8:	26 96       	adiw	r28, 0x06	; 6
    3bfa:	0f b6       	in	r0, 0x3f	; 63
    3bfc:	f8 94       	cli
    3bfe:	de bf       	out	0x3e, r29	; 62
    3c00:	0f be       	out	0x3f, r0	; 63
    3c02:	cd bf       	out	0x3d, r28	; 61
    3c04:	cf 91       	pop	r28
    3c06:	df 91       	pop	r29
    3c08:	08 95       	ret

00003c0a <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    3c0a:	0e 94 4e 1d 	call	0x3a9c	; 0x3a9c <vPortYieldFromTick>
		asm volatile ( "reti" );
    3c0e:	18 95       	reti

00003c10 <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    3c10:	df 93       	push	r29
    3c12:	cf 93       	push	r28
    3c14:	cd b7       	in	r28, 0x3d	; 61
    3c16:	de b7       	in	r29, 0x3e	; 62
    3c18:	28 97       	sbiw	r28, 0x08	; 8
    3c1a:	0f b6       	in	r0, 0x3f	; 63
    3c1c:	f8 94       	cli
    3c1e:	de bf       	out	0x3e, r29	; 62
    3c20:	0f be       	out	0x3f, r0	; 63
    3c22:	cd bf       	out	0x3d, r28	; 61
    3c24:	8f 83       	std	Y+7, r24	; 0x07
    3c26:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    3c28:	1a 82       	std	Y+2, r1	; 0x02
    3c2a:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    3c2c:	8f 81       	ldd	r24, Y+7	; 0x07
    3c2e:	88 23       	and	r24, r24
    3c30:	09 f4       	brne	.+2      	; 0x3c34 <xQueueCreate+0x24>
    3c32:	8c c0       	rjmp	.+280    	; 0x3d4c <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    3c34:	8f e1       	ldi	r24, 0x1F	; 31
    3c36:	90 e0       	ldi	r25, 0x00	; 0
    3c38:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <pvPortMalloc>
    3c3c:	9e 83       	std	Y+6, r25	; 0x06
    3c3e:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    3c40:	8d 81       	ldd	r24, Y+5	; 0x05
    3c42:	9e 81       	ldd	r25, Y+6	; 0x06
    3c44:	00 97       	sbiw	r24, 0x00	; 0
    3c46:	09 f4       	brne	.+2      	; 0x3c4a <xQueueCreate+0x3a>
    3c48:	81 c0       	rjmp	.+258    	; 0x3d4c <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    3c4a:	8f 81       	ldd	r24, Y+7	; 0x07
    3c4c:	28 2f       	mov	r18, r24
    3c4e:	30 e0       	ldi	r19, 0x00	; 0
    3c50:	88 85       	ldd	r24, Y+8	; 0x08
    3c52:	88 2f       	mov	r24, r24
    3c54:	90 e0       	ldi	r25, 0x00	; 0
    3c56:	ac 01       	movw	r20, r24
    3c58:	24 9f       	mul	r18, r20
    3c5a:	c0 01       	movw	r24, r0
    3c5c:	25 9f       	mul	r18, r21
    3c5e:	90 0d       	add	r25, r0
    3c60:	34 9f       	mul	r19, r20
    3c62:	90 0d       	add	r25, r0
    3c64:	11 24       	eor	r1, r1
    3c66:	01 96       	adiw	r24, 0x01	; 1
    3c68:	9c 83       	std	Y+4, r25	; 0x04
    3c6a:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    3c6c:	8b 81       	ldd	r24, Y+3	; 0x03
    3c6e:	9c 81       	ldd	r25, Y+4	; 0x04
    3c70:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <pvPortMalloc>
    3c74:	ed 81       	ldd	r30, Y+5	; 0x05
    3c76:	fe 81       	ldd	r31, Y+6	; 0x06
    3c78:	91 83       	std	Z+1, r25	; 0x01
    3c7a:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    3c7c:	ed 81       	ldd	r30, Y+5	; 0x05
    3c7e:	fe 81       	ldd	r31, Y+6	; 0x06
    3c80:	80 81       	ld	r24, Z
    3c82:	91 81       	ldd	r25, Z+1	; 0x01
    3c84:	00 97       	sbiw	r24, 0x00	; 0
    3c86:	09 f4       	brne	.+2      	; 0x3c8a <xQueueCreate+0x7a>
    3c88:	5d c0       	rjmp	.+186    	; 0x3d44 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    3c8a:	ed 81       	ldd	r30, Y+5	; 0x05
    3c8c:	fe 81       	ldd	r31, Y+6	; 0x06
    3c8e:	40 81       	ld	r20, Z
    3c90:	51 81       	ldd	r21, Z+1	; 0x01
    3c92:	8f 81       	ldd	r24, Y+7	; 0x07
    3c94:	28 2f       	mov	r18, r24
    3c96:	30 e0       	ldi	r19, 0x00	; 0
    3c98:	88 85       	ldd	r24, Y+8	; 0x08
    3c9a:	88 2f       	mov	r24, r24
    3c9c:	90 e0       	ldi	r25, 0x00	; 0
    3c9e:	bc 01       	movw	r22, r24
    3ca0:	26 9f       	mul	r18, r22
    3ca2:	c0 01       	movw	r24, r0
    3ca4:	27 9f       	mul	r18, r23
    3ca6:	90 0d       	add	r25, r0
    3ca8:	36 9f       	mul	r19, r22
    3caa:	90 0d       	add	r25, r0
    3cac:	11 24       	eor	r1, r1
    3cae:	84 0f       	add	r24, r20
    3cb0:	95 1f       	adc	r25, r21
    3cb2:	ed 81       	ldd	r30, Y+5	; 0x05
    3cb4:	fe 81       	ldd	r31, Y+6	; 0x06
    3cb6:	93 83       	std	Z+3, r25	; 0x03
    3cb8:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    3cba:	ed 81       	ldd	r30, Y+5	; 0x05
    3cbc:	fe 81       	ldd	r31, Y+6	; 0x06
    3cbe:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    3cc0:	ed 81       	ldd	r30, Y+5	; 0x05
    3cc2:	fe 81       	ldd	r31, Y+6	; 0x06
    3cc4:	80 81       	ld	r24, Z
    3cc6:	91 81       	ldd	r25, Z+1	; 0x01
    3cc8:	ed 81       	ldd	r30, Y+5	; 0x05
    3cca:	fe 81       	ldd	r31, Y+6	; 0x06
    3ccc:	95 83       	std	Z+5, r25	; 0x05
    3cce:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    3cd0:	ed 81       	ldd	r30, Y+5	; 0x05
    3cd2:	fe 81       	ldd	r31, Y+6	; 0x06
    3cd4:	40 81       	ld	r20, Z
    3cd6:	51 81       	ldd	r21, Z+1	; 0x01
    3cd8:	8f 81       	ldd	r24, Y+7	; 0x07
    3cda:	88 2f       	mov	r24, r24
    3cdc:	90 e0       	ldi	r25, 0x00	; 0
    3cde:	9c 01       	movw	r18, r24
    3ce0:	21 50       	subi	r18, 0x01	; 1
    3ce2:	30 40       	sbci	r19, 0x00	; 0
    3ce4:	88 85       	ldd	r24, Y+8	; 0x08
    3ce6:	88 2f       	mov	r24, r24
    3ce8:	90 e0       	ldi	r25, 0x00	; 0
    3cea:	bc 01       	movw	r22, r24
    3cec:	26 9f       	mul	r18, r22
    3cee:	c0 01       	movw	r24, r0
    3cf0:	27 9f       	mul	r18, r23
    3cf2:	90 0d       	add	r25, r0
    3cf4:	36 9f       	mul	r19, r22
    3cf6:	90 0d       	add	r25, r0
    3cf8:	11 24       	eor	r1, r1
    3cfa:	84 0f       	add	r24, r20
    3cfc:	95 1f       	adc	r25, r21
    3cfe:	ed 81       	ldd	r30, Y+5	; 0x05
    3d00:	fe 81       	ldd	r31, Y+6	; 0x06
    3d02:	97 83       	std	Z+7, r25	; 0x07
    3d04:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    3d06:	ed 81       	ldd	r30, Y+5	; 0x05
    3d08:	fe 81       	ldd	r31, Y+6	; 0x06
    3d0a:	8f 81       	ldd	r24, Y+7	; 0x07
    3d0c:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    3d0e:	ed 81       	ldd	r30, Y+5	; 0x05
    3d10:	fe 81       	ldd	r31, Y+6	; 0x06
    3d12:	88 85       	ldd	r24, Y+8	; 0x08
    3d14:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    3d16:	ed 81       	ldd	r30, Y+5	; 0x05
    3d18:	fe 81       	ldd	r31, Y+6	; 0x06
    3d1a:	8f ef       	ldi	r24, 0xFF	; 255
    3d1c:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    3d1e:	ed 81       	ldd	r30, Y+5	; 0x05
    3d20:	fe 81       	ldd	r31, Y+6	; 0x06
    3d22:	8f ef       	ldi	r24, 0xFF	; 255
    3d24:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    3d26:	8d 81       	ldd	r24, Y+5	; 0x05
    3d28:	9e 81       	ldd	r25, Y+6	; 0x06
    3d2a:	08 96       	adiw	r24, 0x08	; 8
    3d2c:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    3d30:	8d 81       	ldd	r24, Y+5	; 0x05
    3d32:	9e 81       	ldd	r25, Y+6	; 0x06
    3d34:	41 96       	adiw	r24, 0x11	; 17
    3d36:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    3d3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3d3c:	9e 81       	ldd	r25, Y+6	; 0x06
    3d3e:	9a 83       	std	Y+2, r25	; 0x02
    3d40:	89 83       	std	Y+1, r24	; 0x01
    3d42:	04 c0       	rjmp	.+8      	; 0x3d4c <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    3d44:	8d 81       	ldd	r24, Y+5	; 0x05
    3d46:	9e 81       	ldd	r25, Y+6	; 0x06
    3d48:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    3d4c:	89 81       	ldd	r24, Y+1	; 0x01
    3d4e:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3d50:	28 96       	adiw	r28, 0x08	; 8
    3d52:	0f b6       	in	r0, 0x3f	; 63
    3d54:	f8 94       	cli
    3d56:	de bf       	out	0x3e, r29	; 62
    3d58:	0f be       	out	0x3f, r0	; 63
    3d5a:	cd bf       	out	0x3d, r28	; 61
    3d5c:	cf 91       	pop	r28
    3d5e:	df 91       	pop	r29
    3d60:	08 95       	ret

00003d62 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    3d62:	df 93       	push	r29
    3d64:	cf 93       	push	r28
    3d66:	cd b7       	in	r28, 0x3d	; 61
    3d68:	de b7       	in	r29, 0x3e	; 62
    3d6a:	2c 97       	sbiw	r28, 0x0c	; 12
    3d6c:	0f b6       	in	r0, 0x3f	; 63
    3d6e:	f8 94       	cli
    3d70:	de bf       	out	0x3e, r29	; 62
    3d72:	0f be       	out	0x3f, r0	; 63
    3d74:	cd bf       	out	0x3d, r28	; 61
    3d76:	9e 83       	std	Y+6, r25	; 0x06
    3d78:	8d 83       	std	Y+5, r24	; 0x05
    3d7a:	78 87       	std	Y+8, r23	; 0x08
    3d7c:	6f 83       	std	Y+7, r22	; 0x07
    3d7e:	5a 87       	std	Y+10, r21	; 0x0a
    3d80:	49 87       	std	Y+9, r20	; 0x09
    3d82:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3d84:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    3d86:	0f b6       	in	r0, 0x3f	; 63
    3d88:	f8 94       	cli
    3d8a:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3d8c:	ed 81       	ldd	r30, Y+5	; 0x05
    3d8e:	fe 81       	ldd	r31, Y+6	; 0x06
    3d90:	92 8d       	ldd	r25, Z+26	; 0x1a
    3d92:	ed 81       	ldd	r30, Y+5	; 0x05
    3d94:	fe 81       	ldd	r31, Y+6	; 0x06
    3d96:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d98:	98 17       	cp	r25, r24
    3d9a:	d8 f4       	brcc	.+54     	; 0x3dd2 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3d9c:	8d 81       	ldd	r24, Y+5	; 0x05
    3d9e:	9e 81       	ldd	r25, Y+6	; 0x06
    3da0:	2f 81       	ldd	r18, Y+7	; 0x07
    3da2:	38 85       	ldd	r19, Y+8	; 0x08
    3da4:	b9 01       	movw	r22, r18
    3da6:	4b 85       	ldd	r20, Y+11	; 0x0b
    3da8:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3dac:	ed 81       	ldd	r30, Y+5	; 0x05
    3dae:	fe 81       	ldd	r31, Y+6	; 0x06
    3db0:	81 89       	ldd	r24, Z+17	; 0x11
    3db2:	88 23       	and	r24, r24
    3db4:	49 f0       	breq	.+18     	; 0x3dc8 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    3db6:	8d 81       	ldd	r24, Y+5	; 0x05
    3db8:	9e 81       	ldd	r25, Y+6	; 0x06
    3dba:	41 96       	adiw	r24, 0x11	; 17
    3dbc:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    3dc0:	81 30       	cpi	r24, 0x01	; 1
    3dc2:	11 f4       	brne	.+4      	; 0x3dc8 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    3dc4:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    3dc8:	0f 90       	pop	r0
    3dca:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    3dcc:	81 e0       	ldi	r24, 0x01	; 1
    3dce:	8c 87       	std	Y+12, r24	; 0x0c
    3dd0:	5c c0       	rjmp	.+184    	; 0x3e8a <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3dd2:	89 85       	ldd	r24, Y+9	; 0x09
    3dd4:	9a 85       	ldd	r25, Y+10	; 0x0a
    3dd6:	00 97       	sbiw	r24, 0x00	; 0
    3dd8:	21 f4       	brne	.+8      	; 0x3de2 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3dda:	0f 90       	pop	r0
    3ddc:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    3dde:	1c 86       	std	Y+12, r1	; 0x0c
    3de0:	54 c0       	rjmp	.+168    	; 0x3e8a <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    3de2:	89 81       	ldd	r24, Y+1	; 0x01
    3de4:	88 23       	and	r24, r24
    3de6:	31 f4       	brne	.+12     	; 0x3df4 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3de8:	ce 01       	movw	r24, r28
    3dea:	02 96       	adiw	r24, 0x02	; 2
    3dec:	0e 94 a1 27 	call	0x4f42	; 0x4f42 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3df0:	81 e0       	ldi	r24, 0x01	; 1
    3df2:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    3df4:	0f 90       	pop	r0
    3df6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3df8:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3dfc:	0f b6       	in	r0, 0x3f	; 63
    3dfe:	f8 94       	cli
    3e00:	0f 92       	push	r0
    3e02:	ed 81       	ldd	r30, Y+5	; 0x05
    3e04:	fe 81       	ldd	r31, Y+6	; 0x06
    3e06:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e08:	8f 3f       	cpi	r24, 0xFF	; 255
    3e0a:	19 f4       	brne	.+6      	; 0x3e12 <xQueueGenericSend+0xb0>
    3e0c:	ed 81       	ldd	r30, Y+5	; 0x05
    3e0e:	fe 81       	ldd	r31, Y+6	; 0x06
    3e10:	15 8e       	std	Z+29, r1	; 0x1d
    3e12:	ed 81       	ldd	r30, Y+5	; 0x05
    3e14:	fe 81       	ldd	r31, Y+6	; 0x06
    3e16:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e18:	8f 3f       	cpi	r24, 0xFF	; 255
    3e1a:	19 f4       	brne	.+6      	; 0x3e22 <xQueueGenericSend+0xc0>
    3e1c:	ed 81       	ldd	r30, Y+5	; 0x05
    3e1e:	fe 81       	ldd	r31, Y+6	; 0x06
    3e20:	16 8e       	std	Z+30, r1	; 0x1e
    3e22:	0f 90       	pop	r0
    3e24:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3e26:	ce 01       	movw	r24, r28
    3e28:	02 96       	adiw	r24, 0x02	; 2
    3e2a:	9e 01       	movw	r18, r28
    3e2c:	27 5f       	subi	r18, 0xF7	; 247
    3e2e:	3f 4f       	sbci	r19, 0xFF	; 255
    3e30:	b9 01       	movw	r22, r18
    3e32:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <xTaskCheckForTimeOut>
    3e36:	88 23       	and	r24, r24
    3e38:	09 f5       	brne	.+66     	; 0x3e7c <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    3e3a:	8d 81       	ldd	r24, Y+5	; 0x05
    3e3c:	9e 81       	ldd	r25, Y+6	; 0x06
    3e3e:	0e 94 50 22 	call	0x44a0	; 0x44a0 <prvIsQueueFull>
    3e42:	88 23       	and	r24, r24
    3e44:	a1 f0       	breq	.+40     	; 0x3e6e <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    3e46:	8d 81       	ldd	r24, Y+5	; 0x05
    3e48:	9e 81       	ldd	r25, Y+6	; 0x06
    3e4a:	08 96       	adiw	r24, 0x08	; 8
    3e4c:	29 85       	ldd	r18, Y+9	; 0x09
    3e4e:	3a 85       	ldd	r19, Y+10	; 0x0a
    3e50:	b9 01       	movw	r22, r18
    3e52:	0e 94 03 27 	call	0x4e06	; 0x4e06 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    3e56:	8d 81       	ldd	r24, Y+5	; 0x05
    3e58:	9e 81       	ldd	r25, Y+6	; 0x06
    3e5a:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    3e5e:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    3e62:	88 23       	and	r24, r24
    3e64:	09 f0       	breq	.+2      	; 0x3e68 <xQueueGenericSend+0x106>
    3e66:	8f cf       	rjmp	.-226    	; 0x3d86 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    3e68:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
    3e6c:	8c cf       	rjmp	.-232    	; 0x3d86 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    3e6e:	8d 81       	ldd	r24, Y+5	; 0x05
    3e70:	9e 81       	ldd	r25, Y+6	; 0x06
    3e72:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    3e76:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    3e7a:	85 cf       	rjmp	.-246    	; 0x3d86 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    3e7c:	8d 81       	ldd	r24, Y+5	; 0x05
    3e7e:	9e 81       	ldd	r25, Y+6	; 0x06
    3e80:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    3e84:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    3e88:	1c 86       	std	Y+12, r1	; 0x0c
    3e8a:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    3e8c:	2c 96       	adiw	r28, 0x0c	; 12
    3e8e:	0f b6       	in	r0, 0x3f	; 63
    3e90:	f8 94       	cli
    3e92:	de bf       	out	0x3e, r29	; 62
    3e94:	0f be       	out	0x3f, r0	; 63
    3e96:	cd bf       	out	0x3d, r28	; 61
    3e98:	cf 91       	pop	r28
    3e9a:	df 91       	pop	r29
    3e9c:	08 95       	ret

00003e9e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    3e9e:	df 93       	push	r29
    3ea0:	cf 93       	push	r28
    3ea2:	cd b7       	in	r28, 0x3d	; 61
    3ea4:	de b7       	in	r29, 0x3e	; 62
    3ea6:	29 97       	sbiw	r28, 0x09	; 9
    3ea8:	0f b6       	in	r0, 0x3f	; 63
    3eaa:	f8 94       	cli
    3eac:	de bf       	out	0x3e, r29	; 62
    3eae:	0f be       	out	0x3f, r0	; 63
    3eb0:	cd bf       	out	0x3d, r28	; 61
    3eb2:	9c 83       	std	Y+4, r25	; 0x04
    3eb4:	8b 83       	std	Y+3, r24	; 0x03
    3eb6:	7e 83       	std	Y+6, r23	; 0x06
    3eb8:	6d 83       	std	Y+5, r22	; 0x05
    3eba:	58 87       	std	Y+8, r21	; 0x08
    3ebc:	4f 83       	std	Y+7, r20	; 0x07
    3ebe:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    3ec0:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3ec2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ec4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ec6:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ec8:	eb 81       	ldd	r30, Y+3	; 0x03
    3eca:	fc 81       	ldd	r31, Y+4	; 0x04
    3ecc:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ece:	98 17       	cp	r25, r24
    3ed0:	40 f5       	brcc	.+80     	; 0x3f22 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    3ed2:	8b 81       	ldd	r24, Y+3	; 0x03
    3ed4:	9c 81       	ldd	r25, Y+4	; 0x04
    3ed6:	2d 81       	ldd	r18, Y+5	; 0x05
    3ed8:	3e 81       	ldd	r19, Y+6	; 0x06
    3eda:	b9 01       	movw	r22, r18
    3edc:	49 85       	ldd	r20, Y+9	; 0x09
    3ede:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3ee2:	eb 81       	ldd	r30, Y+3	; 0x03
    3ee4:	fc 81       	ldd	r31, Y+4	; 0x04
    3ee6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ee8:	8f 3f       	cpi	r24, 0xFF	; 255
    3eea:	89 f4       	brne	.+34     	; 0x3f0e <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3eec:	eb 81       	ldd	r30, Y+3	; 0x03
    3eee:	fc 81       	ldd	r31, Y+4	; 0x04
    3ef0:	81 89       	ldd	r24, Z+17	; 0x11
    3ef2:	88 23       	and	r24, r24
    3ef4:	99 f0       	breq	.+38     	; 0x3f1c <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ef6:	8b 81       	ldd	r24, Y+3	; 0x03
    3ef8:	9c 81       	ldd	r25, Y+4	; 0x04
    3efa:	41 96       	adiw	r24, 0x11	; 17
    3efc:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    3f00:	88 23       	and	r24, r24
    3f02:	61 f0       	breq	.+24     	; 0x3f1c <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    3f04:	ef 81       	ldd	r30, Y+7	; 0x07
    3f06:	f8 85       	ldd	r31, Y+8	; 0x08
    3f08:	81 e0       	ldi	r24, 0x01	; 1
    3f0a:	80 83       	st	Z, r24
    3f0c:	07 c0       	rjmp	.+14     	; 0x3f1c <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3f0e:	eb 81       	ldd	r30, Y+3	; 0x03
    3f10:	fc 81       	ldd	r31, Y+4	; 0x04
    3f12:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f14:	8f 5f       	subi	r24, 0xFF	; 255
    3f16:	eb 81       	ldd	r30, Y+3	; 0x03
    3f18:	fc 81       	ldd	r31, Y+4	; 0x04
    3f1a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3f1c:	81 e0       	ldi	r24, 0x01	; 1
    3f1e:	8a 83       	std	Y+2, r24	; 0x02
    3f20:	01 c0       	rjmp	.+2      	; 0x3f24 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3f22:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    3f24:	8a 81       	ldd	r24, Y+2	; 0x02
}
    3f26:	29 96       	adiw	r28, 0x09	; 9
    3f28:	0f b6       	in	r0, 0x3f	; 63
    3f2a:	f8 94       	cli
    3f2c:	de bf       	out	0x3e, r29	; 62
    3f2e:	0f be       	out	0x3f, r0	; 63
    3f30:	cd bf       	out	0x3d, r28	; 61
    3f32:	cf 91       	pop	r28
    3f34:	df 91       	pop	r29
    3f36:	08 95       	ret

00003f38 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    3f38:	df 93       	push	r29
    3f3a:	cf 93       	push	r28
    3f3c:	cd b7       	in	r28, 0x3d	; 61
    3f3e:	de b7       	in	r29, 0x3e	; 62
    3f40:	2e 97       	sbiw	r28, 0x0e	; 14
    3f42:	0f b6       	in	r0, 0x3f	; 63
    3f44:	f8 94       	cli
    3f46:	de bf       	out	0x3e, r29	; 62
    3f48:	0f be       	out	0x3f, r0	; 63
    3f4a:	cd bf       	out	0x3d, r28	; 61
    3f4c:	98 87       	std	Y+8, r25	; 0x08
    3f4e:	8f 83       	std	Y+7, r24	; 0x07
    3f50:	7a 87       	std	Y+10, r23	; 0x0a
    3f52:	69 87       	std	Y+9, r22	; 0x09
    3f54:	5c 87       	std	Y+12, r21	; 0x0c
    3f56:	4b 87       	std	Y+11, r20	; 0x0b
    3f58:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    3f5a:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3f5c:	0f b6       	in	r0, 0x3f	; 63
    3f5e:	f8 94       	cli
    3f60:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    3f62:	ef 81       	ldd	r30, Y+7	; 0x07
    3f64:	f8 85       	ldd	r31, Y+8	; 0x08
    3f66:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f68:	88 23       	and	r24, r24
    3f6a:	09 f4       	brne	.+2      	; 0x3f6e <xQueueGenericReceive+0x36>
    3f6c:	3f c0       	rjmp	.+126    	; 0x3fec <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    3f6e:	ef 81       	ldd	r30, Y+7	; 0x07
    3f70:	f8 85       	ldd	r31, Y+8	; 0x08
    3f72:	86 81       	ldd	r24, Z+6	; 0x06
    3f74:	97 81       	ldd	r25, Z+7	; 0x07
    3f76:	9a 83       	std	Y+2, r25	; 0x02
    3f78:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    3f7a:	8f 81       	ldd	r24, Y+7	; 0x07
    3f7c:	98 85       	ldd	r25, Y+8	; 0x08
    3f7e:	29 85       	ldd	r18, Y+9	; 0x09
    3f80:	3a 85       	ldd	r19, Y+10	; 0x0a
    3f82:	b9 01       	movw	r22, r18
    3f84:	0e 94 81 21 	call	0x4302	; 0x4302 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    3f88:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f8a:	88 23       	and	r24, r24
    3f8c:	b1 f4       	brne	.+44     	; 0x3fba <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    3f8e:	ef 81       	ldd	r30, Y+7	; 0x07
    3f90:	f8 85       	ldd	r31, Y+8	; 0x08
    3f92:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f94:	81 50       	subi	r24, 0x01	; 1
    3f96:	ef 81       	ldd	r30, Y+7	; 0x07
    3f98:	f8 85       	ldd	r31, Y+8	; 0x08
    3f9a:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f9c:	ef 81       	ldd	r30, Y+7	; 0x07
    3f9e:	f8 85       	ldd	r31, Y+8	; 0x08
    3fa0:	80 85       	ldd	r24, Z+8	; 0x08
    3fa2:	88 23       	and	r24, r24
    3fa4:	f1 f0       	breq	.+60     	; 0x3fe2 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3fa6:	8f 81       	ldd	r24, Y+7	; 0x07
    3fa8:	98 85       	ldd	r25, Y+8	; 0x08
    3faa:	08 96       	adiw	r24, 0x08	; 8
    3fac:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    3fb0:	81 30       	cpi	r24, 0x01	; 1
    3fb2:	b9 f4       	brne	.+46     	; 0x3fe2 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    3fb4:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
    3fb8:	14 c0       	rjmp	.+40     	; 0x3fe2 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    3fba:	ef 81       	ldd	r30, Y+7	; 0x07
    3fbc:	f8 85       	ldd	r31, Y+8	; 0x08
    3fbe:	89 81       	ldd	r24, Y+1	; 0x01
    3fc0:	9a 81       	ldd	r25, Y+2	; 0x02
    3fc2:	97 83       	std	Z+7, r25	; 0x07
    3fc4:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fc6:	ef 81       	ldd	r30, Y+7	; 0x07
    3fc8:	f8 85       	ldd	r31, Y+8	; 0x08
    3fca:	81 89       	ldd	r24, Z+17	; 0x11
    3fcc:	88 23       	and	r24, r24
    3fce:	49 f0       	breq	.+18     	; 0x3fe2 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fd0:	8f 81       	ldd	r24, Y+7	; 0x07
    3fd2:	98 85       	ldd	r25, Y+8	; 0x08
    3fd4:	41 96       	adiw	r24, 0x11	; 17
    3fd6:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    3fda:	88 23       	and	r24, r24
    3fdc:	11 f0       	breq	.+4      	; 0x3fe2 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    3fde:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    3fe2:	0f 90       	pop	r0
    3fe4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3fe6:	81 e0       	ldi	r24, 0x01	; 1
    3fe8:	8e 87       	std	Y+14, r24	; 0x0e
    3fea:	5c c0       	rjmp	.+184    	; 0x40a4 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    3fec:	8b 85       	ldd	r24, Y+11	; 0x0b
    3fee:	9c 85       	ldd	r25, Y+12	; 0x0c
    3ff0:	00 97       	sbiw	r24, 0x00	; 0
    3ff2:	21 f4       	brne	.+8      	; 0x3ffc <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3ff4:	0f 90       	pop	r0
    3ff6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3ff8:	1e 86       	std	Y+14, r1	; 0x0e
    3ffa:	54 c0       	rjmp	.+168    	; 0x40a4 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    3ffc:	8b 81       	ldd	r24, Y+3	; 0x03
    3ffe:	88 23       	and	r24, r24
    4000:	31 f4       	brne	.+12     	; 0x400e <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4002:	ce 01       	movw	r24, r28
    4004:	04 96       	adiw	r24, 0x04	; 4
    4006:	0e 94 a1 27 	call	0x4f42	; 0x4f42 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    400a:	81 e0       	ldi	r24, 0x01	; 1
    400c:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    400e:	0f 90       	pop	r0
    4010:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4012:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4016:	0f b6       	in	r0, 0x3f	; 63
    4018:	f8 94       	cli
    401a:	0f 92       	push	r0
    401c:	ef 81       	ldd	r30, Y+7	; 0x07
    401e:	f8 85       	ldd	r31, Y+8	; 0x08
    4020:	85 8d       	ldd	r24, Z+29	; 0x1d
    4022:	8f 3f       	cpi	r24, 0xFF	; 255
    4024:	19 f4       	brne	.+6      	; 0x402c <xQueueGenericReceive+0xf4>
    4026:	ef 81       	ldd	r30, Y+7	; 0x07
    4028:	f8 85       	ldd	r31, Y+8	; 0x08
    402a:	15 8e       	std	Z+29, r1	; 0x1d
    402c:	ef 81       	ldd	r30, Y+7	; 0x07
    402e:	f8 85       	ldd	r31, Y+8	; 0x08
    4030:	86 8d       	ldd	r24, Z+30	; 0x1e
    4032:	8f 3f       	cpi	r24, 0xFF	; 255
    4034:	19 f4       	brne	.+6      	; 0x403c <xQueueGenericReceive+0x104>
    4036:	ef 81       	ldd	r30, Y+7	; 0x07
    4038:	f8 85       	ldd	r31, Y+8	; 0x08
    403a:	16 8e       	std	Z+30, r1	; 0x1e
    403c:	0f 90       	pop	r0
    403e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4040:	ce 01       	movw	r24, r28
    4042:	04 96       	adiw	r24, 0x04	; 4
    4044:	9e 01       	movw	r18, r28
    4046:	25 5f       	subi	r18, 0xF5	; 245
    4048:	3f 4f       	sbci	r19, 0xFF	; 255
    404a:	b9 01       	movw	r22, r18
    404c:	0e 94 ba 27 	call	0x4f74	; 0x4f74 <xTaskCheckForTimeOut>
    4050:	88 23       	and	r24, r24
    4052:	09 f5       	brne	.+66     	; 0x4096 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4054:	8f 81       	ldd	r24, Y+7	; 0x07
    4056:	98 85       	ldd	r25, Y+8	; 0x08
    4058:	0e 94 1d 22 	call	0x443a	; 0x443a <prvIsQueueEmpty>
    405c:	88 23       	and	r24, r24
    405e:	a1 f0       	breq	.+40     	; 0x4088 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4060:	8f 81       	ldd	r24, Y+7	; 0x07
    4062:	98 85       	ldd	r25, Y+8	; 0x08
    4064:	41 96       	adiw	r24, 0x11	; 17
    4066:	2b 85       	ldd	r18, Y+11	; 0x0b
    4068:	3c 85       	ldd	r19, Y+12	; 0x0c
    406a:	b9 01       	movw	r22, r18
    406c:	0e 94 03 27 	call	0x4e06	; 0x4e06 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    4070:	8f 81       	ldd	r24, Y+7	; 0x07
    4072:	98 85       	ldd	r25, Y+8	; 0x08
    4074:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    4078:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    407c:	88 23       	and	r24, r24
    407e:	09 f0       	breq	.+2      	; 0x4082 <xQueueGenericReceive+0x14a>
    4080:	6d cf       	rjmp	.-294    	; 0x3f5c <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    4082:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
    4086:	6a cf       	rjmp	.-300    	; 0x3f5c <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    4088:	8f 81       	ldd	r24, Y+7	; 0x07
    408a:	98 85       	ldd	r25, Y+8	; 0x08
    408c:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    4090:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    4094:	63 cf       	rjmp	.-314    	; 0x3f5c <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    4096:	8f 81       	ldd	r24, Y+7	; 0x07
    4098:	98 85       	ldd	r25, Y+8	; 0x08
    409a:	0e 94 c9 21 	call	0x4392	; 0x4392 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    409e:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    40a2:	1e 86       	std	Y+14, r1	; 0x0e
    40a4:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    40a6:	2e 96       	adiw	r28, 0x0e	; 14
    40a8:	0f b6       	in	r0, 0x3f	; 63
    40aa:	f8 94       	cli
    40ac:	de bf       	out	0x3e, r29	; 62
    40ae:	0f be       	out	0x3f, r0	; 63
    40b0:	cd bf       	out	0x3d, r28	; 61
    40b2:	cf 91       	pop	r28
    40b4:	df 91       	pop	r29
    40b6:	08 95       	ret

000040b8 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    40b8:	df 93       	push	r29
    40ba:	cf 93       	push	r28
    40bc:	cd b7       	in	r28, 0x3d	; 61
    40be:	de b7       	in	r29, 0x3e	; 62
    40c0:	28 97       	sbiw	r28, 0x08	; 8
    40c2:	0f b6       	in	r0, 0x3f	; 63
    40c4:	f8 94       	cli
    40c6:	de bf       	out	0x3e, r29	; 62
    40c8:	0f be       	out	0x3f, r0	; 63
    40ca:	cd bf       	out	0x3d, r28	; 61
    40cc:	9c 83       	std	Y+4, r25	; 0x04
    40ce:	8b 83       	std	Y+3, r24	; 0x03
    40d0:	7e 83       	std	Y+6, r23	; 0x06
    40d2:	6d 83       	std	Y+5, r22	; 0x05
    40d4:	58 87       	std	Y+8, r21	; 0x08
    40d6:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    40d8:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    40da:	eb 81       	ldd	r30, Y+3	; 0x03
    40dc:	fc 81       	ldd	r31, Y+4	; 0x04
    40de:	82 8d       	ldd	r24, Z+26	; 0x1a
    40e0:	88 23       	and	r24, r24
    40e2:	71 f1       	breq	.+92     	; 0x4140 <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    40e4:	8b 81       	ldd	r24, Y+3	; 0x03
    40e6:	9c 81       	ldd	r25, Y+4	; 0x04
    40e8:	2d 81       	ldd	r18, Y+5	; 0x05
    40ea:	3e 81       	ldd	r19, Y+6	; 0x06
    40ec:	b9 01       	movw	r22, r18
    40ee:	0e 94 81 21 	call	0x4302	; 0x4302 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    40f2:	eb 81       	ldd	r30, Y+3	; 0x03
    40f4:	fc 81       	ldd	r31, Y+4	; 0x04
    40f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    40f8:	81 50       	subi	r24, 0x01	; 1
    40fa:	eb 81       	ldd	r30, Y+3	; 0x03
    40fc:	fc 81       	ldd	r31, Y+4	; 0x04
    40fe:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    4100:	eb 81       	ldd	r30, Y+3	; 0x03
    4102:	fc 81       	ldd	r31, Y+4	; 0x04
    4104:	85 8d       	ldd	r24, Z+29	; 0x1d
    4106:	8f 3f       	cpi	r24, 0xFF	; 255
    4108:	89 f4       	brne	.+34     	; 0x412c <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    410a:	eb 81       	ldd	r30, Y+3	; 0x03
    410c:	fc 81       	ldd	r31, Y+4	; 0x04
    410e:	80 85       	ldd	r24, Z+8	; 0x08
    4110:	88 23       	and	r24, r24
    4112:	99 f0       	breq	.+38     	; 0x413a <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4114:	8b 81       	ldd	r24, Y+3	; 0x03
    4116:	9c 81       	ldd	r25, Y+4	; 0x04
    4118:	08 96       	adiw	r24, 0x08	; 8
    411a:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    411e:	88 23       	and	r24, r24
    4120:	61 f0       	breq	.+24     	; 0x413a <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    4122:	ef 81       	ldd	r30, Y+7	; 0x07
    4124:	f8 85       	ldd	r31, Y+8	; 0x08
    4126:	81 e0       	ldi	r24, 0x01	; 1
    4128:	80 83       	st	Z, r24
    412a:	07 c0       	rjmp	.+14     	; 0x413a <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    412c:	eb 81       	ldd	r30, Y+3	; 0x03
    412e:	fc 81       	ldd	r31, Y+4	; 0x04
    4130:	85 8d       	ldd	r24, Z+29	; 0x1d
    4132:	8f 5f       	subi	r24, 0xFF	; 255
    4134:	eb 81       	ldd	r30, Y+3	; 0x03
    4136:	fc 81       	ldd	r31, Y+4	; 0x04
    4138:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    413a:	81 e0       	ldi	r24, 0x01	; 1
    413c:	8a 83       	std	Y+2, r24	; 0x02
    413e:	01 c0       	rjmp	.+2      	; 0x4142 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    4140:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4142:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4144:	28 96       	adiw	r28, 0x08	; 8
    4146:	0f b6       	in	r0, 0x3f	; 63
    4148:	f8 94       	cli
    414a:	de bf       	out	0x3e, r29	; 62
    414c:	0f be       	out	0x3f, r0	; 63
    414e:	cd bf       	out	0x3d, r28	; 61
    4150:	cf 91       	pop	r28
    4152:	df 91       	pop	r29
    4154:	08 95       	ret

00004156 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    4156:	df 93       	push	r29
    4158:	cf 93       	push	r28
    415a:	00 d0       	rcall	.+0      	; 0x415c <uxQueueMessagesWaiting+0x6>
    415c:	0f 92       	push	r0
    415e:	cd b7       	in	r28, 0x3d	; 61
    4160:	de b7       	in	r29, 0x3e	; 62
    4162:	9b 83       	std	Y+3, r25	; 0x03
    4164:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    4166:	0f b6       	in	r0, 0x3f	; 63
    4168:	f8 94       	cli
    416a:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    416c:	ea 81       	ldd	r30, Y+2	; 0x02
    416e:	fb 81       	ldd	r31, Y+3	; 0x03
    4170:	82 8d       	ldd	r24, Z+26	; 0x1a
    4172:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4174:	0f 90       	pop	r0
    4176:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    4178:	89 81       	ldd	r24, Y+1	; 0x01
}
    417a:	0f 90       	pop	r0
    417c:	0f 90       	pop	r0
    417e:	0f 90       	pop	r0
    4180:	cf 91       	pop	r28
    4182:	df 91       	pop	r29
    4184:	08 95       	ret

00004186 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    4186:	df 93       	push	r29
    4188:	cf 93       	push	r28
    418a:	00 d0       	rcall	.+0      	; 0x418c <uxQueueMessagesWaitingFromISR+0x6>
    418c:	0f 92       	push	r0
    418e:	cd b7       	in	r28, 0x3d	; 61
    4190:	de b7       	in	r29, 0x3e	; 62
    4192:	9b 83       	std	Y+3, r25	; 0x03
    4194:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    4196:	ea 81       	ldd	r30, Y+2	; 0x02
    4198:	fb 81       	ldd	r31, Y+3	; 0x03
    419a:	82 8d       	ldd	r24, Z+26	; 0x1a
    419c:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    419e:	89 81       	ldd	r24, Y+1	; 0x01
}
    41a0:	0f 90       	pop	r0
    41a2:	0f 90       	pop	r0
    41a4:	0f 90       	pop	r0
    41a6:	cf 91       	pop	r28
    41a8:	df 91       	pop	r29
    41aa:	08 95       	ret

000041ac <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    41ac:	df 93       	push	r29
    41ae:	cf 93       	push	r28
    41b0:	00 d0       	rcall	.+0      	; 0x41b2 <vQueueDelete+0x6>
    41b2:	cd b7       	in	r28, 0x3d	; 61
    41b4:	de b7       	in	r29, 0x3e	; 62
    41b6:	9a 83       	std	Y+2, r25	; 0x02
    41b8:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    41ba:	e9 81       	ldd	r30, Y+1	; 0x01
    41bc:	fa 81       	ldd	r31, Y+2	; 0x02
    41be:	80 81       	ld	r24, Z
    41c0:	91 81       	ldd	r25, Z+1	; 0x01
    41c2:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
	vPortFree( pxQueue );
    41c6:	89 81       	ldd	r24, Y+1	; 0x01
    41c8:	9a 81       	ldd	r25, Y+2	; 0x02
    41ca:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
}
    41ce:	0f 90       	pop	r0
    41d0:	0f 90       	pop	r0
    41d2:	cf 91       	pop	r28
    41d4:	df 91       	pop	r29
    41d6:	08 95       	ret

000041d8 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    41d8:	df 93       	push	r29
    41da:	cf 93       	push	r28
    41dc:	00 d0       	rcall	.+0      	; 0x41de <prvCopyDataToQueue+0x6>
    41de:	00 d0       	rcall	.+0      	; 0x41e0 <prvCopyDataToQueue+0x8>
    41e0:	0f 92       	push	r0
    41e2:	cd b7       	in	r28, 0x3d	; 61
    41e4:	de b7       	in	r29, 0x3e	; 62
    41e6:	9a 83       	std	Y+2, r25	; 0x02
    41e8:	89 83       	std	Y+1, r24	; 0x01
    41ea:	7c 83       	std	Y+4, r23	; 0x04
    41ec:	6b 83       	std	Y+3, r22	; 0x03
    41ee:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    41f0:	e9 81       	ldd	r30, Y+1	; 0x01
    41f2:	fa 81       	ldd	r31, Y+2	; 0x02
    41f4:	84 8d       	ldd	r24, Z+28	; 0x1c
    41f6:	88 23       	and	r24, r24
    41f8:	09 f4       	brne	.+2      	; 0x41fc <prvCopyDataToQueue+0x24>
    41fa:	74 c0       	rjmp	.+232    	; 0x42e4 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    41fc:	8d 81       	ldd	r24, Y+5	; 0x05
    41fe:	88 23       	and	r24, r24
    4200:	99 f5       	brne	.+102    	; 0x4268 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4202:	e9 81       	ldd	r30, Y+1	; 0x01
    4204:	fa 81       	ldd	r31, Y+2	; 0x02
    4206:	64 81       	ldd	r22, Z+4	; 0x04
    4208:	75 81       	ldd	r23, Z+5	; 0x05
    420a:	e9 81       	ldd	r30, Y+1	; 0x01
    420c:	fa 81       	ldd	r31, Y+2	; 0x02
    420e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4210:	48 2f       	mov	r20, r24
    4212:	50 e0       	ldi	r21, 0x00	; 0
    4214:	2b 81       	ldd	r18, Y+3	; 0x03
    4216:	3c 81       	ldd	r19, Y+4	; 0x04
    4218:	cb 01       	movw	r24, r22
    421a:	b9 01       	movw	r22, r18
    421c:	0e 94 05 2a 	call	0x540a	; 0x540a <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    4220:	e9 81       	ldd	r30, Y+1	; 0x01
    4222:	fa 81       	ldd	r31, Y+2	; 0x02
    4224:	24 81       	ldd	r18, Z+4	; 0x04
    4226:	35 81       	ldd	r19, Z+5	; 0x05
    4228:	e9 81       	ldd	r30, Y+1	; 0x01
    422a:	fa 81       	ldd	r31, Y+2	; 0x02
    422c:	84 8d       	ldd	r24, Z+28	; 0x1c
    422e:	88 2f       	mov	r24, r24
    4230:	90 e0       	ldi	r25, 0x00	; 0
    4232:	82 0f       	add	r24, r18
    4234:	93 1f       	adc	r25, r19
    4236:	e9 81       	ldd	r30, Y+1	; 0x01
    4238:	fa 81       	ldd	r31, Y+2	; 0x02
    423a:	95 83       	std	Z+5, r25	; 0x05
    423c:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    423e:	e9 81       	ldd	r30, Y+1	; 0x01
    4240:	fa 81       	ldd	r31, Y+2	; 0x02
    4242:	24 81       	ldd	r18, Z+4	; 0x04
    4244:	35 81       	ldd	r19, Z+5	; 0x05
    4246:	e9 81       	ldd	r30, Y+1	; 0x01
    4248:	fa 81       	ldd	r31, Y+2	; 0x02
    424a:	82 81       	ldd	r24, Z+2	; 0x02
    424c:	93 81       	ldd	r25, Z+3	; 0x03
    424e:	28 17       	cp	r18, r24
    4250:	39 07       	cpc	r19, r25
    4252:	08 f4       	brcc	.+2      	; 0x4256 <prvCopyDataToQueue+0x7e>
    4254:	47 c0       	rjmp	.+142    	; 0x42e4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    4256:	e9 81       	ldd	r30, Y+1	; 0x01
    4258:	fa 81       	ldd	r31, Y+2	; 0x02
    425a:	80 81       	ld	r24, Z
    425c:	91 81       	ldd	r25, Z+1	; 0x01
    425e:	e9 81       	ldd	r30, Y+1	; 0x01
    4260:	fa 81       	ldd	r31, Y+2	; 0x02
    4262:	95 83       	std	Z+5, r25	; 0x05
    4264:	84 83       	std	Z+4, r24	; 0x04
    4266:	3e c0       	rjmp	.+124    	; 0x42e4 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    4268:	e9 81       	ldd	r30, Y+1	; 0x01
    426a:	fa 81       	ldd	r31, Y+2	; 0x02
    426c:	66 81       	ldd	r22, Z+6	; 0x06
    426e:	77 81       	ldd	r23, Z+7	; 0x07
    4270:	e9 81       	ldd	r30, Y+1	; 0x01
    4272:	fa 81       	ldd	r31, Y+2	; 0x02
    4274:	84 8d       	ldd	r24, Z+28	; 0x1c
    4276:	48 2f       	mov	r20, r24
    4278:	50 e0       	ldi	r21, 0x00	; 0
    427a:	2b 81       	ldd	r18, Y+3	; 0x03
    427c:	3c 81       	ldd	r19, Y+4	; 0x04
    427e:	cb 01       	movw	r24, r22
    4280:	b9 01       	movw	r22, r18
    4282:	0e 94 05 2a 	call	0x540a	; 0x540a <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    4286:	e9 81       	ldd	r30, Y+1	; 0x01
    4288:	fa 81       	ldd	r31, Y+2	; 0x02
    428a:	26 81       	ldd	r18, Z+6	; 0x06
    428c:	37 81       	ldd	r19, Z+7	; 0x07
    428e:	e9 81       	ldd	r30, Y+1	; 0x01
    4290:	fa 81       	ldd	r31, Y+2	; 0x02
    4292:	84 8d       	ldd	r24, Z+28	; 0x1c
    4294:	88 2f       	mov	r24, r24
    4296:	90 e0       	ldi	r25, 0x00	; 0
    4298:	90 95       	com	r25
    429a:	81 95       	neg	r24
    429c:	9f 4f       	sbci	r25, 0xFF	; 255
    429e:	82 0f       	add	r24, r18
    42a0:	93 1f       	adc	r25, r19
    42a2:	e9 81       	ldd	r30, Y+1	; 0x01
    42a4:	fa 81       	ldd	r31, Y+2	; 0x02
    42a6:	97 83       	std	Z+7, r25	; 0x07
    42a8:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    42aa:	e9 81       	ldd	r30, Y+1	; 0x01
    42ac:	fa 81       	ldd	r31, Y+2	; 0x02
    42ae:	26 81       	ldd	r18, Z+6	; 0x06
    42b0:	37 81       	ldd	r19, Z+7	; 0x07
    42b2:	e9 81       	ldd	r30, Y+1	; 0x01
    42b4:	fa 81       	ldd	r31, Y+2	; 0x02
    42b6:	80 81       	ld	r24, Z
    42b8:	91 81       	ldd	r25, Z+1	; 0x01
    42ba:	28 17       	cp	r18, r24
    42bc:	39 07       	cpc	r19, r25
    42be:	90 f4       	brcc	.+36     	; 0x42e4 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    42c0:	e9 81       	ldd	r30, Y+1	; 0x01
    42c2:	fa 81       	ldd	r31, Y+2	; 0x02
    42c4:	22 81       	ldd	r18, Z+2	; 0x02
    42c6:	33 81       	ldd	r19, Z+3	; 0x03
    42c8:	e9 81       	ldd	r30, Y+1	; 0x01
    42ca:	fa 81       	ldd	r31, Y+2	; 0x02
    42cc:	84 8d       	ldd	r24, Z+28	; 0x1c
    42ce:	88 2f       	mov	r24, r24
    42d0:	90 e0       	ldi	r25, 0x00	; 0
    42d2:	90 95       	com	r25
    42d4:	81 95       	neg	r24
    42d6:	9f 4f       	sbci	r25, 0xFF	; 255
    42d8:	82 0f       	add	r24, r18
    42da:	93 1f       	adc	r25, r19
    42dc:	e9 81       	ldd	r30, Y+1	; 0x01
    42de:	fa 81       	ldd	r31, Y+2	; 0x02
    42e0:	97 83       	std	Z+7, r25	; 0x07
    42e2:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    42e4:	e9 81       	ldd	r30, Y+1	; 0x01
    42e6:	fa 81       	ldd	r31, Y+2	; 0x02
    42e8:	82 8d       	ldd	r24, Z+26	; 0x1a
    42ea:	8f 5f       	subi	r24, 0xFF	; 255
    42ec:	e9 81       	ldd	r30, Y+1	; 0x01
    42ee:	fa 81       	ldd	r31, Y+2	; 0x02
    42f0:	82 8f       	std	Z+26, r24	; 0x1a
}
    42f2:	0f 90       	pop	r0
    42f4:	0f 90       	pop	r0
    42f6:	0f 90       	pop	r0
    42f8:	0f 90       	pop	r0
    42fa:	0f 90       	pop	r0
    42fc:	cf 91       	pop	r28
    42fe:	df 91       	pop	r29
    4300:	08 95       	ret

00004302 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    4302:	df 93       	push	r29
    4304:	cf 93       	push	r28
    4306:	00 d0       	rcall	.+0      	; 0x4308 <prvCopyDataFromQueue+0x6>
    4308:	00 d0       	rcall	.+0      	; 0x430a <prvCopyDataFromQueue+0x8>
    430a:	cd b7       	in	r28, 0x3d	; 61
    430c:	de b7       	in	r29, 0x3e	; 62
    430e:	9a 83       	std	Y+2, r25	; 0x02
    4310:	89 83       	std	Y+1, r24	; 0x01
    4312:	7c 83       	std	Y+4, r23	; 0x04
    4314:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    4316:	e9 81       	ldd	r30, Y+1	; 0x01
    4318:	fa 81       	ldd	r31, Y+2	; 0x02
    431a:	80 81       	ld	r24, Z
    431c:	91 81       	ldd	r25, Z+1	; 0x01
    431e:	00 97       	sbiw	r24, 0x00	; 0
    4320:	89 f1       	breq	.+98     	; 0x4384 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    4322:	e9 81       	ldd	r30, Y+1	; 0x01
    4324:	fa 81       	ldd	r31, Y+2	; 0x02
    4326:	26 81       	ldd	r18, Z+6	; 0x06
    4328:	37 81       	ldd	r19, Z+7	; 0x07
    432a:	e9 81       	ldd	r30, Y+1	; 0x01
    432c:	fa 81       	ldd	r31, Y+2	; 0x02
    432e:	84 8d       	ldd	r24, Z+28	; 0x1c
    4330:	88 2f       	mov	r24, r24
    4332:	90 e0       	ldi	r25, 0x00	; 0
    4334:	82 0f       	add	r24, r18
    4336:	93 1f       	adc	r25, r19
    4338:	e9 81       	ldd	r30, Y+1	; 0x01
    433a:	fa 81       	ldd	r31, Y+2	; 0x02
    433c:	97 83       	std	Z+7, r25	; 0x07
    433e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    4340:	e9 81       	ldd	r30, Y+1	; 0x01
    4342:	fa 81       	ldd	r31, Y+2	; 0x02
    4344:	26 81       	ldd	r18, Z+6	; 0x06
    4346:	37 81       	ldd	r19, Z+7	; 0x07
    4348:	e9 81       	ldd	r30, Y+1	; 0x01
    434a:	fa 81       	ldd	r31, Y+2	; 0x02
    434c:	82 81       	ldd	r24, Z+2	; 0x02
    434e:	93 81       	ldd	r25, Z+3	; 0x03
    4350:	28 17       	cp	r18, r24
    4352:	39 07       	cpc	r19, r25
    4354:	40 f0       	brcs	.+16     	; 0x4366 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    4356:	e9 81       	ldd	r30, Y+1	; 0x01
    4358:	fa 81       	ldd	r31, Y+2	; 0x02
    435a:	80 81       	ld	r24, Z
    435c:	91 81       	ldd	r25, Z+1	; 0x01
    435e:	e9 81       	ldd	r30, Y+1	; 0x01
    4360:	fa 81       	ldd	r31, Y+2	; 0x02
    4362:	97 83       	std	Z+7, r25	; 0x07
    4364:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    4366:	e9 81       	ldd	r30, Y+1	; 0x01
    4368:	fa 81       	ldd	r31, Y+2	; 0x02
    436a:	46 81       	ldd	r20, Z+6	; 0x06
    436c:	57 81       	ldd	r21, Z+7	; 0x07
    436e:	e9 81       	ldd	r30, Y+1	; 0x01
    4370:	fa 81       	ldd	r31, Y+2	; 0x02
    4372:	84 8d       	ldd	r24, Z+28	; 0x1c
    4374:	28 2f       	mov	r18, r24
    4376:	30 e0       	ldi	r19, 0x00	; 0
    4378:	8b 81       	ldd	r24, Y+3	; 0x03
    437a:	9c 81       	ldd	r25, Y+4	; 0x04
    437c:	ba 01       	movw	r22, r20
    437e:	a9 01       	movw	r20, r18
    4380:	0e 94 05 2a 	call	0x540a	; 0x540a <memcpy>
	}
}
    4384:	0f 90       	pop	r0
    4386:	0f 90       	pop	r0
    4388:	0f 90       	pop	r0
    438a:	0f 90       	pop	r0
    438c:	cf 91       	pop	r28
    438e:	df 91       	pop	r29
    4390:	08 95       	ret

00004392 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    4392:	df 93       	push	r29
    4394:	cf 93       	push	r28
    4396:	00 d0       	rcall	.+0      	; 0x4398 <prvUnlockQueue+0x6>
    4398:	cd b7       	in	r28, 0x3d	; 61
    439a:	de b7       	in	r29, 0x3e	; 62
    439c:	9a 83       	std	Y+2, r25	; 0x02
    439e:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    43a0:	0f b6       	in	r0, 0x3f	; 63
    43a2:	f8 94       	cli
    43a4:	0f 92       	push	r0
    43a6:	15 c0       	rjmp	.+42     	; 0x43d2 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    43a8:	e9 81       	ldd	r30, Y+1	; 0x01
    43aa:	fa 81       	ldd	r31, Y+2	; 0x02
    43ac:	81 89       	ldd	r24, Z+17	; 0x11
    43ae:	88 23       	and	r24, r24
    43b0:	a9 f0       	breq	.+42     	; 0x43dc <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    43b2:	89 81       	ldd	r24, Y+1	; 0x01
    43b4:	9a 81       	ldd	r25, Y+2	; 0x02
    43b6:	41 96       	adiw	r24, 0x11	; 17
    43b8:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    43bc:	88 23       	and	r24, r24
    43be:	11 f0       	breq	.+4      	; 0x43c4 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    43c0:	0e 94 17 28 	call	0x502e	; 0x502e <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    43c4:	e9 81       	ldd	r30, Y+1	; 0x01
    43c6:	fa 81       	ldd	r31, Y+2	; 0x02
    43c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    43ca:	81 50       	subi	r24, 0x01	; 1
    43cc:	e9 81       	ldd	r30, Y+1	; 0x01
    43ce:	fa 81       	ldd	r31, Y+2	; 0x02
    43d0:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    43d2:	e9 81       	ldd	r30, Y+1	; 0x01
    43d4:	fa 81       	ldd	r31, Y+2	; 0x02
    43d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    43d8:	18 16       	cp	r1, r24
    43da:	34 f3       	brlt	.-52     	; 0x43a8 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    43dc:	e9 81       	ldd	r30, Y+1	; 0x01
    43de:	fa 81       	ldd	r31, Y+2	; 0x02
    43e0:	8f ef       	ldi	r24, 0xFF	; 255
    43e2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    43e4:	0f 90       	pop	r0
    43e6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    43e8:	0f b6       	in	r0, 0x3f	; 63
    43ea:	f8 94       	cli
    43ec:	0f 92       	push	r0
    43ee:	15 c0       	rjmp	.+42     	; 0x441a <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    43f0:	e9 81       	ldd	r30, Y+1	; 0x01
    43f2:	fa 81       	ldd	r31, Y+2	; 0x02
    43f4:	80 85       	ldd	r24, Z+8	; 0x08
    43f6:	88 23       	and	r24, r24
    43f8:	a9 f0       	breq	.+42     	; 0x4424 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    43fa:	89 81       	ldd	r24, Y+1	; 0x01
    43fc:	9a 81       	ldd	r25, Y+2	; 0x02
    43fe:	08 96       	adiw	r24, 0x08	; 8
    4400:	0e 94 39 27 	call	0x4e72	; 0x4e72 <xTaskRemoveFromEventList>
    4404:	88 23       	and	r24, r24
    4406:	11 f0       	breq	.+4      	; 0x440c <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    4408:	0e 94 17 28 	call	0x502e	; 0x502e <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    440c:	e9 81       	ldd	r30, Y+1	; 0x01
    440e:	fa 81       	ldd	r31, Y+2	; 0x02
    4410:	85 8d       	ldd	r24, Z+29	; 0x1d
    4412:	81 50       	subi	r24, 0x01	; 1
    4414:	e9 81       	ldd	r30, Y+1	; 0x01
    4416:	fa 81       	ldd	r31, Y+2	; 0x02
    4418:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    441a:	e9 81       	ldd	r30, Y+1	; 0x01
    441c:	fa 81       	ldd	r31, Y+2	; 0x02
    441e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4420:	18 16       	cp	r1, r24
    4422:	34 f3       	brlt	.-52     	; 0x43f0 <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4424:	e9 81       	ldd	r30, Y+1	; 0x01
    4426:	fa 81       	ldd	r31, Y+2	; 0x02
    4428:	8f ef       	ldi	r24, 0xFF	; 255
    442a:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    442c:	0f 90       	pop	r0
    442e:	0f be       	out	0x3f, r0	; 63
}
    4430:	0f 90       	pop	r0
    4432:	0f 90       	pop	r0
    4434:	cf 91       	pop	r28
    4436:	df 91       	pop	r29
    4438:	08 95       	ret

0000443a <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    443a:	df 93       	push	r29
    443c:	cf 93       	push	r28
    443e:	00 d0       	rcall	.+0      	; 0x4440 <prvIsQueueEmpty+0x6>
    4440:	0f 92       	push	r0
    4442:	cd b7       	in	r28, 0x3d	; 61
    4444:	de b7       	in	r29, 0x3e	; 62
    4446:	9b 83       	std	Y+3, r25	; 0x03
    4448:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    444a:	0f b6       	in	r0, 0x3f	; 63
    444c:	f8 94       	cli
    444e:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    4450:	ea 81       	ldd	r30, Y+2	; 0x02
    4452:	fb 81       	ldd	r31, Y+3	; 0x03
    4454:	82 8d       	ldd	r24, Z+26	; 0x1a
    4456:	19 82       	std	Y+1, r1	; 0x01
    4458:	88 23       	and	r24, r24
    445a:	11 f4       	brne	.+4      	; 0x4460 <prvIsQueueEmpty+0x26>
    445c:	81 e0       	ldi	r24, 0x01	; 1
    445e:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    4460:	0f 90       	pop	r0
    4462:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    4464:	89 81       	ldd	r24, Y+1	; 0x01
}
    4466:	0f 90       	pop	r0
    4468:	0f 90       	pop	r0
    446a:	0f 90       	pop	r0
    446c:	cf 91       	pop	r28
    446e:	df 91       	pop	r29
    4470:	08 95       	ret

00004472 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    4472:	df 93       	push	r29
    4474:	cf 93       	push	r28
    4476:	00 d0       	rcall	.+0      	; 0x4478 <xQueueIsQueueEmptyFromISR+0x6>
    4478:	0f 92       	push	r0
    447a:	cd b7       	in	r28, 0x3d	; 61
    447c:	de b7       	in	r29, 0x3e	; 62
    447e:	9b 83       	std	Y+3, r25	; 0x03
    4480:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    4482:	ea 81       	ldd	r30, Y+2	; 0x02
    4484:	fb 81       	ldd	r31, Y+3	; 0x03
    4486:	82 8d       	ldd	r24, Z+26	; 0x1a
    4488:	19 82       	std	Y+1, r1	; 0x01
    448a:	88 23       	and	r24, r24
    448c:	11 f4       	brne	.+4      	; 0x4492 <xQueueIsQueueEmptyFromISR+0x20>
    448e:	81 e0       	ldi	r24, 0x01	; 1
    4490:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4492:	89 81       	ldd	r24, Y+1	; 0x01
}
    4494:	0f 90       	pop	r0
    4496:	0f 90       	pop	r0
    4498:	0f 90       	pop	r0
    449a:	cf 91       	pop	r28
    449c:	df 91       	pop	r29
    449e:	08 95       	ret

000044a0 <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    44a0:	df 93       	push	r29
    44a2:	cf 93       	push	r28
    44a4:	00 d0       	rcall	.+0      	; 0x44a6 <prvIsQueueFull+0x6>
    44a6:	0f 92       	push	r0
    44a8:	cd b7       	in	r28, 0x3d	; 61
    44aa:	de b7       	in	r29, 0x3e	; 62
    44ac:	9b 83       	std	Y+3, r25	; 0x03
    44ae:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    44b0:	0f b6       	in	r0, 0x3f	; 63
    44b2:	f8 94       	cli
    44b4:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    44b6:	ea 81       	ldd	r30, Y+2	; 0x02
    44b8:	fb 81       	ldd	r31, Y+3	; 0x03
    44ba:	92 8d       	ldd	r25, Z+26	; 0x1a
    44bc:	ea 81       	ldd	r30, Y+2	; 0x02
    44be:	fb 81       	ldd	r31, Y+3	; 0x03
    44c0:	83 8d       	ldd	r24, Z+27	; 0x1b
    44c2:	19 82       	std	Y+1, r1	; 0x01
    44c4:	98 17       	cp	r25, r24
    44c6:	11 f4       	brne	.+4      	; 0x44cc <prvIsQueueFull+0x2c>
    44c8:	81 e0       	ldi	r24, 0x01	; 1
    44ca:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    44cc:	0f 90       	pop	r0
    44ce:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    44d0:	89 81       	ldd	r24, Y+1	; 0x01
}
    44d2:	0f 90       	pop	r0
    44d4:	0f 90       	pop	r0
    44d6:	0f 90       	pop	r0
    44d8:	cf 91       	pop	r28
    44da:	df 91       	pop	r29
    44dc:	08 95       	ret

000044de <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    44de:	df 93       	push	r29
    44e0:	cf 93       	push	r28
    44e2:	00 d0       	rcall	.+0      	; 0x44e4 <xQueueIsQueueFullFromISR+0x6>
    44e4:	0f 92       	push	r0
    44e6:	cd b7       	in	r28, 0x3d	; 61
    44e8:	de b7       	in	r29, 0x3e	; 62
    44ea:	9b 83       	std	Y+3, r25	; 0x03
    44ec:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    44ee:	ea 81       	ldd	r30, Y+2	; 0x02
    44f0:	fb 81       	ldd	r31, Y+3	; 0x03
    44f2:	92 8d       	ldd	r25, Z+26	; 0x1a
    44f4:	ea 81       	ldd	r30, Y+2	; 0x02
    44f6:	fb 81       	ldd	r31, Y+3	; 0x03
    44f8:	83 8d       	ldd	r24, Z+27	; 0x1b
    44fa:	19 82       	std	Y+1, r1	; 0x01
    44fc:	98 17       	cp	r25, r24
    44fe:	11 f4       	brne	.+4      	; 0x4504 <xQueueIsQueueFullFromISR+0x26>
    4500:	81 e0       	ldi	r24, 0x01	; 1
    4502:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    4504:	89 81       	ldd	r24, Y+1	; 0x01
}
    4506:	0f 90       	pop	r0
    4508:	0f 90       	pop	r0
    450a:	0f 90       	pop	r0
    450c:	cf 91       	pop	r28
    450e:	df 91       	pop	r29
    4510:	08 95       	ret

00004512 <spi_masterinit>:
#include "STD_TYPES.h"
#include "BIT_MATH.h"
#include "spi_slave.h"
#include <avr/io.h>
void spi_masterinit()
{
    4512:	df 93       	push	r29
    4514:	cf 93       	push	r28
    4516:	cd b7       	in	r28, 0x3d	; 61
    4518:	de b7       	in	r29, 0x3e	; 62
	SPCR=(1<<SPE)|(1<<MSTR)|(1<<SPR0);
    451a:	ed e2       	ldi	r30, 0x2D	; 45
    451c:	f0 e0       	ldi	r31, 0x00	; 0
    451e:	81 e5       	ldi	r24, 0x51	; 81
    4520:	80 83       	st	Z, r24
}
    4522:	cf 91       	pop	r28
    4524:	df 91       	pop	r29
    4526:	08 95       	ret

00004528 <spi_slaveinit>:
void spi_slaveinit()
{
    4528:	df 93       	push	r29
    452a:	cf 93       	push	r28
    452c:	cd b7       	in	r28, 0x3d	; 61
    452e:	de b7       	in	r29, 0x3e	; 62
	SPCR=(1<<SPE);
    4530:	ed e2       	ldi	r30, 0x2D	; 45
    4532:	f0 e0       	ldi	r31, 0x00	; 0
    4534:	80 e4       	ldi	r24, 0x40	; 64
    4536:	80 83       	st	Z, r24
}
    4538:	cf 91       	pop	r28
    453a:	df 91       	pop	r29
    453c:	08 95       	ret

0000453e <spi_transmit>:
void spi_transmit(u8 val)
{SPDR=val;
    453e:	df 93       	push	r29
    4540:	cf 93       	push	r28
    4542:	0f 92       	push	r0
    4544:	cd b7       	in	r28, 0x3d	; 61
    4546:	de b7       	in	r29, 0x3e	; 62
    4548:	89 83       	std	Y+1, r24	; 0x01
    454a:	ef e2       	ldi	r30, 0x2F	; 47
    454c:	f0 e0       	ldi	r31, 0x00	; 0
    454e:	89 81       	ldd	r24, Y+1	; 0x01
    4550:	80 83       	st	Z, r24
	while(GET_BIT(SPSR,SPIF)==0){}
    4552:	ee e2       	ldi	r30, 0x2E	; 46
    4554:	f0 e0       	ldi	r31, 0x00	; 0
    4556:	80 81       	ld	r24, Z
    4558:	88 23       	and	r24, r24
    455a:	dc f7       	brge	.-10     	; 0x4552 <spi_transmit+0x14>

}
    455c:	0f 90       	pop	r0
    455e:	cf 91       	pop	r28
    4560:	df 91       	pop	r29
    4562:	08 95       	ret

00004564 <spi_receive>:
u8 spi_receive()
{
    4564:	df 93       	push	r29
    4566:	cf 93       	push	r28
    4568:	cd b7       	in	r28, 0x3d	; 61
    456a:	de b7       	in	r29, 0x3e	; 62
	while(GET_BIT(SPSR,SPIF)==0){}
    456c:	ee e2       	ldi	r30, 0x2E	; 46
    456e:	f0 e0       	ldi	r31, 0x00	; 0
    4570:	80 81       	ld	r24, Z
    4572:	88 23       	and	r24, r24
    4574:	dc f7       	brge	.-10     	; 0x456c <spi_receive+0x8>
		return SPDR;
    4576:	ef e2       	ldi	r30, 0x2F	; 47
    4578:	f0 e0       	ldi	r31, 0x00	; 0
    457a:	80 81       	ld	r24, Z
}
    457c:	cf 91       	pop	r28
    457e:	df 91       	pop	r29
    4580:	08 95       	ret

00004582 <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    4582:	af 92       	push	r10
    4584:	bf 92       	push	r11
    4586:	cf 92       	push	r12
    4588:	df 92       	push	r13
    458a:	ef 92       	push	r14
    458c:	ff 92       	push	r15
    458e:	0f 93       	push	r16
    4590:	1f 93       	push	r17
    4592:	df 93       	push	r29
    4594:	cf 93       	push	r28
    4596:	cd b7       	in	r28, 0x3d	; 61
    4598:	de b7       	in	r29, 0x3e	; 62
    459a:	64 97       	sbiw	r28, 0x14	; 20
    459c:	0f b6       	in	r0, 0x3f	; 63
    459e:	f8 94       	cli
    45a0:	de bf       	out	0x3e, r29	; 62
    45a2:	0f be       	out	0x3f, r0	; 63
    45a4:	cd bf       	out	0x3d, r28	; 61
    45a6:	9f 83       	std	Y+7, r25	; 0x07
    45a8:	8e 83       	std	Y+6, r24	; 0x06
    45aa:	79 87       	std	Y+9, r23	; 0x09
    45ac:	68 87       	std	Y+8, r22	; 0x08
    45ae:	5b 87       	std	Y+11, r21	; 0x0b
    45b0:	4a 87       	std	Y+10, r20	; 0x0a
    45b2:	3d 87       	std	Y+13, r19	; 0x0d
    45b4:	2c 87       	std	Y+12, r18	; 0x0c
    45b6:	0e 87       	std	Y+14, r16	; 0x0e
    45b8:	f8 8a       	std	Y+16, r15	; 0x10
    45ba:	ef 86       	std	Y+15, r14	; 0x0f
    45bc:	da 8a       	std	Y+18, r13	; 0x12
    45be:	c9 8a       	std	Y+17, r12	; 0x11
    45c0:	bc 8a       	std	Y+20, r11	; 0x14
    45c2:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    45c4:	8a 85       	ldd	r24, Y+10	; 0x0a
    45c6:	9b 85       	ldd	r25, Y+11	; 0x0b
    45c8:	29 89       	ldd	r18, Y+17	; 0x11
    45ca:	3a 89       	ldd	r19, Y+18	; 0x12
    45cc:	b9 01       	movw	r22, r18
    45ce:	0e 94 46 29 	call	0x528c	; 0x528c <prvAllocateTCBAndStack>
    45d2:	9c 83       	std	Y+4, r25	; 0x04
    45d4:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    45d6:	8b 81       	ldd	r24, Y+3	; 0x03
    45d8:	9c 81       	ldd	r25, Y+4	; 0x04
    45da:	00 97       	sbiw	r24, 0x00	; 0
    45dc:	09 f4       	brne	.+2      	; 0x45e0 <xTaskGenericCreate+0x5e>
    45de:	99 c0       	rjmp	.+306    	; 0x4712 <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    45e0:	eb 81       	ldd	r30, Y+3	; 0x03
    45e2:	fc 81       	ldd	r31, Y+4	; 0x04
    45e4:	27 89       	ldd	r18, Z+23	; 0x17
    45e6:	30 8d       	ldd	r19, Z+24	; 0x18
    45e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    45ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    45ec:	01 97       	sbiw	r24, 0x01	; 1
    45ee:	82 0f       	add	r24, r18
    45f0:	93 1f       	adc	r25, r19
    45f2:	9a 83       	std	Y+2, r25	; 0x02
    45f4:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    45f6:	8b 81       	ldd	r24, Y+3	; 0x03
    45f8:	9c 81       	ldd	r25, Y+4	; 0x04
    45fa:	28 85       	ldd	r18, Y+8	; 0x08
    45fc:	39 85       	ldd	r19, Y+9	; 0x09
    45fe:	eb 89       	ldd	r30, Y+19	; 0x13
    4600:	fc 89       	ldd	r31, Y+20	; 0x14
    4602:	aa 85       	ldd	r26, Y+10	; 0x0a
    4604:	bb 85       	ldd	r27, Y+11	; 0x0b
    4606:	b9 01       	movw	r22, r18
    4608:	4e 85       	ldd	r20, Y+14	; 0x0e
    460a:	9f 01       	movw	r18, r30
    460c:	8d 01       	movw	r16, r26
    460e:	0e 94 2b 28 	call	0x5056	; 0x5056 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    4612:	89 81       	ldd	r24, Y+1	; 0x01
    4614:	9a 81       	ldd	r25, Y+2	; 0x02
    4616:	2e 81       	ldd	r18, Y+6	; 0x06
    4618:	3f 81       	ldd	r19, Y+7	; 0x07
    461a:	4c 85       	ldd	r20, Y+12	; 0x0c
    461c:	5d 85       	ldd	r21, Y+13	; 0x0d
    461e:	b9 01       	movw	r22, r18
    4620:	0e 94 36 1b 	call	0x366c	; 0x366c <pxPortInitialiseStack>
    4624:	eb 81       	ldd	r30, Y+3	; 0x03
    4626:	fc 81       	ldd	r31, Y+4	; 0x04
    4628:	91 83       	std	Z+1, r25	; 0x01
    462a:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    462c:	8f 85       	ldd	r24, Y+15	; 0x0f
    462e:	98 89       	ldd	r25, Y+16	; 0x10
    4630:	00 97       	sbiw	r24, 0x00	; 0
    4632:	31 f0       	breq	.+12     	; 0x4640 <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    4634:	ef 85       	ldd	r30, Y+15	; 0x0f
    4636:	f8 89       	ldd	r31, Y+16	; 0x10
    4638:	8b 81       	ldd	r24, Y+3	; 0x03
    463a:	9c 81       	ldd	r25, Y+4	; 0x04
    463c:	91 83       	std	Z+1, r25	; 0x01
    463e:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    4640:	0f b6       	in	r0, 0x3f	; 63
    4642:	f8 94       	cli
    4644:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    4646:	80 91 59 07 	lds	r24, 0x0759
    464a:	8f 5f       	subi	r24, 0xFF	; 255
    464c:	80 93 59 07 	sts	0x0759, r24
			if( pxCurrentTCB == NULL )
    4650:	80 91 56 07 	lds	r24, 0x0756
    4654:	90 91 57 07 	lds	r25, 0x0757
    4658:	00 97       	sbiw	r24, 0x00	; 0
    465a:	69 f4       	brne	.+26     	; 0x4676 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    465c:	8b 81       	ldd	r24, Y+3	; 0x03
    465e:	9c 81       	ldd	r25, Y+4	; 0x04
    4660:	90 93 57 07 	sts	0x0757, r25
    4664:	80 93 56 07 	sts	0x0756, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    4668:	80 91 59 07 	lds	r24, 0x0759
    466c:	81 30       	cpi	r24, 0x01	; 1
    466e:	a9 f4       	brne	.+42     	; 0x469a <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    4670:	0e 94 82 28 	call	0x5104	; 0x5104 <prvInitialiseTaskLists>
    4674:	12 c0       	rjmp	.+36     	; 0x469a <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    4676:	80 91 5e 07 	lds	r24, 0x075E
    467a:	88 23       	and	r24, r24
    467c:	71 f4       	brne	.+28     	; 0x469a <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    467e:	e0 91 56 07 	lds	r30, 0x0756
    4682:	f0 91 57 07 	lds	r31, 0x0757
    4686:	96 89       	ldd	r25, Z+22	; 0x16
    4688:	8e 85       	ldd	r24, Y+14	; 0x0e
    468a:	89 17       	cp	r24, r25
    468c:	30 f0       	brcs	.+12     	; 0x469a <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    468e:	8b 81       	ldd	r24, Y+3	; 0x03
    4690:	9c 81       	ldd	r25, Y+4	; 0x04
    4692:	90 93 57 07 	sts	0x0757, r25
    4696:	80 93 56 07 	sts	0x0756, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    469a:	eb 81       	ldd	r30, Y+3	; 0x03
    469c:	fc 81       	ldd	r31, Y+4	; 0x04
    469e:	96 89       	ldd	r25, Z+22	; 0x16
    46a0:	80 91 5c 07 	lds	r24, 0x075C
    46a4:	89 17       	cp	r24, r25
    46a6:	28 f4       	brcc	.+10     	; 0x46b2 <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    46a8:	eb 81       	ldd	r30, Y+3	; 0x03
    46aa:	fc 81       	ldd	r31, Y+4	; 0x04
    46ac:	86 89       	ldd	r24, Z+22	; 0x16
    46ae:	80 93 5c 07 	sts	0x075C, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    46b2:	80 91 63 07 	lds	r24, 0x0763
    46b6:	8f 5f       	subi	r24, 0xFF	; 255
    46b8:	80 93 63 07 	sts	0x0763, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    46bc:	eb 81       	ldd	r30, Y+3	; 0x03
    46be:	fc 81       	ldd	r31, Y+4	; 0x04
    46c0:	96 89       	ldd	r25, Z+22	; 0x16
    46c2:	80 91 5d 07 	lds	r24, 0x075D
    46c6:	89 17       	cp	r24, r25
    46c8:	28 f4       	brcc	.+10     	; 0x46d4 <xTaskGenericCreate+0x152>
    46ca:	eb 81       	ldd	r30, Y+3	; 0x03
    46cc:	fc 81       	ldd	r31, Y+4	; 0x04
    46ce:	86 89       	ldd	r24, Z+22	; 0x16
    46d0:	80 93 5d 07 	sts	0x075D, r24
    46d4:	eb 81       	ldd	r30, Y+3	; 0x03
    46d6:	fc 81       	ldd	r31, Y+4	; 0x04
    46d8:	86 89       	ldd	r24, Z+22	; 0x16
    46da:	28 2f       	mov	r18, r24
    46dc:	30 e0       	ldi	r19, 0x00	; 0
    46de:	c9 01       	movw	r24, r18
    46e0:	88 0f       	add	r24, r24
    46e2:	99 1f       	adc	r25, r25
    46e4:	88 0f       	add	r24, r24
    46e6:	99 1f       	adc	r25, r25
    46e8:	88 0f       	add	r24, r24
    46ea:	99 1f       	adc	r25, r25
    46ec:	82 0f       	add	r24, r18
    46ee:	93 1f       	adc	r25, r19
    46f0:	ac 01       	movw	r20, r24
    46f2:	4c 59       	subi	r20, 0x9C	; 156
    46f4:	58 4f       	sbci	r21, 0xF8	; 248
    46f6:	8b 81       	ldd	r24, Y+3	; 0x03
    46f8:	9c 81       	ldd	r25, Y+4	; 0x04
    46fa:	9c 01       	movw	r18, r24
    46fc:	2e 5f       	subi	r18, 0xFE	; 254
    46fe:	3f 4f       	sbci	r19, 0xFF	; 255
    4700:	ca 01       	movw	r24, r20
    4702:	b9 01       	movw	r22, r18
    4704:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>

			xReturn = pdPASS;
    4708:	81 e0       	ldi	r24, 0x01	; 1
    470a:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    470c:	0f 90       	pop	r0
    470e:	0f be       	out	0x3f, r0	; 63
    4710:	02 c0       	rjmp	.+4      	; 0x4716 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    4712:	8f ef       	ldi	r24, 0xFF	; 255
    4714:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    4716:	8d 81       	ldd	r24, Y+5	; 0x05
    4718:	81 30       	cpi	r24, 0x01	; 1
    471a:	71 f4       	brne	.+28     	; 0x4738 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    471c:	80 91 5e 07 	lds	r24, 0x075E
    4720:	88 23       	and	r24, r24
    4722:	51 f0       	breq	.+20     	; 0x4738 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    4724:	e0 91 56 07 	lds	r30, 0x0756
    4728:	f0 91 57 07 	lds	r31, 0x0757
    472c:	96 89       	ldd	r25, Z+22	; 0x16
    472e:	8e 85       	ldd	r24, Y+14	; 0x0e
    4730:	98 17       	cp	r25, r24
    4732:	10 f4       	brcc	.+4      	; 0x4738 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    4734:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
			}
		}
	}

	return xReturn;
    4738:	8d 81       	ldd	r24, Y+5	; 0x05
}
    473a:	64 96       	adiw	r28, 0x14	; 20
    473c:	0f b6       	in	r0, 0x3f	; 63
    473e:	f8 94       	cli
    4740:	de bf       	out	0x3e, r29	; 62
    4742:	0f be       	out	0x3f, r0	; 63
    4744:	cd bf       	out	0x3d, r28	; 61
    4746:	cf 91       	pop	r28
    4748:	df 91       	pop	r29
    474a:	1f 91       	pop	r17
    474c:	0f 91       	pop	r16
    474e:	ff 90       	pop	r15
    4750:	ef 90       	pop	r14
    4752:	df 90       	pop	r13
    4754:	cf 90       	pop	r12
    4756:	bf 90       	pop	r11
    4758:	af 90       	pop	r10
    475a:	08 95       	ret

0000475c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle pxTaskToDelete )
	{
    475c:	df 93       	push	r29
    475e:	cf 93       	push	r28
    4760:	00 d0       	rcall	.+0      	; 0x4762 <vTaskDelete+0x6>
    4762:	00 d0       	rcall	.+0      	; 0x4764 <vTaskDelete+0x8>
    4764:	00 d0       	rcall	.+0      	; 0x4766 <vTaskDelete+0xa>
    4766:	cd b7       	in	r28, 0x3d	; 61
    4768:	de b7       	in	r29, 0x3e	; 62
    476a:	9c 83       	std	Y+4, r25	; 0x04
    476c:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    476e:	0f b6       	in	r0, 0x3f	; 63
    4770:	f8 94       	cli
    4772:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( pxTaskToDelete == pxCurrentTCB )
    4774:	20 91 56 07 	lds	r18, 0x0756
    4778:	30 91 57 07 	lds	r19, 0x0757
    477c:	8b 81       	ldd	r24, Y+3	; 0x03
    477e:	9c 81       	ldd	r25, Y+4	; 0x04
    4780:	82 17       	cp	r24, r18
    4782:	93 07       	cpc	r25, r19
    4784:	11 f4       	brne	.+4      	; 0x478a <vTaskDelete+0x2e>
			{
				pxTaskToDelete = NULL;
    4786:	1c 82       	std	Y+4, r1	; 0x04
    4788:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToDelete );
    478a:	8b 81       	ldd	r24, Y+3	; 0x03
    478c:	9c 81       	ldd	r25, Y+4	; 0x04
    478e:	00 97       	sbiw	r24, 0x00	; 0
    4790:	39 f4       	brne	.+14     	; 0x47a0 <vTaskDelete+0x44>
    4792:	80 91 56 07 	lds	r24, 0x0756
    4796:	90 91 57 07 	lds	r25, 0x0757
    479a:	9e 83       	std	Y+6, r25	; 0x06
    479c:	8d 83       	std	Y+5, r24	; 0x05
    479e:	04 c0       	rjmp	.+8      	; 0x47a8 <vTaskDelete+0x4c>
    47a0:	8b 81       	ldd	r24, Y+3	; 0x03
    47a2:	9c 81       	ldd	r25, Y+4	; 0x04
    47a4:	9e 83       	std	Y+6, r25	; 0x06
    47a6:	8d 83       	std	Y+5, r24	; 0x05
    47a8:	8d 81       	ldd	r24, Y+5	; 0x05
    47aa:	9e 81       	ldd	r25, Y+6	; 0x06
    47ac:	9a 83       	std	Y+2, r25	; 0x02
    47ae:	89 83       	std	Y+1, r24	; 0x01

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    47b0:	89 81       	ldd	r24, Y+1	; 0x01
    47b2:	9a 81       	ldd	r25, Y+2	; 0x02
    47b4:	02 96       	adiw	r24, 0x02	; 2
    47b6:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    47ba:	e9 81       	ldd	r30, Y+1	; 0x01
    47bc:	fa 81       	ldd	r31, Y+2	; 0x02
    47be:	84 89       	ldd	r24, Z+20	; 0x14
    47c0:	95 89       	ldd	r25, Z+21	; 0x15
    47c2:	00 97       	sbiw	r24, 0x00	; 0
    47c4:	29 f0       	breq	.+10     	; 0x47d0 <vTaskDelete+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    47c6:	89 81       	ldd	r24, Y+1	; 0x01
    47c8:	9a 81       	ldd	r25, Y+2	; 0x02
    47ca:	0c 96       	adiw	r24, 0x0c	; 12
    47cc:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
    47d0:	89 81       	ldd	r24, Y+1	; 0x01
    47d2:	9a 81       	ldd	r25, Y+2	; 0x02
    47d4:	9c 01       	movw	r18, r24
    47d6:	2e 5f       	subi	r18, 0xFE	; 254
    47d8:	3f 4f       	sbci	r19, 0xFF	; 255
    47da:	80 eb       	ldi	r24, 0xB0	; 176
    47dc:	97 e0       	ldi	r25, 0x07	; 7
    47de:	b9 01       	movw	r22, r18
    47e0:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
    47e4:	80 91 58 07 	lds	r24, 0x0758
    47e8:	8f 5f       	subi	r24, 0xFF	; 255
    47ea:	80 93 58 07 	sts	0x0758, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
    47ee:	80 91 63 07 	lds	r24, 0x0763
    47f2:	8f 5f       	subi	r24, 0xFF	; 255
    47f4:	80 93 63 07 	sts	0x0763, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
    47f8:	0f 90       	pop	r0
    47fa:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
    47fc:	80 91 5e 07 	lds	r24, 0x075E
    4800:	88 23       	and	r24, r24
    4802:	31 f0       	breq	.+12     	; 0x4810 <vTaskDelete+0xb4>
		{
			if( ( void * ) pxTaskToDelete == NULL )
    4804:	8b 81       	ldd	r24, Y+3	; 0x03
    4806:	9c 81       	ldd	r25, Y+4	; 0x04
    4808:	00 97       	sbiw	r24, 0x00	; 0
    480a:	11 f4       	brne	.+4      	; 0x4810 <vTaskDelete+0xb4>
			{
				portYIELD_WITHIN_API();
    480c:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
			}
		}
	}
    4810:	26 96       	adiw	r28, 0x06	; 6
    4812:	0f b6       	in	r0, 0x3f	; 63
    4814:	f8 94       	cli
    4816:	de bf       	out	0x3e, r29	; 62
    4818:	0f be       	out	0x3f, r0	; 63
    481a:	cd bf       	out	0x3d, r28	; 61
    481c:	cf 91       	pop	r28
    481e:	df 91       	pop	r29
    4820:	08 95       	ret

00004822 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    4822:	df 93       	push	r29
    4824:	cf 93       	push	r28
    4826:	cd b7       	in	r28, 0x3d	; 61
    4828:	de b7       	in	r29, 0x3e	; 62
    482a:	28 97       	sbiw	r28, 0x08	; 8
    482c:	0f b6       	in	r0, 0x3f	; 63
    482e:	f8 94       	cli
    4830:	de bf       	out	0x3e, r29	; 62
    4832:	0f be       	out	0x3f, r0	; 63
    4834:	cd bf       	out	0x3d, r28	; 61
    4836:	9e 83       	std	Y+6, r25	; 0x06
    4838:	8d 83       	std	Y+5, r24	; 0x05
    483a:	78 87       	std	Y+8, r23	; 0x08
    483c:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    483e:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    4840:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    4844:	ed 81       	ldd	r30, Y+5	; 0x05
    4846:	fe 81       	ldd	r31, Y+6	; 0x06
    4848:	20 81       	ld	r18, Z
    484a:	31 81       	ldd	r19, Z+1	; 0x01
    484c:	8f 81       	ldd	r24, Y+7	; 0x07
    484e:	98 85       	ldd	r25, Y+8	; 0x08
    4850:	82 0f       	add	r24, r18
    4852:	93 1f       	adc	r25, r19
    4854:	9c 83       	std	Y+4, r25	; 0x04
    4856:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    4858:	ed 81       	ldd	r30, Y+5	; 0x05
    485a:	fe 81       	ldd	r31, Y+6	; 0x06
    485c:	20 81       	ld	r18, Z
    485e:	31 81       	ldd	r19, Z+1	; 0x01
    4860:	80 91 5a 07 	lds	r24, 0x075A
    4864:	90 91 5b 07 	lds	r25, 0x075B
    4868:	82 17       	cp	r24, r18
    486a:	93 07       	cpc	r25, r19
    486c:	a8 f4       	brcc	.+42     	; 0x4898 <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    486e:	ed 81       	ldd	r30, Y+5	; 0x05
    4870:	fe 81       	ldd	r31, Y+6	; 0x06
    4872:	20 81       	ld	r18, Z
    4874:	31 81       	ldd	r19, Z+1	; 0x01
    4876:	8b 81       	ldd	r24, Y+3	; 0x03
    4878:	9c 81       	ldd	r25, Y+4	; 0x04
    487a:	82 17       	cp	r24, r18
    487c:	93 07       	cpc	r25, r19
    487e:	00 f5       	brcc	.+64     	; 0x48c0 <vTaskDelayUntil+0x9e>
    4880:	20 91 5a 07 	lds	r18, 0x075A
    4884:	30 91 5b 07 	lds	r19, 0x075B
    4888:	8b 81       	ldd	r24, Y+3	; 0x03
    488a:	9c 81       	ldd	r25, Y+4	; 0x04
    488c:	28 17       	cp	r18, r24
    488e:	39 07       	cpc	r19, r25
    4890:	b8 f4       	brcc	.+46     	; 0x48c0 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    4892:	81 e0       	ldi	r24, 0x01	; 1
    4894:	89 83       	std	Y+1, r24	; 0x01
    4896:	14 c0       	rjmp	.+40     	; 0x48c0 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    4898:	ed 81       	ldd	r30, Y+5	; 0x05
    489a:	fe 81       	ldd	r31, Y+6	; 0x06
    489c:	20 81       	ld	r18, Z
    489e:	31 81       	ldd	r19, Z+1	; 0x01
    48a0:	8b 81       	ldd	r24, Y+3	; 0x03
    48a2:	9c 81       	ldd	r25, Y+4	; 0x04
    48a4:	82 17       	cp	r24, r18
    48a6:	93 07       	cpc	r25, r19
    48a8:	48 f0       	brcs	.+18     	; 0x48bc <vTaskDelayUntil+0x9a>
    48aa:	20 91 5a 07 	lds	r18, 0x075A
    48ae:	30 91 5b 07 	lds	r19, 0x075B
    48b2:	8b 81       	ldd	r24, Y+3	; 0x03
    48b4:	9c 81       	ldd	r25, Y+4	; 0x04
    48b6:	28 17       	cp	r18, r24
    48b8:	39 07       	cpc	r19, r25
    48ba:	10 f4       	brcc	.+4      	; 0x48c0 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    48bc:	81 e0       	ldi	r24, 0x01	; 1
    48be:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    48c0:	ed 81       	ldd	r30, Y+5	; 0x05
    48c2:	fe 81       	ldd	r31, Y+6	; 0x06
    48c4:	8b 81       	ldd	r24, Y+3	; 0x03
    48c6:	9c 81       	ldd	r25, Y+4	; 0x04
    48c8:	91 83       	std	Z+1, r25	; 0x01
    48ca:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    48cc:	89 81       	ldd	r24, Y+1	; 0x01
    48ce:	88 23       	and	r24, r24
    48d0:	59 f0       	breq	.+22     	; 0x48e8 <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    48d2:	80 91 56 07 	lds	r24, 0x0756
    48d6:	90 91 57 07 	lds	r25, 0x0757
    48da:	02 96       	adiw	r24, 0x02	; 2
    48dc:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    48e0:	8b 81       	ldd	r24, Y+3	; 0x03
    48e2:	9c 81       	ldd	r25, Y+4	; 0x04
    48e4:	0e 94 fd 28 	call	0x51fa	; 0x51fa <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    48e8:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    48ec:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    48ee:	8a 81       	ldd	r24, Y+2	; 0x02
    48f0:	88 23       	and	r24, r24
    48f2:	11 f4       	brne	.+4      	; 0x48f8 <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    48f4:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
		}
	}
    48f8:	28 96       	adiw	r28, 0x08	; 8
    48fa:	0f b6       	in	r0, 0x3f	; 63
    48fc:	f8 94       	cli
    48fe:	de bf       	out	0x3e, r29	; 62
    4900:	0f be       	out	0x3f, r0	; 63
    4902:	cd bf       	out	0x3d, r28	; 61
    4904:	cf 91       	pop	r28
    4906:	df 91       	pop	r29
    4908:	08 95       	ret

0000490a <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    490a:	df 93       	push	r29
    490c:	cf 93       	push	r28
    490e:	00 d0       	rcall	.+0      	; 0x4910 <vTaskDelay+0x6>
    4910:	00 d0       	rcall	.+0      	; 0x4912 <vTaskDelay+0x8>
    4912:	0f 92       	push	r0
    4914:	cd b7       	in	r28, 0x3d	; 61
    4916:	de b7       	in	r29, 0x3e	; 62
    4918:	9d 83       	std	Y+5, r25	; 0x05
    491a:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    491c:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    491e:	8c 81       	ldd	r24, Y+4	; 0x04
    4920:	9d 81       	ldd	r25, Y+5	; 0x05
    4922:	00 97       	sbiw	r24, 0x00	; 0
    4924:	d1 f0       	breq	.+52     	; 0x495a <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    4926:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    492a:	20 91 5a 07 	lds	r18, 0x075A
    492e:	30 91 5b 07 	lds	r19, 0x075B
    4932:	8c 81       	ldd	r24, Y+4	; 0x04
    4934:	9d 81       	ldd	r25, Y+5	; 0x05
    4936:	82 0f       	add	r24, r18
    4938:	93 1f       	adc	r25, r19
    493a:	9b 83       	std	Y+3, r25	; 0x03
    493c:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    493e:	80 91 56 07 	lds	r24, 0x0756
    4942:	90 91 57 07 	lds	r25, 0x0757
    4946:	02 96       	adiw	r24, 0x02	; 2
    4948:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    494c:	8a 81       	ldd	r24, Y+2	; 0x02
    494e:	9b 81       	ldd	r25, Y+3	; 0x03
    4950:	0e 94 fd 28 	call	0x51fa	; 0x51fa <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    4954:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>
    4958:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    495a:	89 81       	ldd	r24, Y+1	; 0x01
    495c:	88 23       	and	r24, r24
    495e:	11 f4       	brne	.+4      	; 0x4964 <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    4960:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
		}
	}
    4964:	0f 90       	pop	r0
    4966:	0f 90       	pop	r0
    4968:	0f 90       	pop	r0
    496a:	0f 90       	pop	r0
    496c:	0f 90       	pop	r0
    496e:	cf 91       	pop	r28
    4970:	df 91       	pop	r29
    4972:	08 95       	ret

00004974 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    4974:	af 92       	push	r10
    4976:	bf 92       	push	r11
    4978:	cf 92       	push	r12
    497a:	df 92       	push	r13
    497c:	ef 92       	push	r14
    497e:	ff 92       	push	r15
    4980:	0f 93       	push	r16
    4982:	df 93       	push	r29
    4984:	cf 93       	push	r28
    4986:	0f 92       	push	r0
    4988:	cd b7       	in	r28, 0x3d	; 61
    498a:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    498c:	2f ee       	ldi	r18, 0xEF	; 239
    498e:	30 e0       	ldi	r19, 0x00	; 0
    4990:	81 e2       	ldi	r24, 0x21	; 33
    4992:	98 e2       	ldi	r25, 0x28	; 40
    4994:	b9 01       	movw	r22, r18
    4996:	45 e5       	ldi	r20, 0x55	; 85
    4998:	50 e0       	ldi	r21, 0x00	; 0
    499a:	20 e0       	ldi	r18, 0x00	; 0
    499c:	30 e0       	ldi	r19, 0x00	; 0
    499e:	00 e0       	ldi	r16, 0x00	; 0
    49a0:	ee 24       	eor	r14, r14
    49a2:	ff 24       	eor	r15, r15
    49a4:	cc 24       	eor	r12, r12
    49a6:	dd 24       	eor	r13, r13
    49a8:	aa 24       	eor	r10, r10
    49aa:	bb 24       	eor	r11, r11
    49ac:	0e 94 c1 22 	call	0x4582	; 0x4582 <xTaskGenericCreate>
    49b0:	89 83       	std	Y+1, r24	; 0x01
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif

	if( xReturn == pdPASS )
    49b2:	89 81       	ldd	r24, Y+1	; 0x01
    49b4:	81 30       	cpi	r24, 0x01	; 1
    49b6:	51 f4       	brne	.+20     	; 0x49cc <vTaskStartScheduler+0x58>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    49b8:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    49ba:	81 e0       	ldi	r24, 0x01	; 1
    49bc:	80 93 5e 07 	sts	0x075E, r24
		xTickCount = ( portTickType ) 0U;
    49c0:	10 92 5b 07 	sts	0x075B, r1
    49c4:	10 92 5a 07 	sts	0x075A, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    49c8:	0e 94 b9 1c 	call	0x3972	; 0x3972 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    49cc:	0f 90       	pop	r0
    49ce:	cf 91       	pop	r28
    49d0:	df 91       	pop	r29
    49d2:	0f 91       	pop	r16
    49d4:	ff 90       	pop	r15
    49d6:	ef 90       	pop	r14
    49d8:	df 90       	pop	r13
    49da:	cf 90       	pop	r12
    49dc:	bf 90       	pop	r11
    49de:	af 90       	pop	r10
    49e0:	08 95       	ret

000049e2 <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    49e2:	df 93       	push	r29
    49e4:	cf 93       	push	r28
    49e6:	cd b7       	in	r28, 0x3d	; 61
    49e8:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    49ea:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    49ec:	10 92 5e 07 	sts	0x075E, r1
	vPortEndScheduler();
    49f0:	0e 94 ee 1c 	call	0x39dc	; 0x39dc <vPortEndScheduler>
}
    49f4:	cf 91       	pop	r28
    49f6:	df 91       	pop	r29
    49f8:	08 95       	ret

000049fa <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    49fa:	df 93       	push	r29
    49fc:	cf 93       	push	r28
    49fe:	cd b7       	in	r28, 0x3d	; 61
    4a00:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    4a02:	80 91 5f 07 	lds	r24, 0x075F
    4a06:	8f 5f       	subi	r24, 0xFF	; 255
    4a08:	80 93 5f 07 	sts	0x075F, r24
}
    4a0c:	cf 91       	pop	r28
    4a0e:	df 91       	pop	r29
    4a10:	08 95       	ret

00004a12 <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    4a12:	df 93       	push	r29
    4a14:	cf 93       	push	r28
    4a16:	00 d0       	rcall	.+0      	; 0x4a18 <xTaskResumeAll+0x6>
    4a18:	00 d0       	rcall	.+0      	; 0x4a1a <xTaskResumeAll+0x8>
    4a1a:	cd b7       	in	r28, 0x3d	; 61
    4a1c:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    4a1e:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    4a20:	0f b6       	in	r0, 0x3f	; 63
    4a22:	f8 94       	cli
    4a24:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    4a26:	80 91 5f 07 	lds	r24, 0x075F
    4a2a:	81 50       	subi	r24, 0x01	; 1
    4a2c:	80 93 5f 07 	sts	0x075F, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4a30:	80 91 5f 07 	lds	r24, 0x075F
    4a34:	88 23       	and	r24, r24
    4a36:	09 f0       	breq	.+2      	; 0x4a3a <xTaskResumeAll+0x28>
    4a38:	6c c0       	rjmp	.+216    	; 0x4b12 <xTaskResumeAll+0x100>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    4a3a:	80 91 59 07 	lds	r24, 0x0759
    4a3e:	88 23       	and	r24, r24
    4a40:	09 f4       	brne	.+2      	; 0x4a44 <xTaskResumeAll+0x32>
    4a42:	67 c0       	rjmp	.+206    	; 0x4b12 <xTaskResumeAll+0x100>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    4a44:	19 82       	std	Y+1, r1	; 0x01
    4a46:	41 c0       	rjmp	.+130    	; 0x4aca <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    4a48:	e0 91 ac 07 	lds	r30, 0x07AC
    4a4c:	f0 91 ad 07 	lds	r31, 0x07AD
    4a50:	86 81       	ldd	r24, Z+6	; 0x06
    4a52:	97 81       	ldd	r25, Z+7	; 0x07
    4a54:	9c 83       	std	Y+4, r25	; 0x04
    4a56:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    4a58:	8b 81       	ldd	r24, Y+3	; 0x03
    4a5a:	9c 81       	ldd	r25, Y+4	; 0x04
    4a5c:	0c 96       	adiw	r24, 0x0c	; 12
    4a5e:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    4a62:	8b 81       	ldd	r24, Y+3	; 0x03
    4a64:	9c 81       	ldd	r25, Y+4	; 0x04
    4a66:	02 96       	adiw	r24, 0x02	; 2
    4a68:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    4a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    4a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    4a70:	96 89       	ldd	r25, Z+22	; 0x16
    4a72:	80 91 5d 07 	lds	r24, 0x075D
    4a76:	89 17       	cp	r24, r25
    4a78:	28 f4       	brcc	.+10     	; 0x4a84 <xTaskResumeAll+0x72>
    4a7a:	eb 81       	ldd	r30, Y+3	; 0x03
    4a7c:	fc 81       	ldd	r31, Y+4	; 0x04
    4a7e:	86 89       	ldd	r24, Z+22	; 0x16
    4a80:	80 93 5d 07 	sts	0x075D, r24
    4a84:	eb 81       	ldd	r30, Y+3	; 0x03
    4a86:	fc 81       	ldd	r31, Y+4	; 0x04
    4a88:	86 89       	ldd	r24, Z+22	; 0x16
    4a8a:	28 2f       	mov	r18, r24
    4a8c:	30 e0       	ldi	r19, 0x00	; 0
    4a8e:	c9 01       	movw	r24, r18
    4a90:	88 0f       	add	r24, r24
    4a92:	99 1f       	adc	r25, r25
    4a94:	88 0f       	add	r24, r24
    4a96:	99 1f       	adc	r25, r25
    4a98:	88 0f       	add	r24, r24
    4a9a:	99 1f       	adc	r25, r25
    4a9c:	82 0f       	add	r24, r18
    4a9e:	93 1f       	adc	r25, r19
    4aa0:	8c 59       	subi	r24, 0x9C	; 156
    4aa2:	98 4f       	sbci	r25, 0xF8	; 248
    4aa4:	2b 81       	ldd	r18, Y+3	; 0x03
    4aa6:	3c 81       	ldd	r19, Y+4	; 0x04
    4aa8:	2e 5f       	subi	r18, 0xFE	; 254
    4aaa:	3f 4f       	sbci	r19, 0xFF	; 255
    4aac:	b9 01       	movw	r22, r18
    4aae:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4ab2:	eb 81       	ldd	r30, Y+3	; 0x03
    4ab4:	fc 81       	ldd	r31, Y+4	; 0x04
    4ab6:	96 89       	ldd	r25, Z+22	; 0x16
    4ab8:	e0 91 56 07 	lds	r30, 0x0756
    4abc:	f0 91 57 07 	lds	r31, 0x0757
    4ac0:	86 89       	ldd	r24, Z+22	; 0x16
    4ac2:	98 17       	cp	r25, r24
    4ac4:	10 f0       	brcs	.+4      	; 0x4aca <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    4ac6:	81 e0       	ldi	r24, 0x01	; 1
    4ac8:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    4aca:	80 91 a7 07 	lds	r24, 0x07A7
    4ace:	88 23       	and	r24, r24
    4ad0:	09 f0       	breq	.+2      	; 0x4ad4 <xTaskResumeAll+0xc2>
    4ad2:	ba cf       	rjmp	.-140    	; 0x4a48 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4ad4:	80 91 60 07 	lds	r24, 0x0760
    4ad8:	88 23       	and	r24, r24
    4ada:	71 f0       	breq	.+28     	; 0x4af8 <xTaskResumeAll+0xe6>
    4adc:	07 c0       	rjmp	.+14     	; 0x4aec <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    4ade:	0e 94 c8 25 	call	0x4b90	; 0x4b90 <vTaskIncrementTick>
						--uxMissedTicks;
    4ae2:	80 91 60 07 	lds	r24, 0x0760
    4ae6:	81 50       	subi	r24, 0x01	; 1
    4ae8:	80 93 60 07 	sts	0x0760, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    4aec:	80 91 60 07 	lds	r24, 0x0760
    4af0:	88 23       	and	r24, r24
    4af2:	a9 f7       	brne	.-22     	; 0x4ade <xTaskResumeAll+0xcc>
					/* As we have processed some ticks it is appropriate to yield
					to ensure the highest priority task that is ready to run is
					the task actually running. */
					#if configUSE_PREEMPTION == 1
					{
						xYieldRequired = pdTRUE;
    4af4:	81 e0       	ldi	r24, 0x01	; 1
    4af6:	89 83       	std	Y+1, r24	; 0x01
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    4af8:	89 81       	ldd	r24, Y+1	; 0x01
    4afa:	81 30       	cpi	r24, 0x01	; 1
    4afc:	21 f0       	breq	.+8      	; 0x4b06 <xTaskResumeAll+0xf4>
    4afe:	80 91 61 07 	lds	r24, 0x0761
    4b02:	81 30       	cpi	r24, 0x01	; 1
    4b04:	31 f4       	brne	.+12     	; 0x4b12 <xTaskResumeAll+0x100>
				{
					xAlreadyYielded = pdTRUE;
    4b06:	81 e0       	ldi	r24, 0x01	; 1
    4b08:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    4b0a:	10 92 61 07 	sts	0x0761, r1
					portYIELD_WITHIN_API();
    4b0e:	0e 94 f5 1c 	call	0x39ea	; 0x39ea <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    4b12:	0f 90       	pop	r0
    4b14:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    4b16:	8a 81       	ldd	r24, Y+2	; 0x02
}
    4b18:	0f 90       	pop	r0
    4b1a:	0f 90       	pop	r0
    4b1c:	0f 90       	pop	r0
    4b1e:	0f 90       	pop	r0
    4b20:	cf 91       	pop	r28
    4b22:	df 91       	pop	r29
    4b24:	08 95       	ret

00004b26 <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    4b26:	df 93       	push	r29
    4b28:	cf 93       	push	r28
    4b2a:	00 d0       	rcall	.+0      	; 0x4b2c <xTaskGetTickCount+0x6>
    4b2c:	cd b7       	in	r28, 0x3d	; 61
    4b2e:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    4b30:	0f b6       	in	r0, 0x3f	; 63
    4b32:	f8 94       	cli
    4b34:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    4b36:	80 91 5a 07 	lds	r24, 0x075A
    4b3a:	90 91 5b 07 	lds	r25, 0x075B
    4b3e:	9a 83       	std	Y+2, r25	; 0x02
    4b40:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    4b42:	0f 90       	pop	r0
    4b44:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    4b46:	89 81       	ldd	r24, Y+1	; 0x01
    4b48:	9a 81       	ldd	r25, Y+2	; 0x02
}
    4b4a:	0f 90       	pop	r0
    4b4c:	0f 90       	pop	r0
    4b4e:	cf 91       	pop	r28
    4b50:	df 91       	pop	r29
    4b52:	08 95       	ret

00004b54 <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    4b54:	df 93       	push	r29
    4b56:	cf 93       	push	r28
    4b58:	00 d0       	rcall	.+0      	; 0x4b5a <xTaskGetTickCountFromISR+0x6>
    4b5a:	0f 92       	push	r0
    4b5c:	cd b7       	in	r28, 0x3d	; 61
    4b5e:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    4b60:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    4b62:	80 91 5a 07 	lds	r24, 0x075A
    4b66:	90 91 5b 07 	lds	r25, 0x075B
    4b6a:	9b 83       	std	Y+3, r25	; 0x03
    4b6c:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    4b6e:	8a 81       	ldd	r24, Y+2	; 0x02
    4b70:	9b 81       	ldd	r25, Y+3	; 0x03
}
    4b72:	0f 90       	pop	r0
    4b74:	0f 90       	pop	r0
    4b76:	0f 90       	pop	r0
    4b78:	cf 91       	pop	r28
    4b7a:	df 91       	pop	r29
    4b7c:	08 95       	ret

00004b7e <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    4b7e:	df 93       	push	r29
    4b80:	cf 93       	push	r28
    4b82:	cd b7       	in	r28, 0x3d	; 61
    4b84:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    4b86:	80 91 59 07 	lds	r24, 0x0759
}
    4b8a:	cf 91       	pop	r28
    4b8c:	df 91       	pop	r29
    4b8e:	08 95       	ret

00004b90 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    4b90:	df 93       	push	r29
    4b92:	cf 93       	push	r28
    4b94:	00 d0       	rcall	.+0      	; 0x4b96 <vTaskIncrementTick+0x6>
    4b96:	00 d0       	rcall	.+0      	; 0x4b98 <vTaskIncrementTick+0x8>
    4b98:	00 d0       	rcall	.+0      	; 0x4b9a <vTaskIncrementTick+0xa>
    4b9a:	cd b7       	in	r28, 0x3d	; 61
    4b9c:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4b9e:	80 91 5f 07 	lds	r24, 0x075F
    4ba2:	88 23       	and	r24, r24
    4ba4:	09 f0       	breq	.+2      	; 0x4ba8 <vTaskIncrementTick+0x18>
    4ba6:	bb c0       	rjmp	.+374    	; 0x4d1e <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    4ba8:	80 91 5a 07 	lds	r24, 0x075A
    4bac:	90 91 5b 07 	lds	r25, 0x075B
    4bb0:	01 96       	adiw	r24, 0x01	; 1
    4bb2:	90 93 5b 07 	sts	0x075B, r25
    4bb6:	80 93 5a 07 	sts	0x075A, r24
		if( xTickCount == ( portTickType ) 0U )
    4bba:	80 91 5a 07 	lds	r24, 0x075A
    4bbe:	90 91 5b 07 	lds	r25, 0x075B
    4bc2:	00 97       	sbiw	r24, 0x00	; 0
    4bc4:	d1 f5       	brne	.+116    	; 0x4c3a <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    4bc6:	80 91 a3 07 	lds	r24, 0x07A3
    4bca:	90 91 a4 07 	lds	r25, 0x07A4
    4bce:	9c 83       	std	Y+4, r25	; 0x04
    4bd0:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    4bd2:	80 91 a5 07 	lds	r24, 0x07A5
    4bd6:	90 91 a6 07 	lds	r25, 0x07A6
    4bda:	90 93 a4 07 	sts	0x07A4, r25
    4bde:	80 93 a3 07 	sts	0x07A3, r24
			pxOverflowDelayedTaskList = pxTemp;
    4be2:	8b 81       	ldd	r24, Y+3	; 0x03
    4be4:	9c 81       	ldd	r25, Y+4	; 0x04
    4be6:	90 93 a6 07 	sts	0x07A6, r25
    4bea:	80 93 a5 07 	sts	0x07A5, r24
			xNumOfOverflows++;
    4bee:	80 91 62 07 	lds	r24, 0x0762
    4bf2:	8f 5f       	subi	r24, 0xFF	; 255
    4bf4:	80 93 62 07 	sts	0x0762, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    4bf8:	e0 91 a3 07 	lds	r30, 0x07A3
    4bfc:	f0 91 a4 07 	lds	r31, 0x07A4
    4c00:	80 81       	ld	r24, Z
    4c02:	88 23       	and	r24, r24
    4c04:	39 f4       	brne	.+14     	; 0x4c14 <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    4c06:	8f ef       	ldi	r24, 0xFF	; 255
    4c08:	9f ef       	ldi	r25, 0xFF	; 255
    4c0a:	90 93 28 01 	sts	0x0128, r25
    4c0e:	80 93 27 01 	sts	0x0127, r24
    4c12:	13 c0       	rjmp	.+38     	; 0x4c3a <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    4c14:	e0 91 a3 07 	lds	r30, 0x07A3
    4c18:	f0 91 a4 07 	lds	r31, 0x07A4
    4c1c:	05 80       	ldd	r0, Z+5	; 0x05
    4c1e:	f6 81       	ldd	r31, Z+6	; 0x06
    4c20:	e0 2d       	mov	r30, r0
    4c22:	86 81       	ldd	r24, Z+6	; 0x06
    4c24:	97 81       	ldd	r25, Z+7	; 0x07
    4c26:	9e 83       	std	Y+6, r25	; 0x06
    4c28:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    4c2a:	ed 81       	ldd	r30, Y+5	; 0x05
    4c2c:	fe 81       	ldd	r31, Y+6	; 0x06
    4c2e:	82 81       	ldd	r24, Z+2	; 0x02
    4c30:	93 81       	ldd	r25, Z+3	; 0x03
    4c32:	90 93 28 01 	sts	0x0128, r25
    4c36:	80 93 27 01 	sts	0x0127, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    4c3a:	20 91 5a 07 	lds	r18, 0x075A
    4c3e:	30 91 5b 07 	lds	r19, 0x075B
    4c42:	80 91 27 01 	lds	r24, 0x0127
    4c46:	90 91 28 01 	lds	r25, 0x0128
    4c4a:	28 17       	cp	r18, r24
    4c4c:	39 07       	cpc	r19, r25
    4c4e:	08 f4       	brcc	.+2      	; 0x4c52 <vTaskIncrementTick+0xc2>
    4c50:	6b c0       	rjmp	.+214    	; 0x4d28 <vTaskIncrementTick+0x198>
    4c52:	e0 91 a3 07 	lds	r30, 0x07A3
    4c56:	f0 91 a4 07 	lds	r31, 0x07A4
    4c5a:	80 81       	ld	r24, Z
    4c5c:	88 23       	and	r24, r24
    4c5e:	39 f4       	brne	.+14     	; 0x4c6e <vTaskIncrementTick+0xde>
    4c60:	8f ef       	ldi	r24, 0xFF	; 255
    4c62:	9f ef       	ldi	r25, 0xFF	; 255
    4c64:	90 93 28 01 	sts	0x0128, r25
    4c68:	80 93 27 01 	sts	0x0127, r24
    4c6c:	5d c0       	rjmp	.+186    	; 0x4d28 <vTaskIncrementTick+0x198>
    4c6e:	e0 91 a3 07 	lds	r30, 0x07A3
    4c72:	f0 91 a4 07 	lds	r31, 0x07A4
    4c76:	05 80       	ldd	r0, Z+5	; 0x05
    4c78:	f6 81       	ldd	r31, Z+6	; 0x06
    4c7a:	e0 2d       	mov	r30, r0
    4c7c:	86 81       	ldd	r24, Z+6	; 0x06
    4c7e:	97 81       	ldd	r25, Z+7	; 0x07
    4c80:	9e 83       	std	Y+6, r25	; 0x06
    4c82:	8d 83       	std	Y+5, r24	; 0x05
    4c84:	ed 81       	ldd	r30, Y+5	; 0x05
    4c86:	fe 81       	ldd	r31, Y+6	; 0x06
    4c88:	82 81       	ldd	r24, Z+2	; 0x02
    4c8a:	93 81       	ldd	r25, Z+3	; 0x03
    4c8c:	9a 83       	std	Y+2, r25	; 0x02
    4c8e:	89 83       	std	Y+1, r24	; 0x01
    4c90:	20 91 5a 07 	lds	r18, 0x075A
    4c94:	30 91 5b 07 	lds	r19, 0x075B
    4c98:	89 81       	ldd	r24, Y+1	; 0x01
    4c9a:	9a 81       	ldd	r25, Y+2	; 0x02
    4c9c:	28 17       	cp	r18, r24
    4c9e:	39 07       	cpc	r19, r25
    4ca0:	38 f4       	brcc	.+14     	; 0x4cb0 <vTaskIncrementTick+0x120>
    4ca2:	89 81       	ldd	r24, Y+1	; 0x01
    4ca4:	9a 81       	ldd	r25, Y+2	; 0x02
    4ca6:	90 93 28 01 	sts	0x0128, r25
    4caa:	80 93 27 01 	sts	0x0127, r24
    4cae:	3c c0       	rjmp	.+120    	; 0x4d28 <vTaskIncrementTick+0x198>
    4cb0:	8d 81       	ldd	r24, Y+5	; 0x05
    4cb2:	9e 81       	ldd	r25, Y+6	; 0x06
    4cb4:	02 96       	adiw	r24, 0x02	; 2
    4cb6:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
    4cba:	ed 81       	ldd	r30, Y+5	; 0x05
    4cbc:	fe 81       	ldd	r31, Y+6	; 0x06
    4cbe:	84 89       	ldd	r24, Z+20	; 0x14
    4cc0:	95 89       	ldd	r25, Z+21	; 0x15
    4cc2:	00 97       	sbiw	r24, 0x00	; 0
    4cc4:	29 f0       	breq	.+10     	; 0x4cd0 <vTaskIncrementTick+0x140>
    4cc6:	8d 81       	ldd	r24, Y+5	; 0x05
    4cc8:	9e 81       	ldd	r25, Y+6	; 0x06
    4cca:	0c 96       	adiw	r24, 0x0c	; 12
    4ccc:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
    4cd0:	ed 81       	ldd	r30, Y+5	; 0x05
    4cd2:	fe 81       	ldd	r31, Y+6	; 0x06
    4cd4:	96 89       	ldd	r25, Z+22	; 0x16
    4cd6:	80 91 5d 07 	lds	r24, 0x075D
    4cda:	89 17       	cp	r24, r25
    4cdc:	28 f4       	brcc	.+10     	; 0x4ce8 <vTaskIncrementTick+0x158>
    4cde:	ed 81       	ldd	r30, Y+5	; 0x05
    4ce0:	fe 81       	ldd	r31, Y+6	; 0x06
    4ce2:	86 89       	ldd	r24, Z+22	; 0x16
    4ce4:	80 93 5d 07 	sts	0x075D, r24
    4ce8:	ed 81       	ldd	r30, Y+5	; 0x05
    4cea:	fe 81       	ldd	r31, Y+6	; 0x06
    4cec:	86 89       	ldd	r24, Z+22	; 0x16
    4cee:	28 2f       	mov	r18, r24
    4cf0:	30 e0       	ldi	r19, 0x00	; 0
    4cf2:	c9 01       	movw	r24, r18
    4cf4:	88 0f       	add	r24, r24
    4cf6:	99 1f       	adc	r25, r25
    4cf8:	88 0f       	add	r24, r24
    4cfa:	99 1f       	adc	r25, r25
    4cfc:	88 0f       	add	r24, r24
    4cfe:	99 1f       	adc	r25, r25
    4d00:	82 0f       	add	r24, r18
    4d02:	93 1f       	adc	r25, r19
    4d04:	ac 01       	movw	r20, r24
    4d06:	4c 59       	subi	r20, 0x9C	; 156
    4d08:	58 4f       	sbci	r21, 0xF8	; 248
    4d0a:	8d 81       	ldd	r24, Y+5	; 0x05
    4d0c:	9e 81       	ldd	r25, Y+6	; 0x06
    4d0e:	9c 01       	movw	r18, r24
    4d10:	2e 5f       	subi	r18, 0xFE	; 254
    4d12:	3f 4f       	sbci	r19, 0xFF	; 255
    4d14:	ca 01       	movw	r24, r20
    4d16:	b9 01       	movw	r22, r18
    4d18:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>
    4d1c:	9a cf       	rjmp	.-204    	; 0x4c52 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    4d1e:	80 91 60 07 	lds	r24, 0x0760
    4d22:	8f 5f       	subi	r24, 0xFF	; 255
    4d24:	80 93 60 07 	sts	0x0760, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    4d28:	26 96       	adiw	r28, 0x06	; 6
    4d2a:	0f b6       	in	r0, 0x3f	; 63
    4d2c:	f8 94       	cli
    4d2e:	de bf       	out	0x3e, r29	; 62
    4d30:	0f be       	out	0x3f, r0	; 63
    4d32:	cd bf       	out	0x3d, r28	; 61
    4d34:	cf 91       	pop	r28
    4d36:	df 91       	pop	r29
    4d38:	08 95       	ret

00004d3a <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    4d3a:	df 93       	push	r29
    4d3c:	cf 93       	push	r28
    4d3e:	00 d0       	rcall	.+0      	; 0x4d40 <vTaskSwitchContext+0x6>
    4d40:	cd b7       	in	r28, 0x3d	; 61
    4d42:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    4d44:	80 91 5f 07 	lds	r24, 0x075F
    4d48:	88 23       	and	r24, r24
    4d4a:	49 f0       	breq	.+18     	; 0x4d5e <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    4d4c:	81 e0       	ldi	r24, 0x01	; 1
    4d4e:	80 93 61 07 	sts	0x0761, r24
    4d52:	54 c0       	rjmp	.+168    	; 0x4dfc <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    4d54:	80 91 5d 07 	lds	r24, 0x075D
    4d58:	81 50       	subi	r24, 0x01	; 1
    4d5a:	80 93 5d 07 	sts	0x075D, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    4d5e:	80 91 5d 07 	lds	r24, 0x075D
    4d62:	28 2f       	mov	r18, r24
    4d64:	30 e0       	ldi	r19, 0x00	; 0
    4d66:	c9 01       	movw	r24, r18
    4d68:	88 0f       	add	r24, r24
    4d6a:	99 1f       	adc	r25, r25
    4d6c:	88 0f       	add	r24, r24
    4d6e:	99 1f       	adc	r25, r25
    4d70:	88 0f       	add	r24, r24
    4d72:	99 1f       	adc	r25, r25
    4d74:	82 0f       	add	r24, r18
    4d76:	93 1f       	adc	r25, r19
    4d78:	fc 01       	movw	r30, r24
    4d7a:	ec 59       	subi	r30, 0x9C	; 156
    4d7c:	f8 4f       	sbci	r31, 0xF8	; 248
    4d7e:	80 81       	ld	r24, Z
    4d80:	88 23       	and	r24, r24
    4d82:	41 f3       	breq	.-48     	; 0x4d54 <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    4d84:	80 91 5d 07 	lds	r24, 0x075D
    4d88:	28 2f       	mov	r18, r24
    4d8a:	30 e0       	ldi	r19, 0x00	; 0
    4d8c:	c9 01       	movw	r24, r18
    4d8e:	88 0f       	add	r24, r24
    4d90:	99 1f       	adc	r25, r25
    4d92:	88 0f       	add	r24, r24
    4d94:	99 1f       	adc	r25, r25
    4d96:	88 0f       	add	r24, r24
    4d98:	99 1f       	adc	r25, r25
    4d9a:	82 0f       	add	r24, r18
    4d9c:	93 1f       	adc	r25, r19
    4d9e:	8c 59       	subi	r24, 0x9C	; 156
    4da0:	98 4f       	sbci	r25, 0xF8	; 248
    4da2:	9a 83       	std	Y+2, r25	; 0x02
    4da4:	89 83       	std	Y+1, r24	; 0x01
    4da6:	e9 81       	ldd	r30, Y+1	; 0x01
    4da8:	fa 81       	ldd	r31, Y+2	; 0x02
    4daa:	01 80       	ldd	r0, Z+1	; 0x01
    4dac:	f2 81       	ldd	r31, Z+2	; 0x02
    4dae:	e0 2d       	mov	r30, r0
    4db0:	82 81       	ldd	r24, Z+2	; 0x02
    4db2:	93 81       	ldd	r25, Z+3	; 0x03
    4db4:	e9 81       	ldd	r30, Y+1	; 0x01
    4db6:	fa 81       	ldd	r31, Y+2	; 0x02
    4db8:	92 83       	std	Z+2, r25	; 0x02
    4dba:	81 83       	std	Z+1, r24	; 0x01
    4dbc:	e9 81       	ldd	r30, Y+1	; 0x01
    4dbe:	fa 81       	ldd	r31, Y+2	; 0x02
    4dc0:	21 81       	ldd	r18, Z+1	; 0x01
    4dc2:	32 81       	ldd	r19, Z+2	; 0x02
    4dc4:	89 81       	ldd	r24, Y+1	; 0x01
    4dc6:	9a 81       	ldd	r25, Y+2	; 0x02
    4dc8:	03 96       	adiw	r24, 0x03	; 3
    4dca:	28 17       	cp	r18, r24
    4dcc:	39 07       	cpc	r19, r25
    4dce:	59 f4       	brne	.+22     	; 0x4de6 <vTaskSwitchContext+0xac>
    4dd0:	e9 81       	ldd	r30, Y+1	; 0x01
    4dd2:	fa 81       	ldd	r31, Y+2	; 0x02
    4dd4:	01 80       	ldd	r0, Z+1	; 0x01
    4dd6:	f2 81       	ldd	r31, Z+2	; 0x02
    4dd8:	e0 2d       	mov	r30, r0
    4dda:	82 81       	ldd	r24, Z+2	; 0x02
    4ddc:	93 81       	ldd	r25, Z+3	; 0x03
    4dde:	e9 81       	ldd	r30, Y+1	; 0x01
    4de0:	fa 81       	ldd	r31, Y+2	; 0x02
    4de2:	92 83       	std	Z+2, r25	; 0x02
    4de4:	81 83       	std	Z+1, r24	; 0x01
    4de6:	e9 81       	ldd	r30, Y+1	; 0x01
    4de8:	fa 81       	ldd	r31, Y+2	; 0x02
    4dea:	01 80       	ldd	r0, Z+1	; 0x01
    4dec:	f2 81       	ldd	r31, Z+2	; 0x02
    4dee:	e0 2d       	mov	r30, r0
    4df0:	86 81       	ldd	r24, Z+6	; 0x06
    4df2:	97 81       	ldd	r25, Z+7	; 0x07
    4df4:	90 93 57 07 	sts	0x0757, r25
    4df8:	80 93 56 07 	sts	0x0756, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    4dfc:	0f 90       	pop	r0
    4dfe:	0f 90       	pop	r0
    4e00:	cf 91       	pop	r28
    4e02:	df 91       	pop	r29
    4e04:	08 95       	ret

00004e06 <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    4e06:	df 93       	push	r29
    4e08:	cf 93       	push	r28
    4e0a:	00 d0       	rcall	.+0      	; 0x4e0c <vTaskPlaceOnEventList+0x6>
    4e0c:	00 d0       	rcall	.+0      	; 0x4e0e <vTaskPlaceOnEventList+0x8>
    4e0e:	00 d0       	rcall	.+0      	; 0x4e10 <vTaskPlaceOnEventList+0xa>
    4e10:	cd b7       	in	r28, 0x3d	; 61
    4e12:	de b7       	in	r29, 0x3e	; 62
    4e14:	9c 83       	std	Y+4, r25	; 0x04
    4e16:	8b 83       	std	Y+3, r24	; 0x03
    4e18:	7e 83       	std	Y+6, r23	; 0x06
    4e1a:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    4e1c:	4b 81       	ldd	r20, Y+3	; 0x03
    4e1e:	5c 81       	ldd	r21, Y+4	; 0x04
    4e20:	80 91 56 07 	lds	r24, 0x0756
    4e24:	90 91 57 07 	lds	r25, 0x0757
    4e28:	9c 01       	movw	r18, r24
    4e2a:	24 5f       	subi	r18, 0xF4	; 244
    4e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4e2e:	ca 01       	movw	r24, r20
    4e30:	b9 01       	movw	r22, r18
    4e32:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    4e36:	80 91 56 07 	lds	r24, 0x0756
    4e3a:	90 91 57 07 	lds	r25, 0x0757
    4e3e:	02 96       	adiw	r24, 0x02	; 2
    4e40:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
	}
	#else
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    4e44:	20 91 5a 07 	lds	r18, 0x075A
    4e48:	30 91 5b 07 	lds	r19, 0x075B
    4e4c:	8d 81       	ldd	r24, Y+5	; 0x05
    4e4e:	9e 81       	ldd	r25, Y+6	; 0x06
    4e50:	82 0f       	add	r24, r18
    4e52:	93 1f       	adc	r25, r19
    4e54:	9a 83       	std	Y+2, r25	; 0x02
    4e56:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    4e58:	89 81       	ldd	r24, Y+1	; 0x01
    4e5a:	9a 81       	ldd	r25, Y+2	; 0x02
    4e5c:	0e 94 fd 28 	call	0x51fa	; 0x51fa <prvAddCurrentTaskToDelayedList>
	}
	#endif
}
    4e60:	26 96       	adiw	r28, 0x06	; 6
    4e62:	0f b6       	in	r0, 0x3f	; 63
    4e64:	f8 94       	cli
    4e66:	de bf       	out	0x3e, r29	; 62
    4e68:	0f be       	out	0x3f, r0	; 63
    4e6a:	cd bf       	out	0x3d, r28	; 61
    4e6c:	cf 91       	pop	r28
    4e6e:	df 91       	pop	r29
    4e70:	08 95       	ret

00004e72 <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    4e72:	df 93       	push	r29
    4e74:	cf 93       	push	r28
    4e76:	00 d0       	rcall	.+0      	; 0x4e78 <xTaskRemoveFromEventList+0x6>
    4e78:	00 d0       	rcall	.+0      	; 0x4e7a <xTaskRemoveFromEventList+0x8>
    4e7a:	0f 92       	push	r0
    4e7c:	cd b7       	in	r28, 0x3d	; 61
    4e7e:	de b7       	in	r29, 0x3e	; 62
    4e80:	9d 83       	std	Y+5, r25	; 0x05
    4e82:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    4e84:	ec 81       	ldd	r30, Y+4	; 0x04
    4e86:	fd 81       	ldd	r31, Y+5	; 0x05
    4e88:	05 80       	ldd	r0, Z+5	; 0x05
    4e8a:	f6 81       	ldd	r31, Z+6	; 0x06
    4e8c:	e0 2d       	mov	r30, r0
    4e8e:	86 81       	ldd	r24, Z+6	; 0x06
    4e90:	97 81       	ldd	r25, Z+7	; 0x07
    4e92:	9b 83       	std	Y+3, r25	; 0x03
    4e94:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    4e96:	8a 81       	ldd	r24, Y+2	; 0x02
    4e98:	9b 81       	ldd	r25, Y+3	; 0x03
    4e9a:	0c 96       	adiw	r24, 0x0c	; 12
    4e9c:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    4ea0:	80 91 5f 07 	lds	r24, 0x075F
    4ea4:	88 23       	and	r24, r24
    4ea6:	61 f5       	brne	.+88     	; 0x4f00 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    4ea8:	8a 81       	ldd	r24, Y+2	; 0x02
    4eaa:	9b 81       	ldd	r25, Y+3	; 0x03
    4eac:	02 96       	adiw	r24, 0x02	; 2
    4eae:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    4eb2:	ea 81       	ldd	r30, Y+2	; 0x02
    4eb4:	fb 81       	ldd	r31, Y+3	; 0x03
    4eb6:	96 89       	ldd	r25, Z+22	; 0x16
    4eb8:	80 91 5d 07 	lds	r24, 0x075D
    4ebc:	89 17       	cp	r24, r25
    4ebe:	28 f4       	brcc	.+10     	; 0x4eca <xTaskRemoveFromEventList+0x58>
    4ec0:	ea 81       	ldd	r30, Y+2	; 0x02
    4ec2:	fb 81       	ldd	r31, Y+3	; 0x03
    4ec4:	86 89       	ldd	r24, Z+22	; 0x16
    4ec6:	80 93 5d 07 	sts	0x075D, r24
    4eca:	ea 81       	ldd	r30, Y+2	; 0x02
    4ecc:	fb 81       	ldd	r31, Y+3	; 0x03
    4ece:	86 89       	ldd	r24, Z+22	; 0x16
    4ed0:	28 2f       	mov	r18, r24
    4ed2:	30 e0       	ldi	r19, 0x00	; 0
    4ed4:	c9 01       	movw	r24, r18
    4ed6:	88 0f       	add	r24, r24
    4ed8:	99 1f       	adc	r25, r25
    4eda:	88 0f       	add	r24, r24
    4edc:	99 1f       	adc	r25, r25
    4ede:	88 0f       	add	r24, r24
    4ee0:	99 1f       	adc	r25, r25
    4ee2:	82 0f       	add	r24, r18
    4ee4:	93 1f       	adc	r25, r19
    4ee6:	ac 01       	movw	r20, r24
    4ee8:	4c 59       	subi	r20, 0x9C	; 156
    4eea:	58 4f       	sbci	r21, 0xF8	; 248
    4eec:	8a 81       	ldd	r24, Y+2	; 0x02
    4eee:	9b 81       	ldd	r25, Y+3	; 0x03
    4ef0:	9c 01       	movw	r18, r24
    4ef2:	2e 5f       	subi	r18, 0xFE	; 254
    4ef4:	3f 4f       	sbci	r19, 0xFF	; 255
    4ef6:	ca 01       	movw	r24, r20
    4ef8:	b9 01       	movw	r22, r18
    4efa:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>
    4efe:	0a c0       	rjmp	.+20     	; 0x4f14 <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    4f00:	8a 81       	ldd	r24, Y+2	; 0x02
    4f02:	9b 81       	ldd	r25, Y+3	; 0x03
    4f04:	9c 01       	movw	r18, r24
    4f06:	24 5f       	subi	r18, 0xF4	; 244
    4f08:	3f 4f       	sbci	r19, 0xFF	; 255
    4f0a:	87 ea       	ldi	r24, 0xA7	; 167
    4f0c:	97 e0       	ldi	r25, 0x07	; 7
    4f0e:	b9 01       	movw	r22, r18
    4f10:	0e 94 82 17 	call	0x2f04	; 0x2f04 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    4f14:	ea 81       	ldd	r30, Y+2	; 0x02
    4f16:	fb 81       	ldd	r31, Y+3	; 0x03
    4f18:	96 89       	ldd	r25, Z+22	; 0x16
    4f1a:	e0 91 56 07 	lds	r30, 0x0756
    4f1e:	f0 91 57 07 	lds	r31, 0x0757
    4f22:	86 89       	ldd	r24, Z+22	; 0x16
    4f24:	98 17       	cp	r25, r24
    4f26:	18 f0       	brcs	.+6      	; 0x4f2e <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    4f28:	81 e0       	ldi	r24, 0x01	; 1
    4f2a:	89 83       	std	Y+1, r24	; 0x01
    4f2c:	01 c0       	rjmp	.+2      	; 0x4f30 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    4f2e:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
}
    4f32:	0f 90       	pop	r0
    4f34:	0f 90       	pop	r0
    4f36:	0f 90       	pop	r0
    4f38:	0f 90       	pop	r0
    4f3a:	0f 90       	pop	r0
    4f3c:	cf 91       	pop	r28
    4f3e:	df 91       	pop	r29
    4f40:	08 95       	ret

00004f42 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    4f42:	df 93       	push	r29
    4f44:	cf 93       	push	r28
    4f46:	00 d0       	rcall	.+0      	; 0x4f48 <vTaskSetTimeOutState+0x6>
    4f48:	cd b7       	in	r28, 0x3d	; 61
    4f4a:	de b7       	in	r29, 0x3e	; 62
    4f4c:	9a 83       	std	Y+2, r25	; 0x02
    4f4e:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    4f50:	80 91 62 07 	lds	r24, 0x0762
    4f54:	e9 81       	ldd	r30, Y+1	; 0x01
    4f56:	fa 81       	ldd	r31, Y+2	; 0x02
    4f58:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    4f5a:	80 91 5a 07 	lds	r24, 0x075A
    4f5e:	90 91 5b 07 	lds	r25, 0x075B
    4f62:	e9 81       	ldd	r30, Y+1	; 0x01
    4f64:	fa 81       	ldd	r31, Y+2	; 0x02
    4f66:	92 83       	std	Z+2, r25	; 0x02
    4f68:	81 83       	std	Z+1, r24	; 0x01
}
    4f6a:	0f 90       	pop	r0
    4f6c:	0f 90       	pop	r0
    4f6e:	cf 91       	pop	r28
    4f70:	df 91       	pop	r29
    4f72:	08 95       	ret

00004f74 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    4f74:	df 93       	push	r29
    4f76:	cf 93       	push	r28
    4f78:	00 d0       	rcall	.+0      	; 0x4f7a <xTaskCheckForTimeOut+0x6>
    4f7a:	00 d0       	rcall	.+0      	; 0x4f7c <xTaskCheckForTimeOut+0x8>
    4f7c:	0f 92       	push	r0
    4f7e:	cd b7       	in	r28, 0x3d	; 61
    4f80:	de b7       	in	r29, 0x3e	; 62
    4f82:	9b 83       	std	Y+3, r25	; 0x03
    4f84:	8a 83       	std	Y+2, r24	; 0x02
    4f86:	7d 83       	std	Y+5, r23	; 0x05
    4f88:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    4f8a:	0f b6       	in	r0, 0x3f	; 63
    4f8c:	f8 94       	cli
    4f8e:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    4f90:	ea 81       	ldd	r30, Y+2	; 0x02
    4f92:	fb 81       	ldd	r31, Y+3	; 0x03
    4f94:	90 81       	ld	r25, Z
    4f96:	80 91 62 07 	lds	r24, 0x0762
    4f9a:	98 17       	cp	r25, r24
    4f9c:	71 f0       	breq	.+28     	; 0x4fba <xTaskCheckForTimeOut+0x46>
    4f9e:	ea 81       	ldd	r30, Y+2	; 0x02
    4fa0:	fb 81       	ldd	r31, Y+3	; 0x03
    4fa2:	21 81       	ldd	r18, Z+1	; 0x01
    4fa4:	32 81       	ldd	r19, Z+2	; 0x02
    4fa6:	80 91 5a 07 	lds	r24, 0x075A
    4faa:	90 91 5b 07 	lds	r25, 0x075B
    4fae:	82 17       	cp	r24, r18
    4fb0:	93 07       	cpc	r25, r19
    4fb2:	18 f0       	brcs	.+6      	; 0x4fba <xTaskCheckForTimeOut+0x46>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    4fb4:	81 e0       	ldi	r24, 0x01	; 1
    4fb6:	89 83       	std	Y+1, r24	; 0x01
    4fb8:	2f c0       	rjmp	.+94     	; 0x5018 <xTaskCheckForTimeOut+0xa4>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    4fba:	20 91 5a 07 	lds	r18, 0x075A
    4fbe:	30 91 5b 07 	lds	r19, 0x075B
    4fc2:	ea 81       	ldd	r30, Y+2	; 0x02
    4fc4:	fb 81       	ldd	r31, Y+3	; 0x03
    4fc6:	81 81       	ldd	r24, Z+1	; 0x01
    4fc8:	92 81       	ldd	r25, Z+2	; 0x02
    4fca:	28 1b       	sub	r18, r24
    4fcc:	39 0b       	sbc	r19, r25
    4fce:	ec 81       	ldd	r30, Y+4	; 0x04
    4fd0:	fd 81       	ldd	r31, Y+5	; 0x05
    4fd2:	80 81       	ld	r24, Z
    4fd4:	91 81       	ldd	r25, Z+1	; 0x01
    4fd6:	28 17       	cp	r18, r24
    4fd8:	39 07       	cpc	r19, r25
    4fda:	e0 f4       	brcc	.+56     	; 0x5014 <xTaskCheckForTimeOut+0xa0>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    4fdc:	ec 81       	ldd	r30, Y+4	; 0x04
    4fde:	fd 81       	ldd	r31, Y+5	; 0x05
    4fe0:	40 81       	ld	r20, Z
    4fe2:	51 81       	ldd	r21, Z+1	; 0x01
    4fe4:	ea 81       	ldd	r30, Y+2	; 0x02
    4fe6:	fb 81       	ldd	r31, Y+3	; 0x03
    4fe8:	21 81       	ldd	r18, Z+1	; 0x01
    4fea:	32 81       	ldd	r19, Z+2	; 0x02
    4fec:	80 91 5a 07 	lds	r24, 0x075A
    4ff0:	90 91 5b 07 	lds	r25, 0x075B
    4ff4:	b9 01       	movw	r22, r18
    4ff6:	68 1b       	sub	r22, r24
    4ff8:	79 0b       	sbc	r23, r25
    4ffa:	cb 01       	movw	r24, r22
    4ffc:	84 0f       	add	r24, r20
    4ffe:	95 1f       	adc	r25, r21
    5000:	ec 81       	ldd	r30, Y+4	; 0x04
    5002:	fd 81       	ldd	r31, Y+5	; 0x05
    5004:	91 83       	std	Z+1, r25	; 0x01
    5006:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    5008:	8a 81       	ldd	r24, Y+2	; 0x02
    500a:	9b 81       	ldd	r25, Y+3	; 0x03
    500c:	0e 94 a1 27 	call	0x4f42	; 0x4f42 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    5010:	19 82       	std	Y+1, r1	; 0x01
    5012:	02 c0       	rjmp	.+4      	; 0x5018 <xTaskCheckForTimeOut+0xa4>
		}
		else
		{
			xReturn = pdTRUE;
    5014:	81 e0       	ldi	r24, 0x01	; 1
    5016:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    5018:	0f 90       	pop	r0
    501a:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    501c:	89 81       	ldd	r24, Y+1	; 0x01
}
    501e:	0f 90       	pop	r0
    5020:	0f 90       	pop	r0
    5022:	0f 90       	pop	r0
    5024:	0f 90       	pop	r0
    5026:	0f 90       	pop	r0
    5028:	cf 91       	pop	r28
    502a:	df 91       	pop	r29
    502c:	08 95       	ret

0000502e <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    502e:	df 93       	push	r29
    5030:	cf 93       	push	r28
    5032:	cd b7       	in	r28, 0x3d	; 61
    5034:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    5036:	81 e0       	ldi	r24, 0x01	; 1
    5038:	80 93 61 07 	sts	0x0761, r24
}
    503c:	cf 91       	pop	r28
    503e:	df 91       	pop	r29
    5040:	08 95       	ret

00005042 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    5042:	df 93       	push	r29
    5044:	cf 93       	push	r28
    5046:	00 d0       	rcall	.+0      	; 0x5048 <prvIdleTask+0x6>
    5048:	cd b7       	in	r28, 0x3d	; 61
    504a:	de b7       	in	r29, 0x3e	; 62
    504c:	9a 83       	std	Y+2, r25	; 0x02
    504e:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    5050:	0e 94 bf 28 	call	0x517e	; 0x517e <prvCheckTasksWaitingTermination>
    5054:	fd cf       	rjmp	.-6      	; 0x5050 <prvIdleTask+0xe>

00005056 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    5056:	0f 93       	push	r16
    5058:	1f 93       	push	r17
    505a:	df 93       	push	r29
    505c:	cf 93       	push	r28
    505e:	cd b7       	in	r28, 0x3d	; 61
    5060:	de b7       	in	r29, 0x3e	; 62
    5062:	29 97       	sbiw	r28, 0x09	; 9
    5064:	0f b6       	in	r0, 0x3f	; 63
    5066:	f8 94       	cli
    5068:	de bf       	out	0x3e, r29	; 62
    506a:	0f be       	out	0x3f, r0	; 63
    506c:	cd bf       	out	0x3d, r28	; 61
    506e:	9a 83       	std	Y+2, r25	; 0x02
    5070:	89 83       	std	Y+1, r24	; 0x01
    5072:	7c 83       	std	Y+4, r23	; 0x04
    5074:	6b 83       	std	Y+3, r22	; 0x03
    5076:	4d 83       	std	Y+5, r20	; 0x05
    5078:	3f 83       	std	Y+7, r19	; 0x07
    507a:	2e 83       	std	Y+6, r18	; 0x06
    507c:	19 87       	std	Y+9, r17	; 0x09
    507e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    5080:	89 81       	ldd	r24, Y+1	; 0x01
    5082:	9a 81       	ldd	r25, Y+2	; 0x02
    5084:	49 96       	adiw	r24, 0x19	; 25
    5086:	2b 81       	ldd	r18, Y+3	; 0x03
    5088:	3c 81       	ldd	r19, Y+4	; 0x04
    508a:	b9 01       	movw	r22, r18
    508c:	48 e0       	ldi	r20, 0x08	; 8
    508e:	50 e0       	ldi	r21, 0x00	; 0
    5090:	0e 94 15 2a 	call	0x542a	; 0x542a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    5094:	e9 81       	ldd	r30, Y+1	; 0x01
    5096:	fa 81       	ldd	r31, Y+2	; 0x02
    5098:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    509a:	8d 81       	ldd	r24, Y+5	; 0x05
    509c:	85 30       	cpi	r24, 0x05	; 5
    509e:	10 f0       	brcs	.+4      	; 0x50a4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    50a0:	84 e0       	ldi	r24, 0x04	; 4
    50a2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    50a4:	e9 81       	ldd	r30, Y+1	; 0x01
    50a6:	fa 81       	ldd	r31, Y+2	; 0x02
    50a8:	8d 81       	ldd	r24, Y+5	; 0x05
    50aa:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    50ac:	89 81       	ldd	r24, Y+1	; 0x01
    50ae:	9a 81       	ldd	r25, Y+2	; 0x02
    50b0:	02 96       	adiw	r24, 0x02	; 2
    50b2:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    50b6:	89 81       	ldd	r24, Y+1	; 0x01
    50b8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ba:	0c 96       	adiw	r24, 0x0c	; 12
    50bc:	0e 94 72 17 	call	0x2ee4	; 0x2ee4 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    50c0:	e9 81       	ldd	r30, Y+1	; 0x01
    50c2:	fa 81       	ldd	r31, Y+2	; 0x02
    50c4:	89 81       	ldd	r24, Y+1	; 0x01
    50c6:	9a 81       	ldd	r25, Y+2	; 0x02
    50c8:	91 87       	std	Z+9, r25	; 0x09
    50ca:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    50cc:	8d 81       	ldd	r24, Y+5	; 0x05
    50ce:	28 2f       	mov	r18, r24
    50d0:	30 e0       	ldi	r19, 0x00	; 0
    50d2:	85 e0       	ldi	r24, 0x05	; 5
    50d4:	90 e0       	ldi	r25, 0x00	; 0
    50d6:	82 1b       	sub	r24, r18
    50d8:	93 0b       	sbc	r25, r19
    50da:	e9 81       	ldd	r30, Y+1	; 0x01
    50dc:	fa 81       	ldd	r31, Y+2	; 0x02
    50de:	95 87       	std	Z+13, r25	; 0x0d
    50e0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    50e2:	e9 81       	ldd	r30, Y+1	; 0x01
    50e4:	fa 81       	ldd	r31, Y+2	; 0x02
    50e6:	89 81       	ldd	r24, Y+1	; 0x01
    50e8:	9a 81       	ldd	r25, Y+2	; 0x02
    50ea:	93 8b       	std	Z+19, r25	; 0x13
    50ec:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    50ee:	29 96       	adiw	r28, 0x09	; 9
    50f0:	0f b6       	in	r0, 0x3f	; 63
    50f2:	f8 94       	cli
    50f4:	de bf       	out	0x3e, r29	; 62
    50f6:	0f be       	out	0x3f, r0	; 63
    50f8:	cd bf       	out	0x3d, r28	; 61
    50fa:	cf 91       	pop	r28
    50fc:	df 91       	pop	r29
    50fe:	1f 91       	pop	r17
    5100:	0f 91       	pop	r16
    5102:	08 95       	ret

00005104 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    5104:	df 93       	push	r29
    5106:	cf 93       	push	r28
    5108:	0f 92       	push	r0
    510a:	cd b7       	in	r28, 0x3d	; 61
    510c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    510e:	19 82       	std	Y+1, r1	; 0x01
    5110:	13 c0       	rjmp	.+38     	; 0x5138 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    5112:	89 81       	ldd	r24, Y+1	; 0x01
    5114:	28 2f       	mov	r18, r24
    5116:	30 e0       	ldi	r19, 0x00	; 0
    5118:	c9 01       	movw	r24, r18
    511a:	88 0f       	add	r24, r24
    511c:	99 1f       	adc	r25, r25
    511e:	88 0f       	add	r24, r24
    5120:	99 1f       	adc	r25, r25
    5122:	88 0f       	add	r24, r24
    5124:	99 1f       	adc	r25, r25
    5126:	82 0f       	add	r24, r18
    5128:	93 1f       	adc	r25, r19
    512a:	8c 59       	subi	r24, 0x9C	; 156
    512c:	98 4f       	sbci	r25, 0xF8	; 248
    512e:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    5132:	89 81       	ldd	r24, Y+1	; 0x01
    5134:	8f 5f       	subi	r24, 0xFF	; 255
    5136:	89 83       	std	Y+1, r24	; 0x01
    5138:	89 81       	ldd	r24, Y+1	; 0x01
    513a:	85 30       	cpi	r24, 0x05	; 5
    513c:	50 f3       	brcs	.-44     	; 0x5112 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    513e:	81 e9       	ldi	r24, 0x91	; 145
    5140:	97 e0       	ldi	r25, 0x07	; 7
    5142:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    5146:	8a e9       	ldi	r24, 0x9A	; 154
    5148:	97 e0       	ldi	r25, 0x07	; 7
    514a:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    514e:	87 ea       	ldi	r24, 0xA7	; 167
    5150:	97 e0       	ldi	r25, 0x07	; 7
    5152:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
    5156:	80 eb       	ldi	r24, 0xB0	; 176
    5158:	97 e0       	ldi	r25, 0x07	; 7
    515a:	0e 94 48 17 	call	0x2e90	; 0x2e90 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    515e:	81 e9       	ldi	r24, 0x91	; 145
    5160:	97 e0       	ldi	r25, 0x07	; 7
    5162:	90 93 a4 07 	sts	0x07A4, r25
    5166:	80 93 a3 07 	sts	0x07A3, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    516a:	8a e9       	ldi	r24, 0x9A	; 154
    516c:	97 e0       	ldi	r25, 0x07	; 7
    516e:	90 93 a6 07 	sts	0x07A6, r25
    5172:	80 93 a5 07 	sts	0x07A5, r24
}
    5176:	0f 90       	pop	r0
    5178:	cf 91       	pop	r28
    517a:	df 91       	pop	r29
    517c:	08 95       	ret

0000517e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    517e:	df 93       	push	r29
    5180:	cf 93       	push	r28
    5182:	00 d0       	rcall	.+0      	; 0x5184 <prvCheckTasksWaitingTermination+0x6>
    5184:	0f 92       	push	r0
    5186:	cd b7       	in	r28, 0x3d	; 61
    5188:	de b7       	in	r29, 0x3e	; 62
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    518a:	80 91 58 07 	lds	r24, 0x0758
    518e:	88 23       	and	r24, r24
    5190:	71 f1       	breq	.+92     	; 0x51ee <prvCheckTasksWaitingTermination+0x70>
		{
			vTaskSuspendAll();
    5192:	0e 94 fd 24 	call	0x49fa	; 0x49fa <vTaskSuspendAll>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    5196:	80 91 b0 07 	lds	r24, 0x07B0
    519a:	1b 82       	std	Y+3, r1	; 0x03
    519c:	88 23       	and	r24, r24
    519e:	11 f4       	brne	.+4      	; 0x51a4 <prvCheckTasksWaitingTermination+0x26>
    51a0:	81 e0       	ldi	r24, 0x01	; 1
    51a2:	8b 83       	std	Y+3, r24	; 0x03
			xTaskResumeAll();
    51a4:	0e 94 09 25 	call	0x4a12	; 0x4a12 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    51a8:	8b 81       	ldd	r24, Y+3	; 0x03
    51aa:	88 23       	and	r24, r24
    51ac:	01 f5       	brne	.+64     	; 0x51ee <prvCheckTasksWaitingTermination+0x70>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    51ae:	0f b6       	in	r0, 0x3f	; 63
    51b0:	f8 94       	cli
    51b2:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    51b4:	e0 91 b5 07 	lds	r30, 0x07B5
    51b8:	f0 91 b6 07 	lds	r31, 0x07B6
    51bc:	86 81       	ldd	r24, Z+6	; 0x06
    51be:	97 81       	ldd	r25, Z+7	; 0x07
    51c0:	9a 83       	std	Y+2, r25	; 0x02
    51c2:	89 83       	std	Y+1, r24	; 0x01
					vListRemove( &( pxTCB->xGenericListItem ) );
    51c4:	89 81       	ldd	r24, Y+1	; 0x01
    51c6:	9a 81       	ldd	r25, Y+2	; 0x02
    51c8:	02 96       	adiw	r24, 0x02	; 2
    51ca:	0e 94 3a 18 	call	0x3074	; 0x3074 <vListRemove>
					--uxCurrentNumberOfTasks;
    51ce:	80 91 59 07 	lds	r24, 0x0759
    51d2:	81 50       	subi	r24, 0x01	; 1
    51d4:	80 93 59 07 	sts	0x0759, r24
					--uxTasksDeleted;
    51d8:	80 91 58 07 	lds	r24, 0x0758
    51dc:	81 50       	subi	r24, 0x01	; 1
    51de:	80 93 58 07 	sts	0x0758, r24
				}
				taskEXIT_CRITICAL();
    51e2:	0f 90       	pop	r0
    51e4:	0f be       	out	0x3f, r0	; 63

				prvDeleteTCB( pxTCB );
    51e6:	89 81       	ldd	r24, Y+1	; 0x01
    51e8:	9a 81       	ldd	r25, Y+2	; 0x02
    51ea:	0e 94 96 29 	call	0x532c	; 0x532c <prvDeleteTCB>
			}
		}
	}
	#endif
}
    51ee:	0f 90       	pop	r0
    51f0:	0f 90       	pop	r0
    51f2:	0f 90       	pop	r0
    51f4:	cf 91       	pop	r28
    51f6:	df 91       	pop	r29
    51f8:	08 95       	ret

000051fa <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    51fa:	df 93       	push	r29
    51fc:	cf 93       	push	r28
    51fe:	00 d0       	rcall	.+0      	; 0x5200 <prvAddCurrentTaskToDelayedList+0x6>
    5200:	cd b7       	in	r28, 0x3d	; 61
    5202:	de b7       	in	r29, 0x3e	; 62
    5204:	9a 83       	std	Y+2, r25	; 0x02
    5206:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    5208:	e0 91 56 07 	lds	r30, 0x0756
    520c:	f0 91 57 07 	lds	r31, 0x0757
    5210:	89 81       	ldd	r24, Y+1	; 0x01
    5212:	9a 81       	ldd	r25, Y+2	; 0x02
    5214:	93 83       	std	Z+3, r25	; 0x03
    5216:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    5218:	20 91 5a 07 	lds	r18, 0x075A
    521c:	30 91 5b 07 	lds	r19, 0x075B
    5220:	89 81       	ldd	r24, Y+1	; 0x01
    5222:	9a 81       	ldd	r25, Y+2	; 0x02
    5224:	82 17       	cp	r24, r18
    5226:	93 07       	cpc	r25, r19
    5228:	70 f4       	brcc	.+28     	; 0x5246 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    522a:	80 91 a5 07 	lds	r24, 0x07A5
    522e:	90 91 a6 07 	lds	r25, 0x07A6
    5232:	20 91 56 07 	lds	r18, 0x0756
    5236:	30 91 57 07 	lds	r19, 0x0757
    523a:	2e 5f       	subi	r18, 0xFE	; 254
    523c:	3f 4f       	sbci	r19, 0xFF	; 255
    523e:	b9 01       	movw	r22, r18
    5240:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>
    5244:	1e c0       	rjmp	.+60     	; 0x5282 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    5246:	40 91 a3 07 	lds	r20, 0x07A3
    524a:	50 91 a4 07 	lds	r21, 0x07A4
    524e:	80 91 56 07 	lds	r24, 0x0756
    5252:	90 91 57 07 	lds	r25, 0x0757
    5256:	9c 01       	movw	r18, r24
    5258:	2e 5f       	subi	r18, 0xFE	; 254
    525a:	3f 4f       	sbci	r19, 0xFF	; 255
    525c:	ca 01       	movw	r24, r20
    525e:	b9 01       	movw	r22, r18
    5260:	0e 94 ce 17 	call	0x2f9c	; 0x2f9c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    5264:	20 91 27 01 	lds	r18, 0x0127
    5268:	30 91 28 01 	lds	r19, 0x0128
    526c:	89 81       	ldd	r24, Y+1	; 0x01
    526e:	9a 81       	ldd	r25, Y+2	; 0x02
    5270:	82 17       	cp	r24, r18
    5272:	93 07       	cpc	r25, r19
    5274:	30 f4       	brcc	.+12     	; 0x5282 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    5276:	89 81       	ldd	r24, Y+1	; 0x01
    5278:	9a 81       	ldd	r25, Y+2	; 0x02
    527a:	90 93 28 01 	sts	0x0128, r25
    527e:	80 93 27 01 	sts	0x0127, r24
		}
	}
}
    5282:	0f 90       	pop	r0
    5284:	0f 90       	pop	r0
    5286:	cf 91       	pop	r28
    5288:	df 91       	pop	r29
    528a:	08 95       	ret

0000528c <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    528c:	df 93       	push	r29
    528e:	cf 93       	push	r28
    5290:	cd b7       	in	r28, 0x3d	; 61
    5292:	de b7       	in	r29, 0x3e	; 62
    5294:	28 97       	sbiw	r28, 0x08	; 8
    5296:	0f b6       	in	r0, 0x3f	; 63
    5298:	f8 94       	cli
    529a:	de bf       	out	0x3e, r29	; 62
    529c:	0f be       	out	0x3f, r0	; 63
    529e:	cd bf       	out	0x3d, r28	; 61
    52a0:	9c 83       	std	Y+4, r25	; 0x04
    52a2:	8b 83       	std	Y+3, r24	; 0x03
    52a4:	7e 83       	std	Y+6, r23	; 0x06
    52a6:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    52a8:	81 e2       	ldi	r24, 0x21	; 33
    52aa:	90 e0       	ldi	r25, 0x00	; 0
    52ac:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <pvPortMalloc>
    52b0:	9a 83       	std	Y+2, r25	; 0x02
    52b2:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    52b4:	89 81       	ldd	r24, Y+1	; 0x01
    52b6:	9a 81       	ldd	r25, Y+2	; 0x02
    52b8:	00 97       	sbiw	r24, 0x00	; 0
    52ba:	69 f1       	breq	.+90     	; 0x5316 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    52bc:	8d 81       	ldd	r24, Y+5	; 0x05
    52be:	9e 81       	ldd	r25, Y+6	; 0x06
    52c0:	00 97       	sbiw	r24, 0x00	; 0
    52c2:	39 f4       	brne	.+14     	; 0x52d2 <prvAllocateTCBAndStack+0x46>
    52c4:	8b 81       	ldd	r24, Y+3	; 0x03
    52c6:	9c 81       	ldd	r25, Y+4	; 0x04
    52c8:	0e 94 d4 15 	call	0x2ba8	; 0x2ba8 <pvPortMalloc>
    52cc:	98 87       	std	Y+8, r25	; 0x08
    52ce:	8f 83       	std	Y+7, r24	; 0x07
    52d0:	04 c0       	rjmp	.+8      	; 0x52da <prvAllocateTCBAndStack+0x4e>
    52d2:	8d 81       	ldd	r24, Y+5	; 0x05
    52d4:	9e 81       	ldd	r25, Y+6	; 0x06
    52d6:	98 87       	std	Y+8, r25	; 0x08
    52d8:	8f 83       	std	Y+7, r24	; 0x07
    52da:	e9 81       	ldd	r30, Y+1	; 0x01
    52dc:	fa 81       	ldd	r31, Y+2	; 0x02
    52de:	8f 81       	ldd	r24, Y+7	; 0x07
    52e0:	98 85       	ldd	r25, Y+8	; 0x08
    52e2:	90 8f       	std	Z+24, r25	; 0x18
    52e4:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    52e6:	e9 81       	ldd	r30, Y+1	; 0x01
    52e8:	fa 81       	ldd	r31, Y+2	; 0x02
    52ea:	87 89       	ldd	r24, Z+23	; 0x17
    52ec:	90 8d       	ldd	r25, Z+24	; 0x18
    52ee:	00 97       	sbiw	r24, 0x00	; 0
    52f0:	39 f4       	brne	.+14     	; 0x5300 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    52f2:	89 81       	ldd	r24, Y+1	; 0x01
    52f4:	9a 81       	ldd	r25, Y+2	; 0x02
    52f6:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
			pxNewTCB = NULL;
    52fa:	1a 82       	std	Y+2, r1	; 0x02
    52fc:	19 82       	std	Y+1, r1	; 0x01
    52fe:	0b c0       	rjmp	.+22     	; 0x5316 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    5300:	e9 81       	ldd	r30, Y+1	; 0x01
    5302:	fa 81       	ldd	r31, Y+2	; 0x02
    5304:	87 89       	ldd	r24, Z+23	; 0x17
    5306:	90 8d       	ldd	r25, Z+24	; 0x18
    5308:	2b 81       	ldd	r18, Y+3	; 0x03
    530a:	3c 81       	ldd	r19, Y+4	; 0x04
    530c:	65 ea       	ldi	r22, 0xA5	; 165
    530e:	70 e0       	ldi	r23, 0x00	; 0
    5310:	a9 01       	movw	r20, r18
    5312:	0e 94 0e 2a 	call	0x541c	; 0x541c <memset>
		}
	}

	return pxNewTCB;
    5316:	89 81       	ldd	r24, Y+1	; 0x01
    5318:	9a 81       	ldd	r25, Y+2	; 0x02
}
    531a:	28 96       	adiw	r28, 0x08	; 8
    531c:	0f b6       	in	r0, 0x3f	; 63
    531e:	f8 94       	cli
    5320:	de bf       	out	0x3e, r29	; 62
    5322:	0f be       	out	0x3f, r0	; 63
    5324:	cd bf       	out	0x3d, r28	; 61
    5326:	cf 91       	pop	r28
    5328:	df 91       	pop	r29
    532a:	08 95       	ret

0000532c <prvDeleteTCB>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	static void prvDeleteTCB( tskTCB *pxTCB )
	{
    532c:	df 93       	push	r29
    532e:	cf 93       	push	r28
    5330:	00 d0       	rcall	.+0      	; 0x5332 <prvDeleteTCB+0x6>
    5332:	cd b7       	in	r28, 0x3d	; 61
    5334:	de b7       	in	r29, 0x3e	; 62
    5336:	9a 83       	std	Y+2, r25	; 0x02
    5338:	89 83       	std	Y+1, r24	; 0x01
		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    533a:	e9 81       	ldd	r30, Y+1	; 0x01
    533c:	fa 81       	ldd	r31, Y+2	; 0x02
    533e:	87 89       	ldd	r24, Z+23	; 0x17
    5340:	90 8d       	ldd	r25, Z+24	; 0x18
    5342:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
		vPortFree( pxTCB );
    5346:	89 81       	ldd	r24, Y+1	; 0x01
    5348:	9a 81       	ldd	r25, Y+2	; 0x02
    534a:	0e 94 1a 16 	call	0x2c34	; 0x2c34 <vPortFree>
	}
    534e:	0f 90       	pop	r0
    5350:	0f 90       	pop	r0
    5352:	cf 91       	pop	r28
    5354:	df 91       	pop	r29
    5356:	08 95       	ret

00005358 <__udivmodsi4>:
    5358:	a1 e2       	ldi	r26, 0x21	; 33
    535a:	1a 2e       	mov	r1, r26
    535c:	aa 1b       	sub	r26, r26
    535e:	bb 1b       	sub	r27, r27
    5360:	fd 01       	movw	r30, r26
    5362:	0d c0       	rjmp	.+26     	; 0x537e <__udivmodsi4_ep>

00005364 <__udivmodsi4_loop>:
    5364:	aa 1f       	adc	r26, r26
    5366:	bb 1f       	adc	r27, r27
    5368:	ee 1f       	adc	r30, r30
    536a:	ff 1f       	adc	r31, r31
    536c:	a2 17       	cp	r26, r18
    536e:	b3 07       	cpc	r27, r19
    5370:	e4 07       	cpc	r30, r20
    5372:	f5 07       	cpc	r31, r21
    5374:	20 f0       	brcs	.+8      	; 0x537e <__udivmodsi4_ep>
    5376:	a2 1b       	sub	r26, r18
    5378:	b3 0b       	sbc	r27, r19
    537a:	e4 0b       	sbc	r30, r20
    537c:	f5 0b       	sbc	r31, r21

0000537e <__udivmodsi4_ep>:
    537e:	66 1f       	adc	r22, r22
    5380:	77 1f       	adc	r23, r23
    5382:	88 1f       	adc	r24, r24
    5384:	99 1f       	adc	r25, r25
    5386:	1a 94       	dec	r1
    5388:	69 f7       	brne	.-38     	; 0x5364 <__udivmodsi4_loop>
    538a:	60 95       	com	r22
    538c:	70 95       	com	r23
    538e:	80 95       	com	r24
    5390:	90 95       	com	r25
    5392:	9b 01       	movw	r18, r22
    5394:	ac 01       	movw	r20, r24
    5396:	bd 01       	movw	r22, r26
    5398:	cf 01       	movw	r24, r30
    539a:	08 95       	ret

0000539c <__prologue_saves__>:
    539c:	2f 92       	push	r2
    539e:	3f 92       	push	r3
    53a0:	4f 92       	push	r4
    53a2:	5f 92       	push	r5
    53a4:	6f 92       	push	r6
    53a6:	7f 92       	push	r7
    53a8:	8f 92       	push	r8
    53aa:	9f 92       	push	r9
    53ac:	af 92       	push	r10
    53ae:	bf 92       	push	r11
    53b0:	cf 92       	push	r12
    53b2:	df 92       	push	r13
    53b4:	ef 92       	push	r14
    53b6:	ff 92       	push	r15
    53b8:	0f 93       	push	r16
    53ba:	1f 93       	push	r17
    53bc:	cf 93       	push	r28
    53be:	df 93       	push	r29
    53c0:	cd b7       	in	r28, 0x3d	; 61
    53c2:	de b7       	in	r29, 0x3e	; 62
    53c4:	ca 1b       	sub	r28, r26
    53c6:	db 0b       	sbc	r29, r27
    53c8:	0f b6       	in	r0, 0x3f	; 63
    53ca:	f8 94       	cli
    53cc:	de bf       	out	0x3e, r29	; 62
    53ce:	0f be       	out	0x3f, r0	; 63
    53d0:	cd bf       	out	0x3d, r28	; 61
    53d2:	09 94       	ijmp

000053d4 <__epilogue_restores__>:
    53d4:	2a 88       	ldd	r2, Y+18	; 0x12
    53d6:	39 88       	ldd	r3, Y+17	; 0x11
    53d8:	48 88       	ldd	r4, Y+16	; 0x10
    53da:	5f 84       	ldd	r5, Y+15	; 0x0f
    53dc:	6e 84       	ldd	r6, Y+14	; 0x0e
    53de:	7d 84       	ldd	r7, Y+13	; 0x0d
    53e0:	8c 84       	ldd	r8, Y+12	; 0x0c
    53e2:	9b 84       	ldd	r9, Y+11	; 0x0b
    53e4:	aa 84       	ldd	r10, Y+10	; 0x0a
    53e6:	b9 84       	ldd	r11, Y+9	; 0x09
    53e8:	c8 84       	ldd	r12, Y+8	; 0x08
    53ea:	df 80       	ldd	r13, Y+7	; 0x07
    53ec:	ee 80       	ldd	r14, Y+6	; 0x06
    53ee:	fd 80       	ldd	r15, Y+5	; 0x05
    53f0:	0c 81       	ldd	r16, Y+4	; 0x04
    53f2:	1b 81       	ldd	r17, Y+3	; 0x03
    53f4:	aa 81       	ldd	r26, Y+2	; 0x02
    53f6:	b9 81       	ldd	r27, Y+1	; 0x01
    53f8:	ce 0f       	add	r28, r30
    53fa:	d1 1d       	adc	r29, r1
    53fc:	0f b6       	in	r0, 0x3f	; 63
    53fe:	f8 94       	cli
    5400:	de bf       	out	0x3e, r29	; 62
    5402:	0f be       	out	0x3f, r0	; 63
    5404:	cd bf       	out	0x3d, r28	; 61
    5406:	ed 01       	movw	r28, r26
    5408:	08 95       	ret

0000540a <memcpy>:
    540a:	fb 01       	movw	r30, r22
    540c:	dc 01       	movw	r26, r24
    540e:	02 c0       	rjmp	.+4      	; 0x5414 <memcpy+0xa>
    5410:	01 90       	ld	r0, Z+
    5412:	0d 92       	st	X+, r0
    5414:	41 50       	subi	r20, 0x01	; 1
    5416:	50 40       	sbci	r21, 0x00	; 0
    5418:	d8 f7       	brcc	.-10     	; 0x5410 <memcpy+0x6>
    541a:	08 95       	ret

0000541c <memset>:
    541c:	dc 01       	movw	r26, r24
    541e:	01 c0       	rjmp	.+2      	; 0x5422 <memset+0x6>
    5420:	6d 93       	st	X+, r22
    5422:	41 50       	subi	r20, 0x01	; 1
    5424:	50 40       	sbci	r21, 0x00	; 0
    5426:	e0 f7       	brcc	.-8      	; 0x5420 <memset+0x4>
    5428:	08 95       	ret

0000542a <strncpy>:
    542a:	fb 01       	movw	r30, r22
    542c:	dc 01       	movw	r26, r24
    542e:	41 50       	subi	r20, 0x01	; 1
    5430:	50 40       	sbci	r21, 0x00	; 0
    5432:	48 f0       	brcs	.+18     	; 0x5446 <strncpy+0x1c>
    5434:	01 90       	ld	r0, Z+
    5436:	0d 92       	st	X+, r0
    5438:	00 20       	and	r0, r0
    543a:	c9 f7       	brne	.-14     	; 0x542e <strncpy+0x4>
    543c:	01 c0       	rjmp	.+2      	; 0x5440 <strncpy+0x16>
    543e:	1d 92       	st	X+, r1
    5440:	41 50       	subi	r20, 0x01	; 1
    5442:	50 40       	sbci	r21, 0x00	; 0
    5444:	e0 f7       	brcc	.-8      	; 0x543e <strncpy+0x14>
    5446:	08 95       	ret

00005448 <_exit>:
    5448:	f8 94       	cli

0000544a <__stop_program>:
    544a:	ff cf       	rjmp	.-2      	; 0x544a <__stop_program>
